// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: envoy/api/v2/auth/cert.proto

package envoy.api.v2.auth;

public final class Cert {
  private Cert() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface TlsParametersOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.auth.TlsParameters)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Minimum TLS protocol version.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1 [(.validate.rules) = { ... }</code>
     */
    int getTlsMinimumProtocolVersionValue();
    /**
     * <pre>
     * Minimum TLS protocol version.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1 [(.validate.rules) = { ... }</code>
     */
    envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol getTlsMinimumProtocolVersion();

    /**
     * <pre>
     * Maximum TLS protocol version.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2 [(.validate.rules) = { ... }</code>
     */
    int getTlsMaximumProtocolVersionValue();
    /**
     * <pre>
     * Maximum TLS protocol version.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2 [(.validate.rules) = { ... }</code>
     */
    envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol getTlsMaximumProtocolVersion();

    /**
     * <pre>
     * If specified, the TLS listener will only support the specified `cipher list
     * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
     * If not specified, the default list:
     * .. code-block:: none
     *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
     *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
     *   ECDHE-ECDSA-AES128-SHA
     *   ECDHE-RSA-AES128-SHA
     *   AES128-GCM-SHA256
     *   AES128-SHA
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *   ECDHE-ECDSA-AES256-SHA
     *   ECDHE-RSA-AES256-SHA
     *   AES256-GCM-SHA384
     *   AES256-SHA
     * will be used.
     * </pre>
     *
     * <code>repeated string cipher_suites = 3;</code>
     */
    java.util.List<java.lang.String>
        getCipherSuitesList();
    /**
     * <pre>
     * If specified, the TLS listener will only support the specified `cipher list
     * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
     * If not specified, the default list:
     * .. code-block:: none
     *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
     *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
     *   ECDHE-ECDSA-AES128-SHA
     *   ECDHE-RSA-AES128-SHA
     *   AES128-GCM-SHA256
     *   AES128-SHA
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *   ECDHE-ECDSA-AES256-SHA
     *   ECDHE-RSA-AES256-SHA
     *   AES256-GCM-SHA384
     *   AES256-SHA
     * will be used.
     * </pre>
     *
     * <code>repeated string cipher_suites = 3;</code>
     */
    int getCipherSuitesCount();
    /**
     * <pre>
     * If specified, the TLS listener will only support the specified `cipher list
     * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
     * If not specified, the default list:
     * .. code-block:: none
     *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
     *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
     *   ECDHE-ECDSA-AES128-SHA
     *   ECDHE-RSA-AES128-SHA
     *   AES128-GCM-SHA256
     *   AES128-SHA
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *   ECDHE-ECDSA-AES256-SHA
     *   ECDHE-RSA-AES256-SHA
     *   AES256-GCM-SHA384
     *   AES256-SHA
     * will be used.
     * </pre>
     *
     * <code>repeated string cipher_suites = 3;</code>
     */
    java.lang.String getCipherSuites(int index);
    /**
     * <pre>
     * If specified, the TLS listener will only support the specified `cipher list
     * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
     * If not specified, the default list:
     * .. code-block:: none
     *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
     *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
     *   ECDHE-ECDSA-AES128-SHA
     *   ECDHE-RSA-AES128-SHA
     *   AES128-GCM-SHA256
     *   AES128-SHA
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *   ECDHE-ECDSA-AES256-SHA
     *   ECDHE-RSA-AES256-SHA
     *   AES256-GCM-SHA384
     *   AES256-SHA
     * will be used.
     * </pre>
     *
     * <code>repeated string cipher_suites = 3;</code>
     */
    com.google.protobuf.ByteString
        getCipherSuitesBytes(int index);

    /**
     * <pre>
     * If specified, the TLS connection will only support the specified ECDH
     * curves. If not specified, the default curves (X25519, P-256) will be used.
     * </pre>
     *
     * <code>repeated string ecdh_curves = 4;</code>
     */
    java.util.List<java.lang.String>
        getEcdhCurvesList();
    /**
     * <pre>
     * If specified, the TLS connection will only support the specified ECDH
     * curves. If not specified, the default curves (X25519, P-256) will be used.
     * </pre>
     *
     * <code>repeated string ecdh_curves = 4;</code>
     */
    int getEcdhCurvesCount();
    /**
     * <pre>
     * If specified, the TLS connection will only support the specified ECDH
     * curves. If not specified, the default curves (X25519, P-256) will be used.
     * </pre>
     *
     * <code>repeated string ecdh_curves = 4;</code>
     */
    java.lang.String getEcdhCurves(int index);
    /**
     * <pre>
     * If specified, the TLS connection will only support the specified ECDH
     * curves. If not specified, the default curves (X25519, P-256) will be used.
     * </pre>
     *
     * <code>repeated string ecdh_curves = 4;</code>
     */
    com.google.protobuf.ByteString
        getEcdhCurvesBytes(int index);
  }
  /**
   * Protobuf type {@code envoy.api.v2.auth.TlsParameters}
   */
  public  static final class TlsParameters extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.auth.TlsParameters)
      TlsParametersOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TlsParameters.newBuilder() to construct.
    private TlsParameters(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TlsParameters() {
      tlsMinimumProtocolVersion_ = 0;
      tlsMaximumProtocolVersion_ = 0;
      cipherSuites_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      ecdhCurves_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TlsParameters(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              int rawValue = input.readEnum();

              tlsMinimumProtocolVersion_ = rawValue;
              break;
            }
            case 16: {
              int rawValue = input.readEnum();

              tlsMaximumProtocolVersion_ = rawValue;
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                cipherSuites_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000004;
              }
              cipherSuites_.add(s);
              break;
            }
            case 34: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                ecdhCurves_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000008;
              }
              ecdhCurves_.add(s);
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          cipherSuites_ = cipherSuites_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          ecdhCurves_ = ecdhCurves_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsParameters_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsParameters_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              envoy.api.v2.auth.Cert.TlsParameters.class, envoy.api.v2.auth.Cert.TlsParameters.Builder.class);
    }

    /**
     * Protobuf enum {@code envoy.api.v2.auth.TlsParameters.TlsProtocol}
     */
    public enum TlsProtocol
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Envoy will choose the optimal TLS version.
       * </pre>
       *
       * <code>TLS_AUTO = 0;</code>
       */
      TLS_AUTO(0),
      /**
       * <pre>
       * TLS 1.0
       * </pre>
       *
       * <code>TLSv1_0 = 1;</code>
       */
      TLSv1_0(1),
      /**
       * <pre>
       * TLS 1.1
       * </pre>
       *
       * <code>TLSv1_1 = 2;</code>
       */
      TLSv1_1(2),
      /**
       * <pre>
       * TLS 1.2
       * </pre>
       *
       * <code>TLSv1_2 = 3;</code>
       */
      TLSv1_2(3),
      /**
       * <pre>
       * TLS 1.3
       * </pre>
       *
       * <code>TLSv1_3 = 4;</code>
       */
      TLSv1_3(4),
      UNRECOGNIZED(-1),
      ;

      /**
       * <pre>
       * Envoy will choose the optimal TLS version.
       * </pre>
       *
       * <code>TLS_AUTO = 0;</code>
       */
      public static final int TLS_AUTO_VALUE = 0;
      /**
       * <pre>
       * TLS 1.0
       * </pre>
       *
       * <code>TLSv1_0 = 1;</code>
       */
      public static final int TLSv1_0_VALUE = 1;
      /**
       * <pre>
       * TLS 1.1
       * </pre>
       *
       * <code>TLSv1_1 = 2;</code>
       */
      public static final int TLSv1_1_VALUE = 2;
      /**
       * <pre>
       * TLS 1.2
       * </pre>
       *
       * <code>TLSv1_2 = 3;</code>
       */
      public static final int TLSv1_2_VALUE = 3;
      /**
       * <pre>
       * TLS 1.3
       * </pre>
       *
       * <code>TLSv1_3 = 4;</code>
       */
      public static final int TLSv1_3_VALUE = 4;


      public final int getNumber() {
        if (this == UNRECOGNIZED) {
          throw new java.lang.IllegalArgumentException(
              "Can't get the number of an unknown enum value.");
        }
        return value;
      }

      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TlsProtocol valueOf(int value) {
        return forNumber(value);
      }

      public static TlsProtocol forNumber(int value) {
        switch (value) {
          case 0: return TLS_AUTO;
          case 1: return TLSv1_0;
          case 2: return TLSv1_1;
          case 3: return TLSv1_2;
          case 4: return TLSv1_3;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<TlsProtocol>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          TlsProtocol> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<TlsProtocol>() {
              public TlsProtocol findValueByNumber(int number) {
                return TlsProtocol.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return envoy.api.v2.auth.Cert.TlsParameters.getDescriptor().getEnumTypes().get(0);
      }

      private static final TlsProtocol[] VALUES = values();

      public static TlsProtocol valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        if (desc.getIndex() == -1) {
          return UNRECOGNIZED;
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private TlsProtocol(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:envoy.api.v2.auth.TlsParameters.TlsProtocol)
    }

    private int bitField0_;
    public static final int TLS_MINIMUM_PROTOCOL_VERSION_FIELD_NUMBER = 1;
    private int tlsMinimumProtocolVersion_;
    /**
     * <pre>
     * Minimum TLS protocol version.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1 [(.validate.rules) = { ... }</code>
     */
    public int getTlsMinimumProtocolVersionValue() {
      return tlsMinimumProtocolVersion_;
    }
    /**
     * <pre>
     * Minimum TLS protocol version.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1 [(.validate.rules) = { ... }</code>
     */
    public envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol getTlsMinimumProtocolVersion() {
      envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol result = envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol.valueOf(tlsMinimumProtocolVersion_);
      return result == null ? envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol.UNRECOGNIZED : result;
    }

    public static final int TLS_MAXIMUM_PROTOCOL_VERSION_FIELD_NUMBER = 2;
    private int tlsMaximumProtocolVersion_;
    /**
     * <pre>
     * Maximum TLS protocol version.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2 [(.validate.rules) = { ... }</code>
     */
    public int getTlsMaximumProtocolVersionValue() {
      return tlsMaximumProtocolVersion_;
    }
    /**
     * <pre>
     * Maximum TLS protocol version.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2 [(.validate.rules) = { ... }</code>
     */
    public envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol getTlsMaximumProtocolVersion() {
      envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol result = envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol.valueOf(tlsMaximumProtocolVersion_);
      return result == null ? envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol.UNRECOGNIZED : result;
    }

    public static final int CIPHER_SUITES_FIELD_NUMBER = 3;
    private com.google.protobuf.LazyStringList cipherSuites_;
    /**
     * <pre>
     * If specified, the TLS listener will only support the specified `cipher list
     * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
     * If not specified, the default list:
     * .. code-block:: none
     *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
     *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
     *   ECDHE-ECDSA-AES128-SHA
     *   ECDHE-RSA-AES128-SHA
     *   AES128-GCM-SHA256
     *   AES128-SHA
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *   ECDHE-ECDSA-AES256-SHA
     *   ECDHE-RSA-AES256-SHA
     *   AES256-GCM-SHA384
     *   AES256-SHA
     * will be used.
     * </pre>
     *
     * <code>repeated string cipher_suites = 3;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getCipherSuitesList() {
      return cipherSuites_;
    }
    /**
     * <pre>
     * If specified, the TLS listener will only support the specified `cipher list
     * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
     * If not specified, the default list:
     * .. code-block:: none
     *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
     *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
     *   ECDHE-ECDSA-AES128-SHA
     *   ECDHE-RSA-AES128-SHA
     *   AES128-GCM-SHA256
     *   AES128-SHA
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *   ECDHE-ECDSA-AES256-SHA
     *   ECDHE-RSA-AES256-SHA
     *   AES256-GCM-SHA384
     *   AES256-SHA
     * will be used.
     * </pre>
     *
     * <code>repeated string cipher_suites = 3;</code>
     */
    public int getCipherSuitesCount() {
      return cipherSuites_.size();
    }
    /**
     * <pre>
     * If specified, the TLS listener will only support the specified `cipher list
     * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
     * If not specified, the default list:
     * .. code-block:: none
     *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
     *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
     *   ECDHE-ECDSA-AES128-SHA
     *   ECDHE-RSA-AES128-SHA
     *   AES128-GCM-SHA256
     *   AES128-SHA
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *   ECDHE-ECDSA-AES256-SHA
     *   ECDHE-RSA-AES256-SHA
     *   AES256-GCM-SHA384
     *   AES256-SHA
     * will be used.
     * </pre>
     *
     * <code>repeated string cipher_suites = 3;</code>
     */
    public java.lang.String getCipherSuites(int index) {
      return cipherSuites_.get(index);
    }
    /**
     * <pre>
     * If specified, the TLS listener will only support the specified `cipher list
     * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
     * If not specified, the default list:
     * .. code-block:: none
     *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
     *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
     *   ECDHE-ECDSA-AES128-SHA
     *   ECDHE-RSA-AES128-SHA
     *   AES128-GCM-SHA256
     *   AES128-SHA
     *   ECDHE-ECDSA-AES256-GCM-SHA384
     *   ECDHE-RSA-AES256-GCM-SHA384
     *   ECDHE-ECDSA-AES256-SHA
     *   ECDHE-RSA-AES256-SHA
     *   AES256-GCM-SHA384
     *   AES256-SHA
     * will be used.
     * </pre>
     *
     * <code>repeated string cipher_suites = 3;</code>
     */
    public com.google.protobuf.ByteString
        getCipherSuitesBytes(int index) {
      return cipherSuites_.getByteString(index);
    }

    public static final int ECDH_CURVES_FIELD_NUMBER = 4;
    private com.google.protobuf.LazyStringList ecdhCurves_;
    /**
     * <pre>
     * If specified, the TLS connection will only support the specified ECDH
     * curves. If not specified, the default curves (X25519, P-256) will be used.
     * </pre>
     *
     * <code>repeated string ecdh_curves = 4;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getEcdhCurvesList() {
      return ecdhCurves_;
    }
    /**
     * <pre>
     * If specified, the TLS connection will only support the specified ECDH
     * curves. If not specified, the default curves (X25519, P-256) will be used.
     * </pre>
     *
     * <code>repeated string ecdh_curves = 4;</code>
     */
    public int getEcdhCurvesCount() {
      return ecdhCurves_.size();
    }
    /**
     * <pre>
     * If specified, the TLS connection will only support the specified ECDH
     * curves. If not specified, the default curves (X25519, P-256) will be used.
     * </pre>
     *
     * <code>repeated string ecdh_curves = 4;</code>
     */
    public java.lang.String getEcdhCurves(int index) {
      return ecdhCurves_.get(index);
    }
    /**
     * <pre>
     * If specified, the TLS connection will only support the specified ECDH
     * curves. If not specified, the default curves (X25519, P-256) will be used.
     * </pre>
     *
     * <code>repeated string ecdh_curves = 4;</code>
     */
    public com.google.protobuf.ByteString
        getEcdhCurvesBytes(int index) {
      return ecdhCurves_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (tlsMinimumProtocolVersion_ != envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol.TLS_AUTO.getNumber()) {
        output.writeEnum(1, tlsMinimumProtocolVersion_);
      }
      if (tlsMaximumProtocolVersion_ != envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol.TLS_AUTO.getNumber()) {
        output.writeEnum(2, tlsMaximumProtocolVersion_);
      }
      for (int i = 0; i < cipherSuites_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, cipherSuites_.getRaw(i));
      }
      for (int i = 0; i < ecdhCurves_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, ecdhCurves_.getRaw(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (tlsMinimumProtocolVersion_ != envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol.TLS_AUTO.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, tlsMinimumProtocolVersion_);
      }
      if (tlsMaximumProtocolVersion_ != envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol.TLS_AUTO.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, tlsMaximumProtocolVersion_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < cipherSuites_.size(); i++) {
          dataSize += computeStringSizeNoTag(cipherSuites_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getCipherSuitesList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < ecdhCurves_.size(); i++) {
          dataSize += computeStringSizeNoTag(ecdhCurves_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getEcdhCurvesList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof envoy.api.v2.auth.Cert.TlsParameters)) {
        return super.equals(obj);
      }
      envoy.api.v2.auth.Cert.TlsParameters other = (envoy.api.v2.auth.Cert.TlsParameters) obj;

      boolean result = true;
      result = result && tlsMinimumProtocolVersion_ == other.tlsMinimumProtocolVersion_;
      result = result && tlsMaximumProtocolVersion_ == other.tlsMaximumProtocolVersion_;
      result = result && getCipherSuitesList()
          .equals(other.getCipherSuitesList());
      result = result && getEcdhCurvesList()
          .equals(other.getEcdhCurvesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TLS_MINIMUM_PROTOCOL_VERSION_FIELD_NUMBER;
      hash = (53 * hash) + tlsMinimumProtocolVersion_;
      hash = (37 * hash) + TLS_MAXIMUM_PROTOCOL_VERSION_FIELD_NUMBER;
      hash = (53 * hash) + tlsMaximumProtocolVersion_;
      if (getCipherSuitesCount() > 0) {
        hash = (37 * hash) + CIPHER_SUITES_FIELD_NUMBER;
        hash = (53 * hash) + getCipherSuitesList().hashCode();
      }
      if (getEcdhCurvesCount() > 0) {
        hash = (37 * hash) + ECDH_CURVES_FIELD_NUMBER;
        hash = (53 * hash) + getEcdhCurvesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static envoy.api.v2.auth.Cert.TlsParameters parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.TlsParameters parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsParameters parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.TlsParameters parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsParameters parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.TlsParameters parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsParameters parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.TlsParameters parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsParameters parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.TlsParameters parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsParameters parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.TlsParameters parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(envoy.api.v2.auth.Cert.TlsParameters prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code envoy.api.v2.auth.TlsParameters}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.auth.TlsParameters)
        envoy.api.v2.auth.Cert.TlsParametersOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsParameters_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsParameters_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                envoy.api.v2.auth.Cert.TlsParameters.class, envoy.api.v2.auth.Cert.TlsParameters.Builder.class);
      }

      // Construct using envoy.api.v2.auth.Cert.TlsParameters.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        tlsMinimumProtocolVersion_ = 0;

        tlsMaximumProtocolVersion_ = 0;

        cipherSuites_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        ecdhCurves_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsParameters_descriptor;
      }

      public envoy.api.v2.auth.Cert.TlsParameters getDefaultInstanceForType() {
        return envoy.api.v2.auth.Cert.TlsParameters.getDefaultInstance();
      }

      public envoy.api.v2.auth.Cert.TlsParameters build() {
        envoy.api.v2.auth.Cert.TlsParameters result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public envoy.api.v2.auth.Cert.TlsParameters buildPartial() {
        envoy.api.v2.auth.Cert.TlsParameters result = new envoy.api.v2.auth.Cert.TlsParameters(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.tlsMinimumProtocolVersion_ = tlsMinimumProtocolVersion_;
        result.tlsMaximumProtocolVersion_ = tlsMaximumProtocolVersion_;
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          cipherSuites_ = cipherSuites_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.cipherSuites_ = cipherSuites_;
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
          ecdhCurves_ = ecdhCurves_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.ecdhCurves_ = ecdhCurves_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof envoy.api.v2.auth.Cert.TlsParameters) {
          return mergeFrom((envoy.api.v2.auth.Cert.TlsParameters)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(envoy.api.v2.auth.Cert.TlsParameters other) {
        if (other == envoy.api.v2.auth.Cert.TlsParameters.getDefaultInstance()) return this;
        if (other.tlsMinimumProtocolVersion_ != 0) {
          setTlsMinimumProtocolVersionValue(other.getTlsMinimumProtocolVersionValue());
        }
        if (other.tlsMaximumProtocolVersion_ != 0) {
          setTlsMaximumProtocolVersionValue(other.getTlsMaximumProtocolVersionValue());
        }
        if (!other.cipherSuites_.isEmpty()) {
          if (cipherSuites_.isEmpty()) {
            cipherSuites_ = other.cipherSuites_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureCipherSuitesIsMutable();
            cipherSuites_.addAll(other.cipherSuites_);
          }
          onChanged();
        }
        if (!other.ecdhCurves_.isEmpty()) {
          if (ecdhCurves_.isEmpty()) {
            ecdhCurves_ = other.ecdhCurves_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureEcdhCurvesIsMutable();
            ecdhCurves_.addAll(other.ecdhCurves_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        envoy.api.v2.auth.Cert.TlsParameters parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (envoy.api.v2.auth.Cert.TlsParameters) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int tlsMinimumProtocolVersion_ = 0;
      /**
       * <pre>
       * Minimum TLS protocol version.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1 [(.validate.rules) = { ... }</code>
       */
      public int getTlsMinimumProtocolVersionValue() {
        return tlsMinimumProtocolVersion_;
      }
      /**
       * <pre>
       * Minimum TLS protocol version.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setTlsMinimumProtocolVersionValue(int value) {
        tlsMinimumProtocolVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Minimum TLS protocol version.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1 [(.validate.rules) = { ... }</code>
       */
      public envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol getTlsMinimumProtocolVersion() {
        envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol result = envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol.valueOf(tlsMinimumProtocolVersion_);
        return result == null ? envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Minimum TLS protocol version.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setTlsMinimumProtocolVersion(envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        tlsMinimumProtocolVersion_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Minimum TLS protocol version.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_minimum_protocol_version = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder clearTlsMinimumProtocolVersion() {
        
        tlsMinimumProtocolVersion_ = 0;
        onChanged();
        return this;
      }

      private int tlsMaximumProtocolVersion_ = 0;
      /**
       * <pre>
       * Maximum TLS protocol version.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2 [(.validate.rules) = { ... }</code>
       */
      public int getTlsMaximumProtocolVersionValue() {
        return tlsMaximumProtocolVersion_;
      }
      /**
       * <pre>
       * Maximum TLS protocol version.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder setTlsMaximumProtocolVersionValue(int value) {
        tlsMaximumProtocolVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum TLS protocol version.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2 [(.validate.rules) = { ... }</code>
       */
      public envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol getTlsMaximumProtocolVersion() {
        envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol result = envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol.valueOf(tlsMaximumProtocolVersion_);
        return result == null ? envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * Maximum TLS protocol version.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder setTlsMaximumProtocolVersion(envoy.api.v2.auth.Cert.TlsParameters.TlsProtocol value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        tlsMaximumProtocolVersion_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum TLS protocol version.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters.TlsProtocol tls_maximum_protocol_version = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder clearTlsMaximumProtocolVersion() {
        
        tlsMaximumProtocolVersion_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList cipherSuites_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureCipherSuitesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          cipherSuites_ = new com.google.protobuf.LazyStringArrayList(cipherSuites_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       * If specified, the TLS listener will only support the specified `cipher list
       * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
       * If not specified, the default list:
       * .. code-block:: none
       *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
       *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
       *   ECDHE-ECDSA-AES128-SHA
       *   ECDHE-RSA-AES128-SHA
       *   AES128-GCM-SHA256
       *   AES128-SHA
       *   ECDHE-ECDSA-AES256-GCM-SHA384
       *   ECDHE-RSA-AES256-GCM-SHA384
       *   ECDHE-ECDSA-AES256-SHA
       *   ECDHE-RSA-AES256-SHA
       *   AES256-GCM-SHA384
       *   AES256-SHA
       * will be used.
       * </pre>
       *
       * <code>repeated string cipher_suites = 3;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getCipherSuitesList() {
        return cipherSuites_.getUnmodifiableView();
      }
      /**
       * <pre>
       * If specified, the TLS listener will only support the specified `cipher list
       * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
       * If not specified, the default list:
       * .. code-block:: none
       *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
       *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
       *   ECDHE-ECDSA-AES128-SHA
       *   ECDHE-RSA-AES128-SHA
       *   AES128-GCM-SHA256
       *   AES128-SHA
       *   ECDHE-ECDSA-AES256-GCM-SHA384
       *   ECDHE-RSA-AES256-GCM-SHA384
       *   ECDHE-ECDSA-AES256-SHA
       *   ECDHE-RSA-AES256-SHA
       *   AES256-GCM-SHA384
       *   AES256-SHA
       * will be used.
       * </pre>
       *
       * <code>repeated string cipher_suites = 3;</code>
       */
      public int getCipherSuitesCount() {
        return cipherSuites_.size();
      }
      /**
       * <pre>
       * If specified, the TLS listener will only support the specified `cipher list
       * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
       * If not specified, the default list:
       * .. code-block:: none
       *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
       *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
       *   ECDHE-ECDSA-AES128-SHA
       *   ECDHE-RSA-AES128-SHA
       *   AES128-GCM-SHA256
       *   AES128-SHA
       *   ECDHE-ECDSA-AES256-GCM-SHA384
       *   ECDHE-RSA-AES256-GCM-SHA384
       *   ECDHE-ECDSA-AES256-SHA
       *   ECDHE-RSA-AES256-SHA
       *   AES256-GCM-SHA384
       *   AES256-SHA
       * will be used.
       * </pre>
       *
       * <code>repeated string cipher_suites = 3;</code>
       */
      public java.lang.String getCipherSuites(int index) {
        return cipherSuites_.get(index);
      }
      /**
       * <pre>
       * If specified, the TLS listener will only support the specified `cipher list
       * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
       * If not specified, the default list:
       * .. code-block:: none
       *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
       *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
       *   ECDHE-ECDSA-AES128-SHA
       *   ECDHE-RSA-AES128-SHA
       *   AES128-GCM-SHA256
       *   AES128-SHA
       *   ECDHE-ECDSA-AES256-GCM-SHA384
       *   ECDHE-RSA-AES256-GCM-SHA384
       *   ECDHE-ECDSA-AES256-SHA
       *   ECDHE-RSA-AES256-SHA
       *   AES256-GCM-SHA384
       *   AES256-SHA
       * will be used.
       * </pre>
       *
       * <code>repeated string cipher_suites = 3;</code>
       */
      public com.google.protobuf.ByteString
          getCipherSuitesBytes(int index) {
        return cipherSuites_.getByteString(index);
      }
      /**
       * <pre>
       * If specified, the TLS listener will only support the specified `cipher list
       * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
       * If not specified, the default list:
       * .. code-block:: none
       *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
       *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
       *   ECDHE-ECDSA-AES128-SHA
       *   ECDHE-RSA-AES128-SHA
       *   AES128-GCM-SHA256
       *   AES128-SHA
       *   ECDHE-ECDSA-AES256-GCM-SHA384
       *   ECDHE-RSA-AES256-GCM-SHA384
       *   ECDHE-ECDSA-AES256-SHA
       *   ECDHE-RSA-AES256-SHA
       *   AES256-GCM-SHA384
       *   AES256-SHA
       * will be used.
       * </pre>
       *
       * <code>repeated string cipher_suites = 3;</code>
       */
      public Builder setCipherSuites(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureCipherSuitesIsMutable();
        cipherSuites_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the TLS listener will only support the specified `cipher list
       * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
       * If not specified, the default list:
       * .. code-block:: none
       *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
       *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
       *   ECDHE-ECDSA-AES128-SHA
       *   ECDHE-RSA-AES128-SHA
       *   AES128-GCM-SHA256
       *   AES128-SHA
       *   ECDHE-ECDSA-AES256-GCM-SHA384
       *   ECDHE-RSA-AES256-GCM-SHA384
       *   ECDHE-ECDSA-AES256-SHA
       *   ECDHE-RSA-AES256-SHA
       *   AES256-GCM-SHA384
       *   AES256-SHA
       * will be used.
       * </pre>
       *
       * <code>repeated string cipher_suites = 3;</code>
       */
      public Builder addCipherSuites(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureCipherSuitesIsMutable();
        cipherSuites_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the TLS listener will only support the specified `cipher list
       * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
       * If not specified, the default list:
       * .. code-block:: none
       *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
       *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
       *   ECDHE-ECDSA-AES128-SHA
       *   ECDHE-RSA-AES128-SHA
       *   AES128-GCM-SHA256
       *   AES128-SHA
       *   ECDHE-ECDSA-AES256-GCM-SHA384
       *   ECDHE-RSA-AES256-GCM-SHA384
       *   ECDHE-ECDSA-AES256-SHA
       *   ECDHE-RSA-AES256-SHA
       *   AES256-GCM-SHA384
       *   AES256-SHA
       * will be used.
       * </pre>
       *
       * <code>repeated string cipher_suites = 3;</code>
       */
      public Builder addAllCipherSuites(
          java.lang.Iterable<java.lang.String> values) {
        ensureCipherSuitesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, cipherSuites_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the TLS listener will only support the specified `cipher list
       * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
       * If not specified, the default list:
       * .. code-block:: none
       *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
       *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
       *   ECDHE-ECDSA-AES128-SHA
       *   ECDHE-RSA-AES128-SHA
       *   AES128-GCM-SHA256
       *   AES128-SHA
       *   ECDHE-ECDSA-AES256-GCM-SHA384
       *   ECDHE-RSA-AES256-GCM-SHA384
       *   ECDHE-ECDSA-AES256-SHA
       *   ECDHE-RSA-AES256-SHA
       *   AES256-GCM-SHA384
       *   AES256-SHA
       * will be used.
       * </pre>
       *
       * <code>repeated string cipher_suites = 3;</code>
       */
      public Builder clearCipherSuites() {
        cipherSuites_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the TLS listener will only support the specified `cipher list
       * &lt;https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration&gt;`_.
       * If not specified, the default list:
       * .. code-block:: none
       *   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
       *   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
       *   ECDHE-ECDSA-AES128-SHA
       *   ECDHE-RSA-AES128-SHA
       *   AES128-GCM-SHA256
       *   AES128-SHA
       *   ECDHE-ECDSA-AES256-GCM-SHA384
       *   ECDHE-RSA-AES256-GCM-SHA384
       *   ECDHE-ECDSA-AES256-SHA
       *   ECDHE-RSA-AES256-SHA
       *   AES256-GCM-SHA384
       *   AES256-SHA
       * will be used.
       * </pre>
       *
       * <code>repeated string cipher_suites = 3;</code>
       */
      public Builder addCipherSuitesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureCipherSuitesIsMutable();
        cipherSuites_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList ecdhCurves_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureEcdhCurvesIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          ecdhCurves_ = new com.google.protobuf.LazyStringArrayList(ecdhCurves_);
          bitField0_ |= 0x00000008;
         }
      }
      /**
       * <pre>
       * If specified, the TLS connection will only support the specified ECDH
       * curves. If not specified, the default curves (X25519, P-256) will be used.
       * </pre>
       *
       * <code>repeated string ecdh_curves = 4;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getEcdhCurvesList() {
        return ecdhCurves_.getUnmodifiableView();
      }
      /**
       * <pre>
       * If specified, the TLS connection will only support the specified ECDH
       * curves. If not specified, the default curves (X25519, P-256) will be used.
       * </pre>
       *
       * <code>repeated string ecdh_curves = 4;</code>
       */
      public int getEcdhCurvesCount() {
        return ecdhCurves_.size();
      }
      /**
       * <pre>
       * If specified, the TLS connection will only support the specified ECDH
       * curves. If not specified, the default curves (X25519, P-256) will be used.
       * </pre>
       *
       * <code>repeated string ecdh_curves = 4;</code>
       */
      public java.lang.String getEcdhCurves(int index) {
        return ecdhCurves_.get(index);
      }
      /**
       * <pre>
       * If specified, the TLS connection will only support the specified ECDH
       * curves. If not specified, the default curves (X25519, P-256) will be used.
       * </pre>
       *
       * <code>repeated string ecdh_curves = 4;</code>
       */
      public com.google.protobuf.ByteString
          getEcdhCurvesBytes(int index) {
        return ecdhCurves_.getByteString(index);
      }
      /**
       * <pre>
       * If specified, the TLS connection will only support the specified ECDH
       * curves. If not specified, the default curves (X25519, P-256) will be used.
       * </pre>
       *
       * <code>repeated string ecdh_curves = 4;</code>
       */
      public Builder setEcdhCurves(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureEcdhCurvesIsMutable();
        ecdhCurves_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the TLS connection will only support the specified ECDH
       * curves. If not specified, the default curves (X25519, P-256) will be used.
       * </pre>
       *
       * <code>repeated string ecdh_curves = 4;</code>
       */
      public Builder addEcdhCurves(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureEcdhCurvesIsMutable();
        ecdhCurves_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the TLS connection will only support the specified ECDH
       * curves. If not specified, the default curves (X25519, P-256) will be used.
       * </pre>
       *
       * <code>repeated string ecdh_curves = 4;</code>
       */
      public Builder addAllEcdhCurves(
          java.lang.Iterable<java.lang.String> values) {
        ensureEcdhCurvesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, ecdhCurves_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the TLS connection will only support the specified ECDH
       * curves. If not specified, the default curves (X25519, P-256) will be used.
       * </pre>
       *
       * <code>repeated string ecdh_curves = 4;</code>
       */
      public Builder clearEcdhCurves() {
        ecdhCurves_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, the TLS connection will only support the specified ECDH
       * curves. If not specified, the default curves (X25519, P-256) will be used.
       * </pre>
       *
       * <code>repeated string ecdh_curves = 4;</code>
       */
      public Builder addEcdhCurvesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureEcdhCurvesIsMutable();
        ecdhCurves_.add(value);
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.auth.TlsParameters)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.auth.TlsParameters)
    private static final envoy.api.v2.auth.Cert.TlsParameters DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new envoy.api.v2.auth.Cert.TlsParameters();
    }

    public static envoy.api.v2.auth.Cert.TlsParameters getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TlsParameters>
        PARSER = new com.google.protobuf.AbstractParser<TlsParameters>() {
      public TlsParameters parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TlsParameters(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<TlsParameters> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TlsParameters> getParserForType() {
      return PARSER;
    }

    public envoy.api.v2.auth.Cert.TlsParameters getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TlsCertificateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.auth.TlsCertificate)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The TLS certificate chain.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
     */
    boolean hasCertificateChain();
    /**
     * <pre>
     * The TLS certificate chain.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
     */
    envoy.api.v2.core.Base.DataSource getCertificateChain();
    /**
     * <pre>
     * The TLS certificate chain.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
     */
    envoy.api.v2.core.Base.DataSourceOrBuilder getCertificateChainOrBuilder();

    /**
     * <pre>
     * The TLS private key.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
     */
    boolean hasPrivateKey();
    /**
     * <pre>
     * The TLS private key.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
     */
    envoy.api.v2.core.Base.DataSource getPrivateKey();
    /**
     * <pre>
     * The TLS private key.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
     */
    envoy.api.v2.core.Base.DataSourceOrBuilder getPrivateKeyOrBuilder();

    /**
     * <pre>
     * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
     * TLS private key is not password encrypted.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource password = 3;</code>
     */
    boolean hasPassword();
    /**
     * <pre>
     * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
     * TLS private key is not password encrypted.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource password = 3;</code>
     */
    envoy.api.v2.core.Base.DataSource getPassword();
    /**
     * <pre>
     * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
     * TLS private key is not password encrypted.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource password = 3;</code>
     */
    envoy.api.v2.core.Base.DataSourceOrBuilder getPasswordOrBuilder();

    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
     */
    boolean hasOcspStaple();
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
     */
    envoy.api.v2.core.Base.DataSource getOcspStaple();
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
     */
    envoy.api.v2.core.Base.DataSourceOrBuilder getOcspStapleOrBuilder();

    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
     */
    java.util.List<envoy.api.v2.core.Base.DataSource> 
        getSignedCertificateTimestampList();
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
     */
    envoy.api.v2.core.Base.DataSource getSignedCertificateTimestamp(int index);
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
     */
    int getSignedCertificateTimestampCount();
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
     */
    java.util.List<? extends envoy.api.v2.core.Base.DataSourceOrBuilder> 
        getSignedCertificateTimestampOrBuilderList();
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
     */
    envoy.api.v2.core.Base.DataSourceOrBuilder getSignedCertificateTimestampOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code envoy.api.v2.auth.TlsCertificate}
   */
  public  static final class TlsCertificate extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.auth.TlsCertificate)
      TlsCertificateOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TlsCertificate.newBuilder() to construct.
    private TlsCertificate(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TlsCertificate() {
      signedCertificateTimestamp_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TlsCertificate(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              envoy.api.v2.core.Base.DataSource.Builder subBuilder = null;
              if (certificateChain_ != null) {
                subBuilder = certificateChain_.toBuilder();
              }
              certificateChain_ = input.readMessage(envoy.api.v2.core.Base.DataSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(certificateChain_);
                certificateChain_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              envoy.api.v2.core.Base.DataSource.Builder subBuilder = null;
              if (privateKey_ != null) {
                subBuilder = privateKey_.toBuilder();
              }
              privateKey_ = input.readMessage(envoy.api.v2.core.Base.DataSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(privateKey_);
                privateKey_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              envoy.api.v2.core.Base.DataSource.Builder subBuilder = null;
              if (password_ != null) {
                subBuilder = password_.toBuilder();
              }
              password_ = input.readMessage(envoy.api.v2.core.Base.DataSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(password_);
                password_ = subBuilder.buildPartial();
              }

              break;
            }
            case 34: {
              envoy.api.v2.core.Base.DataSource.Builder subBuilder = null;
              if (ocspStaple_ != null) {
                subBuilder = ocspStaple_.toBuilder();
              }
              ocspStaple_ = input.readMessage(envoy.api.v2.core.Base.DataSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(ocspStaple_);
                ocspStaple_ = subBuilder.buildPartial();
              }

              break;
            }
            case 42: {
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                signedCertificateTimestamp_ = new java.util.ArrayList<envoy.api.v2.core.Base.DataSource>();
                mutable_bitField0_ |= 0x00000010;
              }
              signedCertificateTimestamp_.add(
                  input.readMessage(envoy.api.v2.core.Base.DataSource.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
          signedCertificateTimestamp_ = java.util.Collections.unmodifiableList(signedCertificateTimestamp_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsCertificate_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsCertificate_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              envoy.api.v2.auth.Cert.TlsCertificate.class, envoy.api.v2.auth.Cert.TlsCertificate.Builder.class);
    }

    private int bitField0_;
    public static final int CERTIFICATE_CHAIN_FIELD_NUMBER = 1;
    private envoy.api.v2.core.Base.DataSource certificateChain_;
    /**
     * <pre>
     * The TLS certificate chain.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
     */
    public boolean hasCertificateChain() {
      return certificateChain_ != null;
    }
    /**
     * <pre>
     * The TLS certificate chain.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
     */
    public envoy.api.v2.core.Base.DataSource getCertificateChain() {
      return certificateChain_ == null ? envoy.api.v2.core.Base.DataSource.getDefaultInstance() : certificateChain_;
    }
    /**
     * <pre>
     * The TLS certificate chain.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
     */
    public envoy.api.v2.core.Base.DataSourceOrBuilder getCertificateChainOrBuilder() {
      return getCertificateChain();
    }

    public static final int PRIVATE_KEY_FIELD_NUMBER = 2;
    private envoy.api.v2.core.Base.DataSource privateKey_;
    /**
     * <pre>
     * The TLS private key.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
     */
    public boolean hasPrivateKey() {
      return privateKey_ != null;
    }
    /**
     * <pre>
     * The TLS private key.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
     */
    public envoy.api.v2.core.Base.DataSource getPrivateKey() {
      return privateKey_ == null ? envoy.api.v2.core.Base.DataSource.getDefaultInstance() : privateKey_;
    }
    /**
     * <pre>
     * The TLS private key.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
     */
    public envoy.api.v2.core.Base.DataSourceOrBuilder getPrivateKeyOrBuilder() {
      return getPrivateKey();
    }

    public static final int PASSWORD_FIELD_NUMBER = 3;
    private envoy.api.v2.core.Base.DataSource password_;
    /**
     * <pre>
     * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
     * TLS private key is not password encrypted.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource password = 3;</code>
     */
    public boolean hasPassword() {
      return password_ != null;
    }
    /**
     * <pre>
     * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
     * TLS private key is not password encrypted.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource password = 3;</code>
     */
    public envoy.api.v2.core.Base.DataSource getPassword() {
      return password_ == null ? envoy.api.v2.core.Base.DataSource.getDefaultInstance() : password_;
    }
    /**
     * <pre>
     * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
     * TLS private key is not password encrypted.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource password = 3;</code>
     */
    public envoy.api.v2.core.Base.DataSourceOrBuilder getPasswordOrBuilder() {
      return getPassword();
    }

    public static final int OCSP_STAPLE_FIELD_NUMBER = 4;
    private envoy.api.v2.core.Base.DataSource ocspStaple_;
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
     */
    public boolean hasOcspStaple() {
      return ocspStaple_ != null;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
     */
    public envoy.api.v2.core.Base.DataSource getOcspStaple() {
      return ocspStaple_ == null ? envoy.api.v2.core.Base.DataSource.getDefaultInstance() : ocspStaple_;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
     */
    public envoy.api.v2.core.Base.DataSourceOrBuilder getOcspStapleOrBuilder() {
      return getOcspStaple();
    }

    public static final int SIGNED_CERTIFICATE_TIMESTAMP_FIELD_NUMBER = 5;
    private java.util.List<envoy.api.v2.core.Base.DataSource> signedCertificateTimestamp_;
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
     */
    public java.util.List<envoy.api.v2.core.Base.DataSource> getSignedCertificateTimestampList() {
      return signedCertificateTimestamp_;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
     */
    public java.util.List<? extends envoy.api.v2.core.Base.DataSourceOrBuilder> 
        getSignedCertificateTimestampOrBuilderList() {
      return signedCertificateTimestamp_;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
     */
    public int getSignedCertificateTimestampCount() {
      return signedCertificateTimestamp_.size();
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
     */
    public envoy.api.v2.core.Base.DataSource getSignedCertificateTimestamp(int index) {
      return signedCertificateTimestamp_.get(index);
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
     */
    public envoy.api.v2.core.Base.DataSourceOrBuilder getSignedCertificateTimestampOrBuilder(
        int index) {
      return signedCertificateTimestamp_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (certificateChain_ != null) {
        output.writeMessage(1, getCertificateChain());
      }
      if (privateKey_ != null) {
        output.writeMessage(2, getPrivateKey());
      }
      if (password_ != null) {
        output.writeMessage(3, getPassword());
      }
      if (ocspStaple_ != null) {
        output.writeMessage(4, getOcspStaple());
      }
      for (int i = 0; i < signedCertificateTimestamp_.size(); i++) {
        output.writeMessage(5, signedCertificateTimestamp_.get(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (certificateChain_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getCertificateChain());
      }
      if (privateKey_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getPrivateKey());
      }
      if (password_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getPassword());
      }
      if (ocspStaple_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getOcspStaple());
      }
      for (int i = 0; i < signedCertificateTimestamp_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, signedCertificateTimestamp_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof envoy.api.v2.auth.Cert.TlsCertificate)) {
        return super.equals(obj);
      }
      envoy.api.v2.auth.Cert.TlsCertificate other = (envoy.api.v2.auth.Cert.TlsCertificate) obj;

      boolean result = true;
      result = result && (hasCertificateChain() == other.hasCertificateChain());
      if (hasCertificateChain()) {
        result = result && getCertificateChain()
            .equals(other.getCertificateChain());
      }
      result = result && (hasPrivateKey() == other.hasPrivateKey());
      if (hasPrivateKey()) {
        result = result && getPrivateKey()
            .equals(other.getPrivateKey());
      }
      result = result && (hasPassword() == other.hasPassword());
      if (hasPassword()) {
        result = result && getPassword()
            .equals(other.getPassword());
      }
      result = result && (hasOcspStaple() == other.hasOcspStaple());
      if (hasOcspStaple()) {
        result = result && getOcspStaple()
            .equals(other.getOcspStaple());
      }
      result = result && getSignedCertificateTimestampList()
          .equals(other.getSignedCertificateTimestampList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCertificateChain()) {
        hash = (37 * hash) + CERTIFICATE_CHAIN_FIELD_NUMBER;
        hash = (53 * hash) + getCertificateChain().hashCode();
      }
      if (hasPrivateKey()) {
        hash = (37 * hash) + PRIVATE_KEY_FIELD_NUMBER;
        hash = (53 * hash) + getPrivateKey().hashCode();
      }
      if (hasPassword()) {
        hash = (37 * hash) + PASSWORD_FIELD_NUMBER;
        hash = (53 * hash) + getPassword().hashCode();
      }
      if (hasOcspStaple()) {
        hash = (37 * hash) + OCSP_STAPLE_FIELD_NUMBER;
        hash = (53 * hash) + getOcspStaple().hashCode();
      }
      if (getSignedCertificateTimestampCount() > 0) {
        hash = (37 * hash) + SIGNED_CERTIFICATE_TIMESTAMP_FIELD_NUMBER;
        hash = (53 * hash) + getSignedCertificateTimestampList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static envoy.api.v2.auth.Cert.TlsCertificate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.TlsCertificate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsCertificate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.TlsCertificate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsCertificate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.TlsCertificate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsCertificate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.TlsCertificate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsCertificate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.TlsCertificate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsCertificate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.TlsCertificate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(envoy.api.v2.auth.Cert.TlsCertificate prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code envoy.api.v2.auth.TlsCertificate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.auth.TlsCertificate)
        envoy.api.v2.auth.Cert.TlsCertificateOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsCertificate_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsCertificate_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                envoy.api.v2.auth.Cert.TlsCertificate.class, envoy.api.v2.auth.Cert.TlsCertificate.Builder.class);
      }

      // Construct using envoy.api.v2.auth.Cert.TlsCertificate.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSignedCertificateTimestampFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (certificateChainBuilder_ == null) {
          certificateChain_ = null;
        } else {
          certificateChain_ = null;
          certificateChainBuilder_ = null;
        }
        if (privateKeyBuilder_ == null) {
          privateKey_ = null;
        } else {
          privateKey_ = null;
          privateKeyBuilder_ = null;
        }
        if (passwordBuilder_ == null) {
          password_ = null;
        } else {
          password_ = null;
          passwordBuilder_ = null;
        }
        if (ocspStapleBuilder_ == null) {
          ocspStaple_ = null;
        } else {
          ocspStaple_ = null;
          ocspStapleBuilder_ = null;
        }
        if (signedCertificateTimestampBuilder_ == null) {
          signedCertificateTimestamp_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
        } else {
          signedCertificateTimestampBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsCertificate_descriptor;
      }

      public envoy.api.v2.auth.Cert.TlsCertificate getDefaultInstanceForType() {
        return envoy.api.v2.auth.Cert.TlsCertificate.getDefaultInstance();
      }

      public envoy.api.v2.auth.Cert.TlsCertificate build() {
        envoy.api.v2.auth.Cert.TlsCertificate result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public envoy.api.v2.auth.Cert.TlsCertificate buildPartial() {
        envoy.api.v2.auth.Cert.TlsCertificate result = new envoy.api.v2.auth.Cert.TlsCertificate(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (certificateChainBuilder_ == null) {
          result.certificateChain_ = certificateChain_;
        } else {
          result.certificateChain_ = certificateChainBuilder_.build();
        }
        if (privateKeyBuilder_ == null) {
          result.privateKey_ = privateKey_;
        } else {
          result.privateKey_ = privateKeyBuilder_.build();
        }
        if (passwordBuilder_ == null) {
          result.password_ = password_;
        } else {
          result.password_ = passwordBuilder_.build();
        }
        if (ocspStapleBuilder_ == null) {
          result.ocspStaple_ = ocspStaple_;
        } else {
          result.ocspStaple_ = ocspStapleBuilder_.build();
        }
        if (signedCertificateTimestampBuilder_ == null) {
          if (((bitField0_ & 0x00000010) == 0x00000010)) {
            signedCertificateTimestamp_ = java.util.Collections.unmodifiableList(signedCertificateTimestamp_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.signedCertificateTimestamp_ = signedCertificateTimestamp_;
        } else {
          result.signedCertificateTimestamp_ = signedCertificateTimestampBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof envoy.api.v2.auth.Cert.TlsCertificate) {
          return mergeFrom((envoy.api.v2.auth.Cert.TlsCertificate)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(envoy.api.v2.auth.Cert.TlsCertificate other) {
        if (other == envoy.api.v2.auth.Cert.TlsCertificate.getDefaultInstance()) return this;
        if (other.hasCertificateChain()) {
          mergeCertificateChain(other.getCertificateChain());
        }
        if (other.hasPrivateKey()) {
          mergePrivateKey(other.getPrivateKey());
        }
        if (other.hasPassword()) {
          mergePassword(other.getPassword());
        }
        if (other.hasOcspStaple()) {
          mergeOcspStaple(other.getOcspStaple());
        }
        if (signedCertificateTimestampBuilder_ == null) {
          if (!other.signedCertificateTimestamp_.isEmpty()) {
            if (signedCertificateTimestamp_.isEmpty()) {
              signedCertificateTimestamp_ = other.signedCertificateTimestamp_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureSignedCertificateTimestampIsMutable();
              signedCertificateTimestamp_.addAll(other.signedCertificateTimestamp_);
            }
            onChanged();
          }
        } else {
          if (!other.signedCertificateTimestamp_.isEmpty()) {
            if (signedCertificateTimestampBuilder_.isEmpty()) {
              signedCertificateTimestampBuilder_.dispose();
              signedCertificateTimestampBuilder_ = null;
              signedCertificateTimestamp_ = other.signedCertificateTimestamp_;
              bitField0_ = (bitField0_ & ~0x00000010);
              signedCertificateTimestampBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSignedCertificateTimestampFieldBuilder() : null;
            } else {
              signedCertificateTimestampBuilder_.addAllMessages(other.signedCertificateTimestamp_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        envoy.api.v2.auth.Cert.TlsCertificate parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (envoy.api.v2.auth.Cert.TlsCertificate) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private envoy.api.v2.core.Base.DataSource certificateChain_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> certificateChainBuilder_;
      /**
       * <pre>
       * The TLS certificate chain.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
       */
      public boolean hasCertificateChain() {
        return certificateChainBuilder_ != null || certificateChain_ != null;
      }
      /**
       * <pre>
       * The TLS certificate chain.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
       */
      public envoy.api.v2.core.Base.DataSource getCertificateChain() {
        if (certificateChainBuilder_ == null) {
          return certificateChain_ == null ? envoy.api.v2.core.Base.DataSource.getDefaultInstance() : certificateChain_;
        } else {
          return certificateChainBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The TLS certificate chain.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
       */
      public Builder setCertificateChain(envoy.api.v2.core.Base.DataSource value) {
        if (certificateChainBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          certificateChain_ = value;
          onChanged();
        } else {
          certificateChainBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The TLS certificate chain.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
       */
      public Builder setCertificateChain(
          envoy.api.v2.core.Base.DataSource.Builder builderForValue) {
        if (certificateChainBuilder_ == null) {
          certificateChain_ = builderForValue.build();
          onChanged();
        } else {
          certificateChainBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The TLS certificate chain.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
       */
      public Builder mergeCertificateChain(envoy.api.v2.core.Base.DataSource value) {
        if (certificateChainBuilder_ == null) {
          if (certificateChain_ != null) {
            certificateChain_ =
              envoy.api.v2.core.Base.DataSource.newBuilder(certificateChain_).mergeFrom(value).buildPartial();
          } else {
            certificateChain_ = value;
          }
          onChanged();
        } else {
          certificateChainBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The TLS certificate chain.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
       */
      public Builder clearCertificateChain() {
        if (certificateChainBuilder_ == null) {
          certificateChain_ = null;
          onChanged();
        } else {
          certificateChain_ = null;
          certificateChainBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The TLS certificate chain.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
       */
      public envoy.api.v2.core.Base.DataSource.Builder getCertificateChainBuilder() {
        
        onChanged();
        return getCertificateChainFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The TLS certificate chain.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
       */
      public envoy.api.v2.core.Base.DataSourceOrBuilder getCertificateChainOrBuilder() {
        if (certificateChainBuilder_ != null) {
          return certificateChainBuilder_.getMessageOrBuilder();
        } else {
          return certificateChain_ == null ?
              envoy.api.v2.core.Base.DataSource.getDefaultInstance() : certificateChain_;
        }
      }
      /**
       * <pre>
       * The TLS certificate chain.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource certificate_chain = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> 
          getCertificateChainFieldBuilder() {
        if (certificateChainBuilder_ == null) {
          certificateChainBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder>(
                  getCertificateChain(),
                  getParentForChildren(),
                  isClean());
          certificateChain_ = null;
        }
        return certificateChainBuilder_;
      }

      private envoy.api.v2.core.Base.DataSource privateKey_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> privateKeyBuilder_;
      /**
       * <pre>
       * The TLS private key.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
       */
      public boolean hasPrivateKey() {
        return privateKeyBuilder_ != null || privateKey_ != null;
      }
      /**
       * <pre>
       * The TLS private key.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
       */
      public envoy.api.v2.core.Base.DataSource getPrivateKey() {
        if (privateKeyBuilder_ == null) {
          return privateKey_ == null ? envoy.api.v2.core.Base.DataSource.getDefaultInstance() : privateKey_;
        } else {
          return privateKeyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The TLS private key.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
       */
      public Builder setPrivateKey(envoy.api.v2.core.Base.DataSource value) {
        if (privateKeyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          privateKey_ = value;
          onChanged();
        } else {
          privateKeyBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The TLS private key.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
       */
      public Builder setPrivateKey(
          envoy.api.v2.core.Base.DataSource.Builder builderForValue) {
        if (privateKeyBuilder_ == null) {
          privateKey_ = builderForValue.build();
          onChanged();
        } else {
          privateKeyBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The TLS private key.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
       */
      public Builder mergePrivateKey(envoy.api.v2.core.Base.DataSource value) {
        if (privateKeyBuilder_ == null) {
          if (privateKey_ != null) {
            privateKey_ =
              envoy.api.v2.core.Base.DataSource.newBuilder(privateKey_).mergeFrom(value).buildPartial();
          } else {
            privateKey_ = value;
          }
          onChanged();
        } else {
          privateKeyBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The TLS private key.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
       */
      public Builder clearPrivateKey() {
        if (privateKeyBuilder_ == null) {
          privateKey_ = null;
          onChanged();
        } else {
          privateKey_ = null;
          privateKeyBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The TLS private key.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
       */
      public envoy.api.v2.core.Base.DataSource.Builder getPrivateKeyBuilder() {
        
        onChanged();
        return getPrivateKeyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The TLS private key.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
       */
      public envoy.api.v2.core.Base.DataSourceOrBuilder getPrivateKeyOrBuilder() {
        if (privateKeyBuilder_ != null) {
          return privateKeyBuilder_.getMessageOrBuilder();
        } else {
          return privateKey_ == null ?
              envoy.api.v2.core.Base.DataSource.getDefaultInstance() : privateKey_;
        }
      }
      /**
       * <pre>
       * The TLS private key.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource private_key = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> 
          getPrivateKeyFieldBuilder() {
        if (privateKeyBuilder_ == null) {
          privateKeyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder>(
                  getPrivateKey(),
                  getParentForChildren(),
                  isClean());
          privateKey_ = null;
        }
        return privateKeyBuilder_;
      }

      private envoy.api.v2.core.Base.DataSource password_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> passwordBuilder_;
      /**
       * <pre>
       * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
       * TLS private key is not password encrypted.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource password = 3;</code>
       */
      public boolean hasPassword() {
        return passwordBuilder_ != null || password_ != null;
      }
      /**
       * <pre>
       * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
       * TLS private key is not password encrypted.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource password = 3;</code>
       */
      public envoy.api.v2.core.Base.DataSource getPassword() {
        if (passwordBuilder_ == null) {
          return password_ == null ? envoy.api.v2.core.Base.DataSource.getDefaultInstance() : password_;
        } else {
          return passwordBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
       * TLS private key is not password encrypted.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource password = 3;</code>
       */
      public Builder setPassword(envoy.api.v2.core.Base.DataSource value) {
        if (passwordBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          password_ = value;
          onChanged();
        } else {
          passwordBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
       * TLS private key is not password encrypted.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource password = 3;</code>
       */
      public Builder setPassword(
          envoy.api.v2.core.Base.DataSource.Builder builderForValue) {
        if (passwordBuilder_ == null) {
          password_ = builderForValue.build();
          onChanged();
        } else {
          passwordBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
       * TLS private key is not password encrypted.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource password = 3;</code>
       */
      public Builder mergePassword(envoy.api.v2.core.Base.DataSource value) {
        if (passwordBuilder_ == null) {
          if (password_ != null) {
            password_ =
              envoy.api.v2.core.Base.DataSource.newBuilder(password_).mergeFrom(value).buildPartial();
          } else {
            password_ = value;
          }
          onChanged();
        } else {
          passwordBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
       * TLS private key is not password encrypted.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource password = 3;</code>
       */
      public Builder clearPassword() {
        if (passwordBuilder_ == null) {
          password_ = null;
          onChanged();
        } else {
          password_ = null;
          passwordBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
       * TLS private key is not password encrypted.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource password = 3;</code>
       */
      public envoy.api.v2.core.Base.DataSource.Builder getPasswordBuilder() {
        
        onChanged();
        return getPasswordFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
       * TLS private key is not password encrypted.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource password = 3;</code>
       */
      public envoy.api.v2.core.Base.DataSourceOrBuilder getPasswordOrBuilder() {
        if (passwordBuilder_ != null) {
          return passwordBuilder_.getMessageOrBuilder();
        } else {
          return password_ == null ?
              envoy.api.v2.core.Base.DataSource.getDefaultInstance() : password_;
        }
      }
      /**
       * <pre>
       * The password to decrypt the TLS private key. If this field is not set, it is assumed that the
       * TLS private key is not password encrypted.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource password = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> 
          getPasswordFieldBuilder() {
        if (passwordBuilder_ == null) {
          passwordBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder>(
                  getPassword(),
                  getParentForChildren(),
                  isClean());
          password_ = null;
        }
        return passwordBuilder_;
      }

      private envoy.api.v2.core.Base.DataSource ocspStaple_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> ocspStapleBuilder_;
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
       */
      public boolean hasOcspStaple() {
        return ocspStapleBuilder_ != null || ocspStaple_ != null;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
       */
      public envoy.api.v2.core.Base.DataSource getOcspStaple() {
        if (ocspStapleBuilder_ == null) {
          return ocspStaple_ == null ? envoy.api.v2.core.Base.DataSource.getDefaultInstance() : ocspStaple_;
        } else {
          return ocspStapleBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
       */
      public Builder setOcspStaple(envoy.api.v2.core.Base.DataSource value) {
        if (ocspStapleBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ocspStaple_ = value;
          onChanged();
        } else {
          ocspStapleBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
       */
      public Builder setOcspStaple(
          envoy.api.v2.core.Base.DataSource.Builder builderForValue) {
        if (ocspStapleBuilder_ == null) {
          ocspStaple_ = builderForValue.build();
          onChanged();
        } else {
          ocspStapleBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
       */
      public Builder mergeOcspStaple(envoy.api.v2.core.Base.DataSource value) {
        if (ocspStapleBuilder_ == null) {
          if (ocspStaple_ != null) {
            ocspStaple_ =
              envoy.api.v2.core.Base.DataSource.newBuilder(ocspStaple_).mergeFrom(value).buildPartial();
          } else {
            ocspStaple_ = value;
          }
          onChanged();
        } else {
          ocspStapleBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
       */
      public Builder clearOcspStaple() {
        if (ocspStapleBuilder_ == null) {
          ocspStaple_ = null;
          onChanged();
        } else {
          ocspStaple_ = null;
          ocspStapleBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
       */
      public envoy.api.v2.core.Base.DataSource.Builder getOcspStapleBuilder() {
        
        onChanged();
        return getOcspStapleFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
       */
      public envoy.api.v2.core.Base.DataSourceOrBuilder getOcspStapleOrBuilder() {
        if (ocspStapleBuilder_ != null) {
          return ocspStapleBuilder_.getMessageOrBuilder();
        } else {
          return ocspStaple_ == null ?
              envoy.api.v2.core.Base.DataSource.getDefaultInstance() : ocspStaple_;
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource ocsp_staple = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> 
          getOcspStapleFieldBuilder() {
        if (ocspStapleBuilder_ == null) {
          ocspStapleBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder>(
                  getOcspStaple(),
                  getParentForChildren(),
                  isClean());
          ocspStaple_ = null;
        }
        return ocspStapleBuilder_;
      }

      private java.util.List<envoy.api.v2.core.Base.DataSource> signedCertificateTimestamp_ =
        java.util.Collections.emptyList();
      private void ensureSignedCertificateTimestampIsMutable() {
        if (!((bitField0_ & 0x00000010) == 0x00000010)) {
          signedCertificateTimestamp_ = new java.util.ArrayList<envoy.api.v2.core.Base.DataSource>(signedCertificateTimestamp_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> signedCertificateTimestampBuilder_;

      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public java.util.List<envoy.api.v2.core.Base.DataSource> getSignedCertificateTimestampList() {
        if (signedCertificateTimestampBuilder_ == null) {
          return java.util.Collections.unmodifiableList(signedCertificateTimestamp_);
        } else {
          return signedCertificateTimestampBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public int getSignedCertificateTimestampCount() {
        if (signedCertificateTimestampBuilder_ == null) {
          return signedCertificateTimestamp_.size();
        } else {
          return signedCertificateTimestampBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public envoy.api.v2.core.Base.DataSource getSignedCertificateTimestamp(int index) {
        if (signedCertificateTimestampBuilder_ == null) {
          return signedCertificateTimestamp_.get(index);
        } else {
          return signedCertificateTimestampBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public Builder setSignedCertificateTimestamp(
          int index, envoy.api.v2.core.Base.DataSource value) {
        if (signedCertificateTimestampBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignedCertificateTimestampIsMutable();
          signedCertificateTimestamp_.set(index, value);
          onChanged();
        } else {
          signedCertificateTimestampBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public Builder setSignedCertificateTimestamp(
          int index, envoy.api.v2.core.Base.DataSource.Builder builderForValue) {
        if (signedCertificateTimestampBuilder_ == null) {
          ensureSignedCertificateTimestampIsMutable();
          signedCertificateTimestamp_.set(index, builderForValue.build());
          onChanged();
        } else {
          signedCertificateTimestampBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public Builder addSignedCertificateTimestamp(envoy.api.v2.core.Base.DataSource value) {
        if (signedCertificateTimestampBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignedCertificateTimestampIsMutable();
          signedCertificateTimestamp_.add(value);
          onChanged();
        } else {
          signedCertificateTimestampBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public Builder addSignedCertificateTimestamp(
          int index, envoy.api.v2.core.Base.DataSource value) {
        if (signedCertificateTimestampBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignedCertificateTimestampIsMutable();
          signedCertificateTimestamp_.add(index, value);
          onChanged();
        } else {
          signedCertificateTimestampBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public Builder addSignedCertificateTimestamp(
          envoy.api.v2.core.Base.DataSource.Builder builderForValue) {
        if (signedCertificateTimestampBuilder_ == null) {
          ensureSignedCertificateTimestampIsMutable();
          signedCertificateTimestamp_.add(builderForValue.build());
          onChanged();
        } else {
          signedCertificateTimestampBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public Builder addSignedCertificateTimestamp(
          int index, envoy.api.v2.core.Base.DataSource.Builder builderForValue) {
        if (signedCertificateTimestampBuilder_ == null) {
          ensureSignedCertificateTimestampIsMutable();
          signedCertificateTimestamp_.add(index, builderForValue.build());
          onChanged();
        } else {
          signedCertificateTimestampBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public Builder addAllSignedCertificateTimestamp(
          java.lang.Iterable<? extends envoy.api.v2.core.Base.DataSource> values) {
        if (signedCertificateTimestampBuilder_ == null) {
          ensureSignedCertificateTimestampIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, signedCertificateTimestamp_);
          onChanged();
        } else {
          signedCertificateTimestampBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public Builder clearSignedCertificateTimestamp() {
        if (signedCertificateTimestampBuilder_ == null) {
          signedCertificateTimestamp_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          signedCertificateTimestampBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public Builder removeSignedCertificateTimestamp(int index) {
        if (signedCertificateTimestampBuilder_ == null) {
          ensureSignedCertificateTimestampIsMutable();
          signedCertificateTimestamp_.remove(index);
          onChanged();
        } else {
          signedCertificateTimestampBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public envoy.api.v2.core.Base.DataSource.Builder getSignedCertificateTimestampBuilder(
          int index) {
        return getSignedCertificateTimestampFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public envoy.api.v2.core.Base.DataSourceOrBuilder getSignedCertificateTimestampOrBuilder(
          int index) {
        if (signedCertificateTimestampBuilder_ == null) {
          return signedCertificateTimestamp_.get(index);  } else {
          return signedCertificateTimestampBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public java.util.List<? extends envoy.api.v2.core.Base.DataSourceOrBuilder> 
           getSignedCertificateTimestampOrBuilderList() {
        if (signedCertificateTimestampBuilder_ != null) {
          return signedCertificateTimestampBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(signedCertificateTimestamp_);
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public envoy.api.v2.core.Base.DataSource.Builder addSignedCertificateTimestampBuilder() {
        return getSignedCertificateTimestampFieldBuilder().addBuilder(
            envoy.api.v2.core.Base.DataSource.getDefaultInstance());
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public envoy.api.v2.core.Base.DataSource.Builder addSignedCertificateTimestampBuilder(
          int index) {
        return getSignedCertificateTimestampFieldBuilder().addBuilder(
            index, envoy.api.v2.core.Base.DataSource.getDefaultInstance());
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource signed_certificate_timestamp = 5;</code>
       */
      public java.util.List<envoy.api.v2.core.Base.DataSource.Builder> 
           getSignedCertificateTimestampBuilderList() {
        return getSignedCertificateTimestampFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> 
          getSignedCertificateTimestampFieldBuilder() {
        if (signedCertificateTimestampBuilder_ == null) {
          signedCertificateTimestampBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder>(
                  signedCertificateTimestamp_,
                  ((bitField0_ & 0x00000010) == 0x00000010),
                  getParentForChildren(),
                  isClean());
          signedCertificateTimestamp_ = null;
        }
        return signedCertificateTimestampBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.auth.TlsCertificate)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.auth.TlsCertificate)
    private static final envoy.api.v2.auth.Cert.TlsCertificate DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new envoy.api.v2.auth.Cert.TlsCertificate();
    }

    public static envoy.api.v2.auth.Cert.TlsCertificate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TlsCertificate>
        PARSER = new com.google.protobuf.AbstractParser<TlsCertificate>() {
      public TlsCertificate parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TlsCertificate(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<TlsCertificate> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TlsCertificate> getParserForType() {
      return PARSER;
    }

    public envoy.api.v2.auth.Cert.TlsCertificate getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TlsSessionTicketKeysOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.auth.TlsSessionTicketKeys)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Keys for encrypting and decrypting TLS session tickets. The
     * first key in the array contains the key to encrypt all new sessions created by this context.
     * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
     * by, for example, putting the new key first, and the previous key second.
     * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
     * is not specified, the TLS library will still support resuming sessions via tickets, but it will
     * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
     * or on different hosts.
     * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
     * example, the output of ``openssl rand 80``.
     * .. attention::
     *   Using this feature has serious security considerations and risks. Improper handling of keys
     *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
     *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
     *   discussion. To minimize the risk, you must:
     *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
     *   * Rotate session ticket keys at least daily, and preferably hourly
     *   * Always generate keys using a cryptographically-secure random data source
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
     */
    java.util.List<envoy.api.v2.core.Base.DataSource> 
        getKeysList();
    /**
     * <pre>
     * Keys for encrypting and decrypting TLS session tickets. The
     * first key in the array contains the key to encrypt all new sessions created by this context.
     * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
     * by, for example, putting the new key first, and the previous key second.
     * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
     * is not specified, the TLS library will still support resuming sessions via tickets, but it will
     * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
     * or on different hosts.
     * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
     * example, the output of ``openssl rand 80``.
     * .. attention::
     *   Using this feature has serious security considerations and risks. Improper handling of keys
     *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
     *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
     *   discussion. To minimize the risk, you must:
     *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
     *   * Rotate session ticket keys at least daily, and preferably hourly
     *   * Always generate keys using a cryptographically-secure random data source
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
     */
    envoy.api.v2.core.Base.DataSource getKeys(int index);
    /**
     * <pre>
     * Keys for encrypting and decrypting TLS session tickets. The
     * first key in the array contains the key to encrypt all new sessions created by this context.
     * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
     * by, for example, putting the new key first, and the previous key second.
     * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
     * is not specified, the TLS library will still support resuming sessions via tickets, but it will
     * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
     * or on different hosts.
     * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
     * example, the output of ``openssl rand 80``.
     * .. attention::
     *   Using this feature has serious security considerations and risks. Improper handling of keys
     *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
     *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
     *   discussion. To minimize the risk, you must:
     *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
     *   * Rotate session ticket keys at least daily, and preferably hourly
     *   * Always generate keys using a cryptographically-secure random data source
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
     */
    int getKeysCount();
    /**
     * <pre>
     * Keys for encrypting and decrypting TLS session tickets. The
     * first key in the array contains the key to encrypt all new sessions created by this context.
     * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
     * by, for example, putting the new key first, and the previous key second.
     * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
     * is not specified, the TLS library will still support resuming sessions via tickets, but it will
     * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
     * or on different hosts.
     * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
     * example, the output of ``openssl rand 80``.
     * .. attention::
     *   Using this feature has serious security considerations and risks. Improper handling of keys
     *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
     *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
     *   discussion. To minimize the risk, you must:
     *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
     *   * Rotate session ticket keys at least daily, and preferably hourly
     *   * Always generate keys using a cryptographically-secure random data source
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
     */
    java.util.List<? extends envoy.api.v2.core.Base.DataSourceOrBuilder> 
        getKeysOrBuilderList();
    /**
     * <pre>
     * Keys for encrypting and decrypting TLS session tickets. The
     * first key in the array contains the key to encrypt all new sessions created by this context.
     * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
     * by, for example, putting the new key first, and the previous key second.
     * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
     * is not specified, the TLS library will still support resuming sessions via tickets, but it will
     * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
     * or on different hosts.
     * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
     * example, the output of ``openssl rand 80``.
     * .. attention::
     *   Using this feature has serious security considerations and risks. Improper handling of keys
     *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
     *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
     *   discussion. To minimize the risk, you must:
     *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
     *   * Rotate session ticket keys at least daily, and preferably hourly
     *   * Always generate keys using a cryptographically-secure random data source
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
     */
    envoy.api.v2.core.Base.DataSourceOrBuilder getKeysOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code envoy.api.v2.auth.TlsSessionTicketKeys}
   */
  public  static final class TlsSessionTicketKeys extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.auth.TlsSessionTicketKeys)
      TlsSessionTicketKeysOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TlsSessionTicketKeys.newBuilder() to construct.
    private TlsSessionTicketKeys(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TlsSessionTicketKeys() {
      keys_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TlsSessionTicketKeys(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                keys_ = new java.util.ArrayList<envoy.api.v2.core.Base.DataSource>();
                mutable_bitField0_ |= 0x00000001;
              }
              keys_.add(
                  input.readMessage(envoy.api.v2.core.Base.DataSource.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          keys_ = java.util.Collections.unmodifiableList(keys_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsSessionTicketKeys_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsSessionTicketKeys_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              envoy.api.v2.auth.Cert.TlsSessionTicketKeys.class, envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder.class);
    }

    public static final int KEYS_FIELD_NUMBER = 1;
    private java.util.List<envoy.api.v2.core.Base.DataSource> keys_;
    /**
     * <pre>
     * Keys for encrypting and decrypting TLS session tickets. The
     * first key in the array contains the key to encrypt all new sessions created by this context.
     * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
     * by, for example, putting the new key first, and the previous key second.
     * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
     * is not specified, the TLS library will still support resuming sessions via tickets, but it will
     * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
     * or on different hosts.
     * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
     * example, the output of ``openssl rand 80``.
     * .. attention::
     *   Using this feature has serious security considerations and risks. Improper handling of keys
     *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
     *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
     *   discussion. To minimize the risk, you must:
     *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
     *   * Rotate session ticket keys at least daily, and preferably hourly
     *   * Always generate keys using a cryptographically-secure random data source
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
     */
    public java.util.List<envoy.api.v2.core.Base.DataSource> getKeysList() {
      return keys_;
    }
    /**
     * <pre>
     * Keys for encrypting and decrypting TLS session tickets. The
     * first key in the array contains the key to encrypt all new sessions created by this context.
     * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
     * by, for example, putting the new key first, and the previous key second.
     * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
     * is not specified, the TLS library will still support resuming sessions via tickets, but it will
     * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
     * or on different hosts.
     * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
     * example, the output of ``openssl rand 80``.
     * .. attention::
     *   Using this feature has serious security considerations and risks. Improper handling of keys
     *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
     *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
     *   discussion. To minimize the risk, you must:
     *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
     *   * Rotate session ticket keys at least daily, and preferably hourly
     *   * Always generate keys using a cryptographically-secure random data source
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
     */
    public java.util.List<? extends envoy.api.v2.core.Base.DataSourceOrBuilder> 
        getKeysOrBuilderList() {
      return keys_;
    }
    /**
     * <pre>
     * Keys for encrypting and decrypting TLS session tickets. The
     * first key in the array contains the key to encrypt all new sessions created by this context.
     * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
     * by, for example, putting the new key first, and the previous key second.
     * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
     * is not specified, the TLS library will still support resuming sessions via tickets, but it will
     * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
     * or on different hosts.
     * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
     * example, the output of ``openssl rand 80``.
     * .. attention::
     *   Using this feature has serious security considerations and risks. Improper handling of keys
     *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
     *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
     *   discussion. To minimize the risk, you must:
     *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
     *   * Rotate session ticket keys at least daily, and preferably hourly
     *   * Always generate keys using a cryptographically-secure random data source
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
     */
    public int getKeysCount() {
      return keys_.size();
    }
    /**
     * <pre>
     * Keys for encrypting and decrypting TLS session tickets. The
     * first key in the array contains the key to encrypt all new sessions created by this context.
     * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
     * by, for example, putting the new key first, and the previous key second.
     * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
     * is not specified, the TLS library will still support resuming sessions via tickets, but it will
     * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
     * or on different hosts.
     * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
     * example, the output of ``openssl rand 80``.
     * .. attention::
     *   Using this feature has serious security considerations and risks. Improper handling of keys
     *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
     *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
     *   discussion. To minimize the risk, you must:
     *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
     *   * Rotate session ticket keys at least daily, and preferably hourly
     *   * Always generate keys using a cryptographically-secure random data source
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
     */
    public envoy.api.v2.core.Base.DataSource getKeys(int index) {
      return keys_.get(index);
    }
    /**
     * <pre>
     * Keys for encrypting and decrypting TLS session tickets. The
     * first key in the array contains the key to encrypt all new sessions created by this context.
     * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
     * by, for example, putting the new key first, and the previous key second.
     * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
     * is not specified, the TLS library will still support resuming sessions via tickets, but it will
     * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
     * or on different hosts.
     * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
     * example, the output of ``openssl rand 80``.
     * .. attention::
     *   Using this feature has serious security considerations and risks. Improper handling of keys
     *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
     *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
     *   discussion. To minimize the risk, you must:
     *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
     *   * Rotate session ticket keys at least daily, and preferably hourly
     *   * Always generate keys using a cryptographically-secure random data source
     * </pre>
     *
     * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
     */
    public envoy.api.v2.core.Base.DataSourceOrBuilder getKeysOrBuilder(
        int index) {
      return keys_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < keys_.size(); i++) {
        output.writeMessage(1, keys_.get(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < keys_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, keys_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof envoy.api.v2.auth.Cert.TlsSessionTicketKeys)) {
        return super.equals(obj);
      }
      envoy.api.v2.auth.Cert.TlsSessionTicketKeys other = (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) obj;

      boolean result = true;
      result = result && getKeysList()
          .equals(other.getKeysList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getKeysCount() > 0) {
        hash = (37 * hash) + KEYS_FIELD_NUMBER;
        hash = (53 * hash) + getKeysList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(envoy.api.v2.auth.Cert.TlsSessionTicketKeys prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code envoy.api.v2.auth.TlsSessionTicketKeys}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.auth.TlsSessionTicketKeys)
        envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsSessionTicketKeys_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsSessionTicketKeys_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                envoy.api.v2.auth.Cert.TlsSessionTicketKeys.class, envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder.class);
      }

      // Construct using envoy.api.v2.auth.Cert.TlsSessionTicketKeys.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getKeysFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (keysBuilder_ == null) {
          keys_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          keysBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_TlsSessionTicketKeys_descriptor;
      }

      public envoy.api.v2.auth.Cert.TlsSessionTicketKeys getDefaultInstanceForType() {
        return envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
      }

      public envoy.api.v2.auth.Cert.TlsSessionTicketKeys build() {
        envoy.api.v2.auth.Cert.TlsSessionTicketKeys result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public envoy.api.v2.auth.Cert.TlsSessionTicketKeys buildPartial() {
        envoy.api.v2.auth.Cert.TlsSessionTicketKeys result = new envoy.api.v2.auth.Cert.TlsSessionTicketKeys(this);
        int from_bitField0_ = bitField0_;
        if (keysBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            keys_ = java.util.Collections.unmodifiableList(keys_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.keys_ = keys_;
        } else {
          result.keys_ = keysBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof envoy.api.v2.auth.Cert.TlsSessionTicketKeys) {
          return mergeFrom((envoy.api.v2.auth.Cert.TlsSessionTicketKeys)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(envoy.api.v2.auth.Cert.TlsSessionTicketKeys other) {
        if (other == envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance()) return this;
        if (keysBuilder_ == null) {
          if (!other.keys_.isEmpty()) {
            if (keys_.isEmpty()) {
              keys_ = other.keys_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureKeysIsMutable();
              keys_.addAll(other.keys_);
            }
            onChanged();
          }
        } else {
          if (!other.keys_.isEmpty()) {
            if (keysBuilder_.isEmpty()) {
              keysBuilder_.dispose();
              keysBuilder_ = null;
              keys_ = other.keys_;
              bitField0_ = (bitField0_ & ~0x00000001);
              keysBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getKeysFieldBuilder() : null;
            } else {
              keysBuilder_.addAllMessages(other.keys_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        envoy.api.v2.auth.Cert.TlsSessionTicketKeys parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<envoy.api.v2.core.Base.DataSource> keys_ =
        java.util.Collections.emptyList();
      private void ensureKeysIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          keys_ = new java.util.ArrayList<envoy.api.v2.core.Base.DataSource>(keys_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> keysBuilder_;

      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public java.util.List<envoy.api.v2.core.Base.DataSource> getKeysList() {
        if (keysBuilder_ == null) {
          return java.util.Collections.unmodifiableList(keys_);
        } else {
          return keysBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public int getKeysCount() {
        if (keysBuilder_ == null) {
          return keys_.size();
        } else {
          return keysBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public envoy.api.v2.core.Base.DataSource getKeys(int index) {
        if (keysBuilder_ == null) {
          return keys_.get(index);
        } else {
          return keysBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setKeys(
          int index, envoy.api.v2.core.Base.DataSource value) {
        if (keysBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeysIsMutable();
          keys_.set(index, value);
          onChanged();
        } else {
          keysBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder setKeys(
          int index, envoy.api.v2.core.Base.DataSource.Builder builderForValue) {
        if (keysBuilder_ == null) {
          ensureKeysIsMutable();
          keys_.set(index, builderForValue.build());
          onChanged();
        } else {
          keysBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder addKeys(envoy.api.v2.core.Base.DataSource value) {
        if (keysBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeysIsMutable();
          keys_.add(value);
          onChanged();
        } else {
          keysBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder addKeys(
          int index, envoy.api.v2.core.Base.DataSource value) {
        if (keysBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureKeysIsMutable();
          keys_.add(index, value);
          onChanged();
        } else {
          keysBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder addKeys(
          envoy.api.v2.core.Base.DataSource.Builder builderForValue) {
        if (keysBuilder_ == null) {
          ensureKeysIsMutable();
          keys_.add(builderForValue.build());
          onChanged();
        } else {
          keysBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder addKeys(
          int index, envoy.api.v2.core.Base.DataSource.Builder builderForValue) {
        if (keysBuilder_ == null) {
          ensureKeysIsMutable();
          keys_.add(index, builderForValue.build());
          onChanged();
        } else {
          keysBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder addAllKeys(
          java.lang.Iterable<? extends envoy.api.v2.core.Base.DataSource> values) {
        if (keysBuilder_ == null) {
          ensureKeysIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, keys_);
          onChanged();
        } else {
          keysBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder clearKeys() {
        if (keysBuilder_ == null) {
          keys_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          keysBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public Builder removeKeys(int index) {
        if (keysBuilder_ == null) {
          ensureKeysIsMutable();
          keys_.remove(index);
          onChanged();
        } else {
          keysBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public envoy.api.v2.core.Base.DataSource.Builder getKeysBuilder(
          int index) {
        return getKeysFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public envoy.api.v2.core.Base.DataSourceOrBuilder getKeysOrBuilder(
          int index) {
        if (keysBuilder_ == null) {
          return keys_.get(index);  } else {
          return keysBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public java.util.List<? extends envoy.api.v2.core.Base.DataSourceOrBuilder> 
           getKeysOrBuilderList() {
        if (keysBuilder_ != null) {
          return keysBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(keys_);
        }
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public envoy.api.v2.core.Base.DataSource.Builder addKeysBuilder() {
        return getKeysFieldBuilder().addBuilder(
            envoy.api.v2.core.Base.DataSource.getDefaultInstance());
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public envoy.api.v2.core.Base.DataSource.Builder addKeysBuilder(
          int index) {
        return getKeysFieldBuilder().addBuilder(
            index, envoy.api.v2.core.Base.DataSource.getDefaultInstance());
      }
      /**
       * <pre>
       * Keys for encrypting and decrypting TLS session tickets. The
       * first key in the array contains the key to encrypt all new sessions created by this context.
       * All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
       * by, for example, putting the new key first, and the previous key second.
       * If :ref:`session_ticket_keys &lt;envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys&gt;`
       * is not specified, the TLS library will still support resuming sessions via tickets, but it will
       * use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
       * or on different hosts.
       * Each key must contain exactly 80 bytes of cryptographically-secure random data. For
       * example, the output of ``openssl rand 80``.
       * .. attention::
       *   Using this feature has serious security considerations and risks. Improper handling of keys
       *   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
       *   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
       *   discussion. To minimize the risk, you must:
       *   * Keep the session ticket keys at least as secure as your TLS certificate private keys
       *   * Rotate session ticket keys at least daily, and preferably hourly
       *   * Always generate keys using a cryptographically-secure random data source
       * </pre>
       *
       * <code>repeated .envoy.api.v2.core.DataSource keys = 1 [(.validate.rules) = { ... }</code>
       */
      public java.util.List<envoy.api.v2.core.Base.DataSource.Builder> 
           getKeysBuilderList() {
        return getKeysFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> 
          getKeysFieldBuilder() {
        if (keysBuilder_ == null) {
          keysBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder>(
                  keys_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          keys_ = null;
        }
        return keysBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.auth.TlsSessionTicketKeys)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.auth.TlsSessionTicketKeys)
    private static final envoy.api.v2.auth.Cert.TlsSessionTicketKeys DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new envoy.api.v2.auth.Cert.TlsSessionTicketKeys();
    }

    public static envoy.api.v2.auth.Cert.TlsSessionTicketKeys getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TlsSessionTicketKeys>
        PARSER = new com.google.protobuf.AbstractParser<TlsSessionTicketKeys>() {
      public TlsSessionTicketKeys parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TlsSessionTicketKeys(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<TlsSessionTicketKeys> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TlsSessionTicketKeys> getParserForType() {
      return PARSER;
    }

    public envoy.api.v2.auth.Cert.TlsSessionTicketKeys getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CertificateValidationContextOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.auth.CertificateValidationContext)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * TLS certificate data containing certificate authority certificates to use in verifying
     * a presented peer certificate (e.g. server certificate for clusters or client certificate
     * for listeners). If not specified and a peer certificate is presented it will not be
     * verified. By default, a client certificate is optional, unless one of the additional
     * options (:ref:`require_client_certificate
     * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
     * :ref:`verify_subject_alt_name
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
     * specified.
     * It can optionally contain certificate revocation lists, in which case Envoy will verify
     * that the presented peer certificate has not been revoked by one of the included CRLs.
     * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
     * system CA locations.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
     */
    boolean hasTrustedCa();
    /**
     * <pre>
     * TLS certificate data containing certificate authority certificates to use in verifying
     * a presented peer certificate (e.g. server certificate for clusters or client certificate
     * for listeners). If not specified and a peer certificate is presented it will not be
     * verified. By default, a client certificate is optional, unless one of the additional
     * options (:ref:`require_client_certificate
     * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
     * :ref:`verify_subject_alt_name
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
     * specified.
     * It can optionally contain certificate revocation lists, in which case Envoy will verify
     * that the presented peer certificate has not been revoked by one of the included CRLs.
     * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
     * system CA locations.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
     */
    envoy.api.v2.core.Base.DataSource getTrustedCa();
    /**
     * <pre>
     * TLS certificate data containing certificate authority certificates to use in verifying
     * a presented peer certificate (e.g. server certificate for clusters or client certificate
     * for listeners). If not specified and a peer certificate is presented it will not be
     * verified. By default, a client certificate is optional, unless one of the additional
     * options (:ref:`require_client_certificate
     * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
     * :ref:`verify_subject_alt_name
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
     * specified.
     * It can optionally contain certificate revocation lists, in which case Envoy will verify
     * that the presented peer certificate has not been revoked by one of the included CRLs.
     * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
     * system CA locations.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
     */
    envoy.api.v2.core.Base.DataSourceOrBuilder getTrustedCaOrBuilder();

    /**
     * <pre>
     * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
     * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
     * matches one of the specified values.
     * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
     *     | openssl pkey -pubin -outform DER &#92;
     *     | openssl dgst -sha256 -binary &#92;
     *     | openssl enc -base64
     *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
     * This is the format used in HTTP Public Key Pinning.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * .. attention::
     *   This option is preferred over :ref:`verify_certificate_hash
     *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
     *   because SPKI is tied to a private key, so it doesn't change when the certificate
     *   is renewed using the same private key.
     * </pre>
     *
     * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
     */
    java.util.List<java.lang.String>
        getVerifyCertificateSpkiList();
    /**
     * <pre>
     * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
     * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
     * matches one of the specified values.
     * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
     *     | openssl pkey -pubin -outform DER &#92;
     *     | openssl dgst -sha256 -binary &#92;
     *     | openssl enc -base64
     *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
     * This is the format used in HTTP Public Key Pinning.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * .. attention::
     *   This option is preferred over :ref:`verify_certificate_hash
     *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
     *   because SPKI is tied to a private key, so it doesn't change when the certificate
     *   is renewed using the same private key.
     * </pre>
     *
     * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
     */
    int getVerifyCertificateSpkiCount();
    /**
     * <pre>
     * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
     * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
     * matches one of the specified values.
     * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
     *     | openssl pkey -pubin -outform DER &#92;
     *     | openssl dgst -sha256 -binary &#92;
     *     | openssl enc -base64
     *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
     * This is the format used in HTTP Public Key Pinning.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * .. attention::
     *   This option is preferred over :ref:`verify_certificate_hash
     *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
     *   because SPKI is tied to a private key, so it doesn't change when the certificate
     *   is renewed using the same private key.
     * </pre>
     *
     * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
     */
    java.lang.String getVerifyCertificateSpki(int index);
    /**
     * <pre>
     * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
     * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
     * matches one of the specified values.
     * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
     *     | openssl pkey -pubin -outform DER &#92;
     *     | openssl dgst -sha256 -binary &#92;
     *     | openssl enc -base64
     *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
     * This is the format used in HTTP Public Key Pinning.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * .. attention::
     *   This option is preferred over :ref:`verify_certificate_hash
     *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
     *   because SPKI is tied to a private key, so it doesn't change when the certificate
     *   is renewed using the same private key.
     * </pre>
     *
     * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.ByteString
        getVerifyCertificateSpkiBytes(int index);

    /**
     * <pre>
     * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
     * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
     * A hex-encoded SHA-256 of the certificate can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
     *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
     * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
     *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
     * Both of those formats are acceptable.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * </pre>
     *
     * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
     */
    java.util.List<java.lang.String>
        getVerifyCertificateHashList();
    /**
     * <pre>
     * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
     * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
     * A hex-encoded SHA-256 of the certificate can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
     *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
     * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
     *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
     * Both of those formats are acceptable.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * </pre>
     *
     * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
     */
    int getVerifyCertificateHashCount();
    /**
     * <pre>
     * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
     * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
     * A hex-encoded SHA-256 of the certificate can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
     *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
     * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
     *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
     * Both of those formats are acceptable.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * </pre>
     *
     * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
     */
    java.lang.String getVerifyCertificateHash(int index);
    /**
     * <pre>
     * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
     * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
     * A hex-encoded SHA-256 of the certificate can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
     *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
     * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
     *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
     * Both of those formats are acceptable.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * </pre>
     *
     * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.ByteString
        getVerifyCertificateHashBytes(int index);

    /**
     * <pre>
     * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
     * Subject Alternative Name of the presented certificate matches one of the specified values.
     * .. attention::
     *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
     *   therefore this option must be used together with :ref:`trusted_ca
     *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
     * </pre>
     *
     * <code>repeated string verify_subject_alt_name = 4;</code>
     */
    java.util.List<java.lang.String>
        getVerifySubjectAltNameList();
    /**
     * <pre>
     * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
     * Subject Alternative Name of the presented certificate matches one of the specified values.
     * .. attention::
     *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
     *   therefore this option must be used together with :ref:`trusted_ca
     *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
     * </pre>
     *
     * <code>repeated string verify_subject_alt_name = 4;</code>
     */
    int getVerifySubjectAltNameCount();
    /**
     * <pre>
     * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
     * Subject Alternative Name of the presented certificate matches one of the specified values.
     * .. attention::
     *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
     *   therefore this option must be used together with :ref:`trusted_ca
     *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
     * </pre>
     *
     * <code>repeated string verify_subject_alt_name = 4;</code>
     */
    java.lang.String getVerifySubjectAltName(int index);
    /**
     * <pre>
     * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
     * Subject Alternative Name of the presented certificate matches one of the specified values.
     * .. attention::
     *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
     *   therefore this option must be used together with :ref:`trusted_ca
     *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
     * </pre>
     *
     * <code>repeated string verify_subject_alt_name = 4;</code>
     */
    com.google.protobuf.ByteString
        getVerifySubjectAltNameBytes(int index);

    /**
     * <pre>
     * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
     */
    boolean hasRequireOcspStaple();
    /**
     * <pre>
     * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
     */
    com.google.protobuf.BoolValue getRequireOcspStaple();
    /**
     * <pre>
     * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
     */
    com.google.protobuf.BoolValueOrBuilder getRequireOcspStapleOrBuilder();

    /**
     * <pre>
     * [#not-implemented-hide:] Must present signed certificate time-stamp.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
     */
    boolean hasRequireSignedCertificateTimestamp();
    /**
     * <pre>
     * [#not-implemented-hide:] Must present signed certificate time-stamp.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
     */
    com.google.protobuf.BoolValue getRequireSignedCertificateTimestamp();
    /**
     * <pre>
     * [#not-implemented-hide:] Must present signed certificate time-stamp.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
     */
    com.google.protobuf.BoolValueOrBuilder getRequireSignedCertificateTimestampOrBuilder();

    /**
     * <pre>
     * An optional `certificate revocation list
     * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
     * (in PEM format). If specified, Envoy will verify that the presented peer
     * certificate has not been revoked by this CRL. If this DataSource contains
     * multiple CRLs, all of them will be used.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
     */
    boolean hasCrl();
    /**
     * <pre>
     * An optional `certificate revocation list
     * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
     * (in PEM format). If specified, Envoy will verify that the presented peer
     * certificate has not been revoked by this CRL. If this DataSource contains
     * multiple CRLs, all of them will be used.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
     */
    envoy.api.v2.core.Base.DataSource getCrl();
    /**
     * <pre>
     * An optional `certificate revocation list
     * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
     * (in PEM format). If specified, Envoy will verify that the presented peer
     * certificate has not been revoked by this CRL. If this DataSource contains
     * multiple CRLs, all of them will be used.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
     */
    envoy.api.v2.core.Base.DataSourceOrBuilder getCrlOrBuilder();

    /**
     * <pre>
     * If specified, Envoy will not reject expired certificates.
     * </pre>
     *
     * <code>bool allow_expired_certificate = 8;</code>
     */
    boolean getAllowExpiredCertificate();
  }
  /**
   * Protobuf type {@code envoy.api.v2.auth.CertificateValidationContext}
   */
  public  static final class CertificateValidationContext extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.auth.CertificateValidationContext)
      CertificateValidationContextOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CertificateValidationContext.newBuilder() to construct.
    private CertificateValidationContext(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CertificateValidationContext() {
      verifyCertificateSpki_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      verifyCertificateHash_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      verifySubjectAltName_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      allowExpiredCertificate_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CertificateValidationContext(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              envoy.api.v2.core.Base.DataSource.Builder subBuilder = null;
              if (trustedCa_ != null) {
                subBuilder = trustedCa_.toBuilder();
              }
              trustedCa_ = input.readMessage(envoy.api.v2.core.Base.DataSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(trustedCa_);
                trustedCa_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                verifyCertificateHash_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000004;
              }
              verifyCertificateHash_.add(s);
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                verifyCertificateSpki_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000002;
              }
              verifyCertificateSpki_.add(s);
              break;
            }
            case 34: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                verifySubjectAltName_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000008;
              }
              verifySubjectAltName_.add(s);
              break;
            }
            case 42: {
              com.google.protobuf.BoolValue.Builder subBuilder = null;
              if (requireOcspStaple_ != null) {
                subBuilder = requireOcspStaple_.toBuilder();
              }
              requireOcspStaple_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(requireOcspStaple_);
                requireOcspStaple_ = subBuilder.buildPartial();
              }

              break;
            }
            case 50: {
              com.google.protobuf.BoolValue.Builder subBuilder = null;
              if (requireSignedCertificateTimestamp_ != null) {
                subBuilder = requireSignedCertificateTimestamp_.toBuilder();
              }
              requireSignedCertificateTimestamp_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(requireSignedCertificateTimestamp_);
                requireSignedCertificateTimestamp_ = subBuilder.buildPartial();
              }

              break;
            }
            case 58: {
              envoy.api.v2.core.Base.DataSource.Builder subBuilder = null;
              if (crl_ != null) {
                subBuilder = crl_.toBuilder();
              }
              crl_ = input.readMessage(envoy.api.v2.core.Base.DataSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(crl_);
                crl_ = subBuilder.buildPartial();
              }

              break;
            }
            case 64: {

              allowExpiredCertificate_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          verifyCertificateHash_ = verifyCertificateHash_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          verifyCertificateSpki_ = verifyCertificateSpki_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          verifySubjectAltName_ = verifySubjectAltName_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CertificateValidationContext_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CertificateValidationContext_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              envoy.api.v2.auth.Cert.CertificateValidationContext.class, envoy.api.v2.auth.Cert.CertificateValidationContext.Builder.class);
    }

    private int bitField0_;
    public static final int TRUSTED_CA_FIELD_NUMBER = 1;
    private envoy.api.v2.core.Base.DataSource trustedCa_;
    /**
     * <pre>
     * TLS certificate data containing certificate authority certificates to use in verifying
     * a presented peer certificate (e.g. server certificate for clusters or client certificate
     * for listeners). If not specified and a peer certificate is presented it will not be
     * verified. By default, a client certificate is optional, unless one of the additional
     * options (:ref:`require_client_certificate
     * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
     * :ref:`verify_subject_alt_name
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
     * specified.
     * It can optionally contain certificate revocation lists, in which case Envoy will verify
     * that the presented peer certificate has not been revoked by one of the included CRLs.
     * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
     * system CA locations.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
     */
    public boolean hasTrustedCa() {
      return trustedCa_ != null;
    }
    /**
     * <pre>
     * TLS certificate data containing certificate authority certificates to use in verifying
     * a presented peer certificate (e.g. server certificate for clusters or client certificate
     * for listeners). If not specified and a peer certificate is presented it will not be
     * verified. By default, a client certificate is optional, unless one of the additional
     * options (:ref:`require_client_certificate
     * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
     * :ref:`verify_subject_alt_name
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
     * specified.
     * It can optionally contain certificate revocation lists, in which case Envoy will verify
     * that the presented peer certificate has not been revoked by one of the included CRLs.
     * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
     * system CA locations.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
     */
    public envoy.api.v2.core.Base.DataSource getTrustedCa() {
      return trustedCa_ == null ? envoy.api.v2.core.Base.DataSource.getDefaultInstance() : trustedCa_;
    }
    /**
     * <pre>
     * TLS certificate data containing certificate authority certificates to use in verifying
     * a presented peer certificate (e.g. server certificate for clusters or client certificate
     * for listeners). If not specified and a peer certificate is presented it will not be
     * verified. By default, a client certificate is optional, unless one of the additional
     * options (:ref:`require_client_certificate
     * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
     * :ref:`verify_subject_alt_name
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
     * specified.
     * It can optionally contain certificate revocation lists, in which case Envoy will verify
     * that the presented peer certificate has not been revoked by one of the included CRLs.
     * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
     * system CA locations.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
     */
    public envoy.api.v2.core.Base.DataSourceOrBuilder getTrustedCaOrBuilder() {
      return getTrustedCa();
    }

    public static final int VERIFY_CERTIFICATE_SPKI_FIELD_NUMBER = 3;
    private com.google.protobuf.LazyStringList verifyCertificateSpki_;
    /**
     * <pre>
     * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
     * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
     * matches one of the specified values.
     * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
     *     | openssl pkey -pubin -outform DER &#92;
     *     | openssl dgst -sha256 -binary &#92;
     *     | openssl enc -base64
     *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
     * This is the format used in HTTP Public Key Pinning.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * .. attention::
     *   This option is preferred over :ref:`verify_certificate_hash
     *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
     *   because SPKI is tied to a private key, so it doesn't change when the certificate
     *   is renewed using the same private key.
     * </pre>
     *
     * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.ProtocolStringList
        getVerifyCertificateSpkiList() {
      return verifyCertificateSpki_;
    }
    /**
     * <pre>
     * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
     * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
     * matches one of the specified values.
     * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
     *     | openssl pkey -pubin -outform DER &#92;
     *     | openssl dgst -sha256 -binary &#92;
     *     | openssl enc -base64
     *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
     * This is the format used in HTTP Public Key Pinning.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * .. attention::
     *   This option is preferred over :ref:`verify_certificate_hash
     *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
     *   because SPKI is tied to a private key, so it doesn't change when the certificate
     *   is renewed using the same private key.
     * </pre>
     *
     * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
     */
    public int getVerifyCertificateSpkiCount() {
      return verifyCertificateSpki_.size();
    }
    /**
     * <pre>
     * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
     * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
     * matches one of the specified values.
     * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
     *     | openssl pkey -pubin -outform DER &#92;
     *     | openssl dgst -sha256 -binary &#92;
     *     | openssl enc -base64
     *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
     * This is the format used in HTTP Public Key Pinning.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * .. attention::
     *   This option is preferred over :ref:`verify_certificate_hash
     *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
     *   because SPKI is tied to a private key, so it doesn't change when the certificate
     *   is renewed using the same private key.
     * </pre>
     *
     * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
     */
    public java.lang.String getVerifyCertificateSpki(int index) {
      return verifyCertificateSpki_.get(index);
    }
    /**
     * <pre>
     * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
     * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
     * matches one of the specified values.
     * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
     *     | openssl pkey -pubin -outform DER &#92;
     *     | openssl dgst -sha256 -binary &#92;
     *     | openssl enc -base64
     *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
     * This is the format used in HTTP Public Key Pinning.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * .. attention::
     *   This option is preferred over :ref:`verify_certificate_hash
     *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
     *   because SPKI is tied to a private key, so it doesn't change when the certificate
     *   is renewed using the same private key.
     * </pre>
     *
     * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.ByteString
        getVerifyCertificateSpkiBytes(int index) {
      return verifyCertificateSpki_.getByteString(index);
    }

    public static final int VERIFY_CERTIFICATE_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.LazyStringList verifyCertificateHash_;
    /**
     * <pre>
     * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
     * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
     * A hex-encoded SHA-256 of the certificate can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
     *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
     * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
     *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
     * Both of those formats are acceptable.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * </pre>
     *
     * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.ProtocolStringList
        getVerifyCertificateHashList() {
      return verifyCertificateHash_;
    }
    /**
     * <pre>
     * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
     * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
     * A hex-encoded SHA-256 of the certificate can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
     *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
     * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
     *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
     * Both of those formats are acceptable.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * </pre>
     *
     * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
     */
    public int getVerifyCertificateHashCount() {
      return verifyCertificateHash_.size();
    }
    /**
     * <pre>
     * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
     * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
     * A hex-encoded SHA-256 of the certificate can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
     *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
     * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
     *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
     * Both of those formats are acceptable.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * </pre>
     *
     * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
     */
    public java.lang.String getVerifyCertificateHash(int index) {
      return verifyCertificateHash_.get(index);
    }
    /**
     * <pre>
     * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
     * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
     * A hex-encoded SHA-256 of the certificate can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
     *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
     * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
     * can be generated with the following command:
     * .. code-block:: bash
     *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
     *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
     * Both of those formats are acceptable.
     * When both:
     * :ref:`verify_certificate_hash
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
     * :ref:`verify_certificate_spki
     * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
     * a hash matching value from either of the lists will result in the certificate being accepted.
     * </pre>
     *
     * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.ByteString
        getVerifyCertificateHashBytes(int index) {
      return verifyCertificateHash_.getByteString(index);
    }

    public static final int VERIFY_SUBJECT_ALT_NAME_FIELD_NUMBER = 4;
    private com.google.protobuf.LazyStringList verifySubjectAltName_;
    /**
     * <pre>
     * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
     * Subject Alternative Name of the presented certificate matches one of the specified values.
     * .. attention::
     *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
     *   therefore this option must be used together with :ref:`trusted_ca
     *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
     * </pre>
     *
     * <code>repeated string verify_subject_alt_name = 4;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getVerifySubjectAltNameList() {
      return verifySubjectAltName_;
    }
    /**
     * <pre>
     * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
     * Subject Alternative Name of the presented certificate matches one of the specified values.
     * .. attention::
     *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
     *   therefore this option must be used together with :ref:`trusted_ca
     *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
     * </pre>
     *
     * <code>repeated string verify_subject_alt_name = 4;</code>
     */
    public int getVerifySubjectAltNameCount() {
      return verifySubjectAltName_.size();
    }
    /**
     * <pre>
     * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
     * Subject Alternative Name of the presented certificate matches one of the specified values.
     * .. attention::
     *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
     *   therefore this option must be used together with :ref:`trusted_ca
     *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
     * </pre>
     *
     * <code>repeated string verify_subject_alt_name = 4;</code>
     */
    public java.lang.String getVerifySubjectAltName(int index) {
      return verifySubjectAltName_.get(index);
    }
    /**
     * <pre>
     * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
     * Subject Alternative Name of the presented certificate matches one of the specified values.
     * .. attention::
     *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
     *   therefore this option must be used together with :ref:`trusted_ca
     *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
     * </pre>
     *
     * <code>repeated string verify_subject_alt_name = 4;</code>
     */
    public com.google.protobuf.ByteString
        getVerifySubjectAltNameBytes(int index) {
      return verifySubjectAltName_.getByteString(index);
    }

    public static final int REQUIRE_OCSP_STAPLE_FIELD_NUMBER = 5;
    private com.google.protobuf.BoolValue requireOcspStaple_;
    /**
     * <pre>
     * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
     */
    public boolean hasRequireOcspStaple() {
      return requireOcspStaple_ != null;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
     */
    public com.google.protobuf.BoolValue getRequireOcspStaple() {
      return requireOcspStaple_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : requireOcspStaple_;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getRequireOcspStapleOrBuilder() {
      return getRequireOcspStaple();
    }

    public static final int REQUIRE_SIGNED_CERTIFICATE_TIMESTAMP_FIELD_NUMBER = 6;
    private com.google.protobuf.BoolValue requireSignedCertificateTimestamp_;
    /**
     * <pre>
     * [#not-implemented-hide:] Must present signed certificate time-stamp.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
     */
    public boolean hasRequireSignedCertificateTimestamp() {
      return requireSignedCertificateTimestamp_ != null;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Must present signed certificate time-stamp.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
     */
    public com.google.protobuf.BoolValue getRequireSignedCertificateTimestamp() {
      return requireSignedCertificateTimestamp_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : requireSignedCertificateTimestamp_;
    }
    /**
     * <pre>
     * [#not-implemented-hide:] Must present signed certificate time-stamp.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getRequireSignedCertificateTimestampOrBuilder() {
      return getRequireSignedCertificateTimestamp();
    }

    public static final int CRL_FIELD_NUMBER = 7;
    private envoy.api.v2.core.Base.DataSource crl_;
    /**
     * <pre>
     * An optional `certificate revocation list
     * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
     * (in PEM format). If specified, Envoy will verify that the presented peer
     * certificate has not been revoked by this CRL. If this DataSource contains
     * multiple CRLs, all of them will be used.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
     */
    public boolean hasCrl() {
      return crl_ != null;
    }
    /**
     * <pre>
     * An optional `certificate revocation list
     * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
     * (in PEM format). If specified, Envoy will verify that the presented peer
     * certificate has not been revoked by this CRL. If this DataSource contains
     * multiple CRLs, all of them will be used.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
     */
    public envoy.api.v2.core.Base.DataSource getCrl() {
      return crl_ == null ? envoy.api.v2.core.Base.DataSource.getDefaultInstance() : crl_;
    }
    /**
     * <pre>
     * An optional `certificate revocation list
     * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
     * (in PEM format). If specified, Envoy will verify that the presented peer
     * certificate has not been revoked by this CRL. If this DataSource contains
     * multiple CRLs, all of them will be used.
     * </pre>
     *
     * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
     */
    public envoy.api.v2.core.Base.DataSourceOrBuilder getCrlOrBuilder() {
      return getCrl();
    }

    public static final int ALLOW_EXPIRED_CERTIFICATE_FIELD_NUMBER = 8;
    private boolean allowExpiredCertificate_;
    /**
     * <pre>
     * If specified, Envoy will not reject expired certificates.
     * </pre>
     *
     * <code>bool allow_expired_certificate = 8;</code>
     */
    public boolean getAllowExpiredCertificate() {
      return allowExpiredCertificate_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (trustedCa_ != null) {
        output.writeMessage(1, getTrustedCa());
      }
      for (int i = 0; i < verifyCertificateHash_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, verifyCertificateHash_.getRaw(i));
      }
      for (int i = 0; i < verifyCertificateSpki_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, verifyCertificateSpki_.getRaw(i));
      }
      for (int i = 0; i < verifySubjectAltName_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, verifySubjectAltName_.getRaw(i));
      }
      if (requireOcspStaple_ != null) {
        output.writeMessage(5, getRequireOcspStaple());
      }
      if (requireSignedCertificateTimestamp_ != null) {
        output.writeMessage(6, getRequireSignedCertificateTimestamp());
      }
      if (crl_ != null) {
        output.writeMessage(7, getCrl());
      }
      if (allowExpiredCertificate_ != false) {
        output.writeBool(8, allowExpiredCertificate_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (trustedCa_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getTrustedCa());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < verifyCertificateHash_.size(); i++) {
          dataSize += computeStringSizeNoTag(verifyCertificateHash_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getVerifyCertificateHashList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < verifyCertificateSpki_.size(); i++) {
          dataSize += computeStringSizeNoTag(verifyCertificateSpki_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getVerifyCertificateSpkiList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < verifySubjectAltName_.size(); i++) {
          dataSize += computeStringSizeNoTag(verifySubjectAltName_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getVerifySubjectAltNameList().size();
      }
      if (requireOcspStaple_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getRequireOcspStaple());
      }
      if (requireSignedCertificateTimestamp_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getRequireSignedCertificateTimestamp());
      }
      if (crl_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getCrl());
      }
      if (allowExpiredCertificate_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(8, allowExpiredCertificate_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof envoy.api.v2.auth.Cert.CertificateValidationContext)) {
        return super.equals(obj);
      }
      envoy.api.v2.auth.Cert.CertificateValidationContext other = (envoy.api.v2.auth.Cert.CertificateValidationContext) obj;

      boolean result = true;
      result = result && (hasTrustedCa() == other.hasTrustedCa());
      if (hasTrustedCa()) {
        result = result && getTrustedCa()
            .equals(other.getTrustedCa());
      }
      result = result && getVerifyCertificateSpkiList()
          .equals(other.getVerifyCertificateSpkiList());
      result = result && getVerifyCertificateHashList()
          .equals(other.getVerifyCertificateHashList());
      result = result && getVerifySubjectAltNameList()
          .equals(other.getVerifySubjectAltNameList());
      result = result && (hasRequireOcspStaple() == other.hasRequireOcspStaple());
      if (hasRequireOcspStaple()) {
        result = result && getRequireOcspStaple()
            .equals(other.getRequireOcspStaple());
      }
      result = result && (hasRequireSignedCertificateTimestamp() == other.hasRequireSignedCertificateTimestamp());
      if (hasRequireSignedCertificateTimestamp()) {
        result = result && getRequireSignedCertificateTimestamp()
            .equals(other.getRequireSignedCertificateTimestamp());
      }
      result = result && (hasCrl() == other.hasCrl());
      if (hasCrl()) {
        result = result && getCrl()
            .equals(other.getCrl());
      }
      result = result && (getAllowExpiredCertificate()
          == other.getAllowExpiredCertificate());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTrustedCa()) {
        hash = (37 * hash) + TRUSTED_CA_FIELD_NUMBER;
        hash = (53 * hash) + getTrustedCa().hashCode();
      }
      if (getVerifyCertificateSpkiCount() > 0) {
        hash = (37 * hash) + VERIFY_CERTIFICATE_SPKI_FIELD_NUMBER;
        hash = (53 * hash) + getVerifyCertificateSpkiList().hashCode();
      }
      if (getVerifyCertificateHashCount() > 0) {
        hash = (37 * hash) + VERIFY_CERTIFICATE_HASH_FIELD_NUMBER;
        hash = (53 * hash) + getVerifyCertificateHashList().hashCode();
      }
      if (getVerifySubjectAltNameCount() > 0) {
        hash = (37 * hash) + VERIFY_SUBJECT_ALT_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getVerifySubjectAltNameList().hashCode();
      }
      if (hasRequireOcspStaple()) {
        hash = (37 * hash) + REQUIRE_OCSP_STAPLE_FIELD_NUMBER;
        hash = (53 * hash) + getRequireOcspStaple().hashCode();
      }
      if (hasRequireSignedCertificateTimestamp()) {
        hash = (37 * hash) + REQUIRE_SIGNED_CERTIFICATE_TIMESTAMP_FIELD_NUMBER;
        hash = (53 * hash) + getRequireSignedCertificateTimestamp().hashCode();
      }
      if (hasCrl()) {
        hash = (37 * hash) + CRL_FIELD_NUMBER;
        hash = (53 * hash) + getCrl().hashCode();
      }
      hash = (37 * hash) + ALLOW_EXPIRED_CERTIFICATE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getAllowExpiredCertificate());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static envoy.api.v2.auth.Cert.CertificateValidationContext parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.CertificateValidationContext parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.CertificateValidationContext parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.CertificateValidationContext parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.CertificateValidationContext parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.CertificateValidationContext parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.CertificateValidationContext parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.CertificateValidationContext parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.CertificateValidationContext parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.CertificateValidationContext parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.CertificateValidationContext parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.CertificateValidationContext parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(envoy.api.v2.auth.Cert.CertificateValidationContext prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code envoy.api.v2.auth.CertificateValidationContext}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.auth.CertificateValidationContext)
        envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CertificateValidationContext_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CertificateValidationContext_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                envoy.api.v2.auth.Cert.CertificateValidationContext.class, envoy.api.v2.auth.Cert.CertificateValidationContext.Builder.class);
      }

      // Construct using envoy.api.v2.auth.Cert.CertificateValidationContext.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (trustedCaBuilder_ == null) {
          trustedCa_ = null;
        } else {
          trustedCa_ = null;
          trustedCaBuilder_ = null;
        }
        verifyCertificateSpki_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        verifyCertificateHash_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        verifySubjectAltName_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000008);
        if (requireOcspStapleBuilder_ == null) {
          requireOcspStaple_ = null;
        } else {
          requireOcspStaple_ = null;
          requireOcspStapleBuilder_ = null;
        }
        if (requireSignedCertificateTimestampBuilder_ == null) {
          requireSignedCertificateTimestamp_ = null;
        } else {
          requireSignedCertificateTimestamp_ = null;
          requireSignedCertificateTimestampBuilder_ = null;
        }
        if (crlBuilder_ == null) {
          crl_ = null;
        } else {
          crl_ = null;
          crlBuilder_ = null;
        }
        allowExpiredCertificate_ = false;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CertificateValidationContext_descriptor;
      }

      public envoy.api.v2.auth.Cert.CertificateValidationContext getDefaultInstanceForType() {
        return envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
      }

      public envoy.api.v2.auth.Cert.CertificateValidationContext build() {
        envoy.api.v2.auth.Cert.CertificateValidationContext result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public envoy.api.v2.auth.Cert.CertificateValidationContext buildPartial() {
        envoy.api.v2.auth.Cert.CertificateValidationContext result = new envoy.api.v2.auth.Cert.CertificateValidationContext(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (trustedCaBuilder_ == null) {
          result.trustedCa_ = trustedCa_;
        } else {
          result.trustedCa_ = trustedCaBuilder_.build();
        }
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          verifyCertificateSpki_ = verifyCertificateSpki_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.verifyCertificateSpki_ = verifyCertificateSpki_;
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          verifyCertificateHash_ = verifyCertificateHash_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.verifyCertificateHash_ = verifyCertificateHash_;
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
          verifySubjectAltName_ = verifySubjectAltName_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.verifySubjectAltName_ = verifySubjectAltName_;
        if (requireOcspStapleBuilder_ == null) {
          result.requireOcspStaple_ = requireOcspStaple_;
        } else {
          result.requireOcspStaple_ = requireOcspStapleBuilder_.build();
        }
        if (requireSignedCertificateTimestampBuilder_ == null) {
          result.requireSignedCertificateTimestamp_ = requireSignedCertificateTimestamp_;
        } else {
          result.requireSignedCertificateTimestamp_ = requireSignedCertificateTimestampBuilder_.build();
        }
        if (crlBuilder_ == null) {
          result.crl_ = crl_;
        } else {
          result.crl_ = crlBuilder_.build();
        }
        result.allowExpiredCertificate_ = allowExpiredCertificate_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof envoy.api.v2.auth.Cert.CertificateValidationContext) {
          return mergeFrom((envoy.api.v2.auth.Cert.CertificateValidationContext)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(envoy.api.v2.auth.Cert.CertificateValidationContext other) {
        if (other == envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance()) return this;
        if (other.hasTrustedCa()) {
          mergeTrustedCa(other.getTrustedCa());
        }
        if (!other.verifyCertificateSpki_.isEmpty()) {
          if (verifyCertificateSpki_.isEmpty()) {
            verifyCertificateSpki_ = other.verifyCertificateSpki_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureVerifyCertificateSpkiIsMutable();
            verifyCertificateSpki_.addAll(other.verifyCertificateSpki_);
          }
          onChanged();
        }
        if (!other.verifyCertificateHash_.isEmpty()) {
          if (verifyCertificateHash_.isEmpty()) {
            verifyCertificateHash_ = other.verifyCertificateHash_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureVerifyCertificateHashIsMutable();
            verifyCertificateHash_.addAll(other.verifyCertificateHash_);
          }
          onChanged();
        }
        if (!other.verifySubjectAltName_.isEmpty()) {
          if (verifySubjectAltName_.isEmpty()) {
            verifySubjectAltName_ = other.verifySubjectAltName_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureVerifySubjectAltNameIsMutable();
            verifySubjectAltName_.addAll(other.verifySubjectAltName_);
          }
          onChanged();
        }
        if (other.hasRequireOcspStaple()) {
          mergeRequireOcspStaple(other.getRequireOcspStaple());
        }
        if (other.hasRequireSignedCertificateTimestamp()) {
          mergeRequireSignedCertificateTimestamp(other.getRequireSignedCertificateTimestamp());
        }
        if (other.hasCrl()) {
          mergeCrl(other.getCrl());
        }
        if (other.getAllowExpiredCertificate() != false) {
          setAllowExpiredCertificate(other.getAllowExpiredCertificate());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        envoy.api.v2.auth.Cert.CertificateValidationContext parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (envoy.api.v2.auth.Cert.CertificateValidationContext) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private envoy.api.v2.core.Base.DataSource trustedCa_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> trustedCaBuilder_;
      /**
       * <pre>
       * TLS certificate data containing certificate authority certificates to use in verifying
       * a presented peer certificate (e.g. server certificate for clusters or client certificate
       * for listeners). If not specified and a peer certificate is presented it will not be
       * verified. By default, a client certificate is optional, unless one of the additional
       * options (:ref:`require_client_certificate
       * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
       * :ref:`verify_subject_alt_name
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
       * specified.
       * It can optionally contain certificate revocation lists, in which case Envoy will verify
       * that the presented peer certificate has not been revoked by one of the included CRLs.
       * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
       * system CA locations.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
       */
      public boolean hasTrustedCa() {
        return trustedCaBuilder_ != null || trustedCa_ != null;
      }
      /**
       * <pre>
       * TLS certificate data containing certificate authority certificates to use in verifying
       * a presented peer certificate (e.g. server certificate for clusters or client certificate
       * for listeners). If not specified and a peer certificate is presented it will not be
       * verified. By default, a client certificate is optional, unless one of the additional
       * options (:ref:`require_client_certificate
       * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
       * :ref:`verify_subject_alt_name
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
       * specified.
       * It can optionally contain certificate revocation lists, in which case Envoy will verify
       * that the presented peer certificate has not been revoked by one of the included CRLs.
       * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
       * system CA locations.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
       */
      public envoy.api.v2.core.Base.DataSource getTrustedCa() {
        if (trustedCaBuilder_ == null) {
          return trustedCa_ == null ? envoy.api.v2.core.Base.DataSource.getDefaultInstance() : trustedCa_;
        } else {
          return trustedCaBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * TLS certificate data containing certificate authority certificates to use in verifying
       * a presented peer certificate (e.g. server certificate for clusters or client certificate
       * for listeners). If not specified and a peer certificate is presented it will not be
       * verified. By default, a client certificate is optional, unless one of the additional
       * options (:ref:`require_client_certificate
       * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
       * :ref:`verify_subject_alt_name
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
       * specified.
       * It can optionally contain certificate revocation lists, in which case Envoy will verify
       * that the presented peer certificate has not been revoked by one of the included CRLs.
       * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
       * system CA locations.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
       */
      public Builder setTrustedCa(envoy.api.v2.core.Base.DataSource value) {
        if (trustedCaBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          trustedCa_ = value;
          onChanged();
        } else {
          trustedCaBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * TLS certificate data containing certificate authority certificates to use in verifying
       * a presented peer certificate (e.g. server certificate for clusters or client certificate
       * for listeners). If not specified and a peer certificate is presented it will not be
       * verified. By default, a client certificate is optional, unless one of the additional
       * options (:ref:`require_client_certificate
       * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
       * :ref:`verify_subject_alt_name
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
       * specified.
       * It can optionally contain certificate revocation lists, in which case Envoy will verify
       * that the presented peer certificate has not been revoked by one of the included CRLs.
       * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
       * system CA locations.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
       */
      public Builder setTrustedCa(
          envoy.api.v2.core.Base.DataSource.Builder builderForValue) {
        if (trustedCaBuilder_ == null) {
          trustedCa_ = builderForValue.build();
          onChanged();
        } else {
          trustedCaBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * TLS certificate data containing certificate authority certificates to use in verifying
       * a presented peer certificate (e.g. server certificate for clusters or client certificate
       * for listeners). If not specified and a peer certificate is presented it will not be
       * verified. By default, a client certificate is optional, unless one of the additional
       * options (:ref:`require_client_certificate
       * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
       * :ref:`verify_subject_alt_name
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
       * specified.
       * It can optionally contain certificate revocation lists, in which case Envoy will verify
       * that the presented peer certificate has not been revoked by one of the included CRLs.
       * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
       * system CA locations.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
       */
      public Builder mergeTrustedCa(envoy.api.v2.core.Base.DataSource value) {
        if (trustedCaBuilder_ == null) {
          if (trustedCa_ != null) {
            trustedCa_ =
              envoy.api.v2.core.Base.DataSource.newBuilder(trustedCa_).mergeFrom(value).buildPartial();
          } else {
            trustedCa_ = value;
          }
          onChanged();
        } else {
          trustedCaBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * TLS certificate data containing certificate authority certificates to use in verifying
       * a presented peer certificate (e.g. server certificate for clusters or client certificate
       * for listeners). If not specified and a peer certificate is presented it will not be
       * verified. By default, a client certificate is optional, unless one of the additional
       * options (:ref:`require_client_certificate
       * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
       * :ref:`verify_subject_alt_name
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
       * specified.
       * It can optionally contain certificate revocation lists, in which case Envoy will verify
       * that the presented peer certificate has not been revoked by one of the included CRLs.
       * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
       * system CA locations.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
       */
      public Builder clearTrustedCa() {
        if (trustedCaBuilder_ == null) {
          trustedCa_ = null;
          onChanged();
        } else {
          trustedCa_ = null;
          trustedCaBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * TLS certificate data containing certificate authority certificates to use in verifying
       * a presented peer certificate (e.g. server certificate for clusters or client certificate
       * for listeners). If not specified and a peer certificate is presented it will not be
       * verified. By default, a client certificate is optional, unless one of the additional
       * options (:ref:`require_client_certificate
       * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
       * :ref:`verify_subject_alt_name
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
       * specified.
       * It can optionally contain certificate revocation lists, in which case Envoy will verify
       * that the presented peer certificate has not been revoked by one of the included CRLs.
       * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
       * system CA locations.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
       */
      public envoy.api.v2.core.Base.DataSource.Builder getTrustedCaBuilder() {
        
        onChanged();
        return getTrustedCaFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * TLS certificate data containing certificate authority certificates to use in verifying
       * a presented peer certificate (e.g. server certificate for clusters or client certificate
       * for listeners). If not specified and a peer certificate is presented it will not be
       * verified. By default, a client certificate is optional, unless one of the additional
       * options (:ref:`require_client_certificate
       * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
       * :ref:`verify_subject_alt_name
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
       * specified.
       * It can optionally contain certificate revocation lists, in which case Envoy will verify
       * that the presented peer certificate has not been revoked by one of the included CRLs.
       * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
       * system CA locations.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
       */
      public envoy.api.v2.core.Base.DataSourceOrBuilder getTrustedCaOrBuilder() {
        if (trustedCaBuilder_ != null) {
          return trustedCaBuilder_.getMessageOrBuilder();
        } else {
          return trustedCa_ == null ?
              envoy.api.v2.core.Base.DataSource.getDefaultInstance() : trustedCa_;
        }
      }
      /**
       * <pre>
       * TLS certificate data containing certificate authority certificates to use in verifying
       * a presented peer certificate (e.g. server certificate for clusters or client certificate
       * for listeners). If not specified and a peer certificate is presented it will not be
       * verified. By default, a client certificate is optional, unless one of the additional
       * options (:ref:`require_client_certificate
       * &lt;envoy_api_field_auth.DownstreamTlsContext.require_client_certificate&gt;`,
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;`,
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`, or
       * :ref:`verify_subject_alt_name
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_subject_alt_name&gt;`) is also
       * specified.
       * It can optionally contain certificate revocation lists, in which case Envoy will verify
       * that the presented peer certificate has not been revoked by one of the included CRLs.
       * See :ref:`the TLS overview &lt;arch_overview_ssl_enabling_verification&gt;` for a list of common
       * system CA locations.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource trusted_ca = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> 
          getTrustedCaFieldBuilder() {
        if (trustedCaBuilder_ == null) {
          trustedCaBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder>(
                  getTrustedCa(),
                  getParentForChildren(),
                  isClean());
          trustedCa_ = null;
        }
        return trustedCaBuilder_;
      }

      private com.google.protobuf.LazyStringList verifyCertificateSpki_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureVerifyCertificateSpkiIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          verifyCertificateSpki_ = new com.google.protobuf.LazyStringArrayList(verifyCertificateSpki_);
          bitField0_ |= 0x00000002;
         }
      }
      /**
       * <pre>
       * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
       * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
       * matches one of the specified values.
       * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
       *     | openssl pkey -pubin -outform DER &#92;
       *     | openssl dgst -sha256 -binary &#92;
       *     | openssl enc -base64
       *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
       * This is the format used in HTTP Public Key Pinning.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * .. attention::
       *   This option is preferred over :ref:`verify_certificate_hash
       *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
       *   because SPKI is tied to a private key, so it doesn't change when the certificate
       *   is renewed using the same private key.
       * </pre>
       *
       * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.ProtocolStringList
          getVerifyCertificateSpkiList() {
        return verifyCertificateSpki_.getUnmodifiableView();
      }
      /**
       * <pre>
       * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
       * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
       * matches one of the specified values.
       * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
       *     | openssl pkey -pubin -outform DER &#92;
       *     | openssl dgst -sha256 -binary &#92;
       *     | openssl enc -base64
       *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
       * This is the format used in HTTP Public Key Pinning.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * .. attention::
       *   This option is preferred over :ref:`verify_certificate_hash
       *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
       *   because SPKI is tied to a private key, so it doesn't change when the certificate
       *   is renewed using the same private key.
       * </pre>
       *
       * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
       */
      public int getVerifyCertificateSpkiCount() {
        return verifyCertificateSpki_.size();
      }
      /**
       * <pre>
       * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
       * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
       * matches one of the specified values.
       * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
       *     | openssl pkey -pubin -outform DER &#92;
       *     | openssl dgst -sha256 -binary &#92;
       *     | openssl enc -base64
       *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
       * This is the format used in HTTP Public Key Pinning.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * .. attention::
       *   This option is preferred over :ref:`verify_certificate_hash
       *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
       *   because SPKI is tied to a private key, so it doesn't change when the certificate
       *   is renewed using the same private key.
       * </pre>
       *
       * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
       */
      public java.lang.String getVerifyCertificateSpki(int index) {
        return verifyCertificateSpki_.get(index);
      }
      /**
       * <pre>
       * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
       * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
       * matches one of the specified values.
       * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
       *     | openssl pkey -pubin -outform DER &#92;
       *     | openssl dgst -sha256 -binary &#92;
       *     | openssl enc -base64
       *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
       * This is the format used in HTTP Public Key Pinning.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * .. attention::
       *   This option is preferred over :ref:`verify_certificate_hash
       *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
       *   because SPKI is tied to a private key, so it doesn't change when the certificate
       *   is renewed using the same private key.
       * </pre>
       *
       * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.ByteString
          getVerifyCertificateSpkiBytes(int index) {
        return verifyCertificateSpki_.getByteString(index);
      }
      /**
       * <pre>
       * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
       * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
       * matches one of the specified values.
       * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
       *     | openssl pkey -pubin -outform DER &#92;
       *     | openssl dgst -sha256 -binary &#92;
       *     | openssl enc -base64
       *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
       * This is the format used in HTTP Public Key Pinning.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * .. attention::
       *   This option is preferred over :ref:`verify_certificate_hash
       *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
       *   because SPKI is tied to a private key, so it doesn't change when the certificate
       *   is renewed using the same private key.
       * </pre>
       *
       * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder setVerifyCertificateSpki(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureVerifyCertificateSpkiIsMutable();
        verifyCertificateSpki_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
       * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
       * matches one of the specified values.
       * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
       *     | openssl pkey -pubin -outform DER &#92;
       *     | openssl dgst -sha256 -binary &#92;
       *     | openssl enc -base64
       *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
       * This is the format used in HTTP Public Key Pinning.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * .. attention::
       *   This option is preferred over :ref:`verify_certificate_hash
       *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
       *   because SPKI is tied to a private key, so it doesn't change when the certificate
       *   is renewed using the same private key.
       * </pre>
       *
       * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder addVerifyCertificateSpki(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureVerifyCertificateSpkiIsMutable();
        verifyCertificateSpki_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
       * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
       * matches one of the specified values.
       * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
       *     | openssl pkey -pubin -outform DER &#92;
       *     | openssl dgst -sha256 -binary &#92;
       *     | openssl enc -base64
       *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
       * This is the format used in HTTP Public Key Pinning.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * .. attention::
       *   This option is preferred over :ref:`verify_certificate_hash
       *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
       *   because SPKI is tied to a private key, so it doesn't change when the certificate
       *   is renewed using the same private key.
       * </pre>
       *
       * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder addAllVerifyCertificateSpki(
          java.lang.Iterable<java.lang.String> values) {
        ensureVerifyCertificateSpkiIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, verifyCertificateSpki_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
       * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
       * matches one of the specified values.
       * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
       *     | openssl pkey -pubin -outform DER &#92;
       *     | openssl dgst -sha256 -binary &#92;
       *     | openssl enc -base64
       *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
       * This is the format used in HTTP Public Key Pinning.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * .. attention::
       *   This option is preferred over :ref:`verify_certificate_hash
       *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
       *   because SPKI is tied to a private key, so it doesn't change when the certificate
       *   is renewed using the same private key.
       * </pre>
       *
       * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder clearVerifyCertificateSpki() {
        verifyCertificateSpki_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
       * SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
       * matches one of the specified values.
       * A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -pubkey &#92;
       *     | openssl pkey -pubin -outform DER &#92;
       *     | openssl dgst -sha256 -binary &#92;
       *     | openssl enc -base64
       *   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
       * This is the format used in HTTP Public Key Pinning.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * .. attention::
       *   This option is preferred over :ref:`verify_certificate_hash
       *   &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;`,
       *   because SPKI is tied to a private key, so it doesn't change when the certificate
       *   is renewed using the same private key.
       * </pre>
       *
       * <code>repeated string verify_certificate_spki = 3 [(.validate.rules) = { ... }</code>
       */
      public Builder addVerifyCertificateSpkiBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureVerifyCertificateSpkiIsMutable();
        verifyCertificateSpki_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList verifyCertificateHash_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureVerifyCertificateHashIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          verifyCertificateHash_ = new com.google.protobuf.LazyStringArrayList(verifyCertificateHash_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
       * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
       * A hex-encoded SHA-256 of the certificate can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
       *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
       * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
       *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
       * Both of those formats are acceptable.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * </pre>
       *
       * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.ProtocolStringList
          getVerifyCertificateHashList() {
        return verifyCertificateHash_.getUnmodifiableView();
      }
      /**
       * <pre>
       * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
       * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
       * A hex-encoded SHA-256 of the certificate can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
       *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
       * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
       *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
       * Both of those formats are acceptable.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * </pre>
       *
       * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
       */
      public int getVerifyCertificateHashCount() {
        return verifyCertificateHash_.size();
      }
      /**
       * <pre>
       * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
       * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
       * A hex-encoded SHA-256 of the certificate can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
       *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
       * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
       *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
       * Both of those formats are acceptable.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * </pre>
       *
       * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
       */
      public java.lang.String getVerifyCertificateHash(int index) {
        return verifyCertificateHash_.get(index);
      }
      /**
       * <pre>
       * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
       * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
       * A hex-encoded SHA-256 of the certificate can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
       *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
       * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
       *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
       * Both of those formats are acceptable.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * </pre>
       *
       * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.ByteString
          getVerifyCertificateHashBytes(int index) {
        return verifyCertificateHash_.getByteString(index);
      }
      /**
       * <pre>
       * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
       * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
       * A hex-encoded SHA-256 of the certificate can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
       *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
       * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
       *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
       * Both of those formats are acceptable.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * </pre>
       *
       * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder setVerifyCertificateHash(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureVerifyCertificateHashIsMutable();
        verifyCertificateHash_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
       * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
       * A hex-encoded SHA-256 of the certificate can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
       *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
       * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
       *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
       * Both of those formats are acceptable.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * </pre>
       *
       * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder addVerifyCertificateHash(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureVerifyCertificateHashIsMutable();
        verifyCertificateHash_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
       * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
       * A hex-encoded SHA-256 of the certificate can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
       *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
       * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
       *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
       * Both of those formats are acceptable.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * </pre>
       *
       * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder addAllVerifyCertificateHash(
          java.lang.Iterable<java.lang.String> values) {
        ensureVerifyCertificateHashIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, verifyCertificateHash_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
       * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
       * A hex-encoded SHA-256 of the certificate can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
       *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
       * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
       *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
       * Both of those formats are acceptable.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * </pre>
       *
       * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder clearVerifyCertificateHash() {
        verifyCertificateHash_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
       * the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
       * A hex-encoded SHA-256 of the certificate can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
       *   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
       * A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
       * can be generated with the following command:
       * .. code-block:: bash
       *   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
       *   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
       * Both of those formats are acceptable.
       * When both:
       * :ref:`verify_certificate_hash
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash&gt;` and
       * :ref:`verify_certificate_spki
       * &lt;envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki&gt;` are specified,
       * a hash matching value from either of the lists will result in the certificate being accepted.
       * </pre>
       *
       * <code>repeated string verify_certificate_hash = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder addVerifyCertificateHashBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureVerifyCertificateHashIsMutable();
        verifyCertificateHash_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList verifySubjectAltName_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureVerifySubjectAltNameIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          verifySubjectAltName_ = new com.google.protobuf.LazyStringArrayList(verifySubjectAltName_);
          bitField0_ |= 0x00000008;
         }
      }
      /**
       * <pre>
       * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
       * Subject Alternative Name of the presented certificate matches one of the specified values.
       * .. attention::
       *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
       *   therefore this option must be used together with :ref:`trusted_ca
       *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
       * </pre>
       *
       * <code>repeated string verify_subject_alt_name = 4;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getVerifySubjectAltNameList() {
        return verifySubjectAltName_.getUnmodifiableView();
      }
      /**
       * <pre>
       * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
       * Subject Alternative Name of the presented certificate matches one of the specified values.
       * .. attention::
       *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
       *   therefore this option must be used together with :ref:`trusted_ca
       *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
       * </pre>
       *
       * <code>repeated string verify_subject_alt_name = 4;</code>
       */
      public int getVerifySubjectAltNameCount() {
        return verifySubjectAltName_.size();
      }
      /**
       * <pre>
       * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
       * Subject Alternative Name of the presented certificate matches one of the specified values.
       * .. attention::
       *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
       *   therefore this option must be used together with :ref:`trusted_ca
       *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
       * </pre>
       *
       * <code>repeated string verify_subject_alt_name = 4;</code>
       */
      public java.lang.String getVerifySubjectAltName(int index) {
        return verifySubjectAltName_.get(index);
      }
      /**
       * <pre>
       * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
       * Subject Alternative Name of the presented certificate matches one of the specified values.
       * .. attention::
       *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
       *   therefore this option must be used together with :ref:`trusted_ca
       *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
       * </pre>
       *
       * <code>repeated string verify_subject_alt_name = 4;</code>
       */
      public com.google.protobuf.ByteString
          getVerifySubjectAltNameBytes(int index) {
        return verifySubjectAltName_.getByteString(index);
      }
      /**
       * <pre>
       * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
       * Subject Alternative Name of the presented certificate matches one of the specified values.
       * .. attention::
       *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
       *   therefore this option must be used together with :ref:`trusted_ca
       *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
       * </pre>
       *
       * <code>repeated string verify_subject_alt_name = 4;</code>
       */
      public Builder setVerifySubjectAltName(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureVerifySubjectAltNameIsMutable();
        verifySubjectAltName_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
       * Subject Alternative Name of the presented certificate matches one of the specified values.
       * .. attention::
       *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
       *   therefore this option must be used together with :ref:`trusted_ca
       *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
       * </pre>
       *
       * <code>repeated string verify_subject_alt_name = 4;</code>
       */
      public Builder addVerifySubjectAltName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureVerifySubjectAltNameIsMutable();
        verifySubjectAltName_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
       * Subject Alternative Name of the presented certificate matches one of the specified values.
       * .. attention::
       *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
       *   therefore this option must be used together with :ref:`trusted_ca
       *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
       * </pre>
       *
       * <code>repeated string verify_subject_alt_name = 4;</code>
       */
      public Builder addAllVerifySubjectAltName(
          java.lang.Iterable<java.lang.String> values) {
        ensureVerifySubjectAltNameIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, verifySubjectAltName_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
       * Subject Alternative Name of the presented certificate matches one of the specified values.
       * .. attention::
       *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
       *   therefore this option must be used together with :ref:`trusted_ca
       *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
       * </pre>
       *
       * <code>repeated string verify_subject_alt_name = 4;</code>
       */
      public Builder clearVerifySubjectAltName() {
        verifySubjectAltName_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * An optional list of Subject Alternative Names. If specified, Envoy will verify that the
       * Subject Alternative Name of the presented certificate matches one of the specified values.
       * .. attention::
       *   Subject Alternative Names are easily spoofable and verifying only them is insecure,
       *   therefore this option must be used together with :ref:`trusted_ca
       *   &lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca&gt;`.
       * </pre>
       *
       * <code>repeated string verify_subject_alt_name = 4;</code>
       */
      public Builder addVerifySubjectAltNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureVerifySubjectAltNameIsMutable();
        verifySubjectAltName_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.BoolValue requireOcspStaple_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> requireOcspStapleBuilder_;
      /**
       * <pre>
       * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
       */
      public boolean hasRequireOcspStaple() {
        return requireOcspStapleBuilder_ != null || requireOcspStaple_ != null;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
       */
      public com.google.protobuf.BoolValue getRequireOcspStaple() {
        if (requireOcspStapleBuilder_ == null) {
          return requireOcspStaple_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : requireOcspStaple_;
        } else {
          return requireOcspStapleBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
       */
      public Builder setRequireOcspStaple(com.google.protobuf.BoolValue value) {
        if (requireOcspStapleBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          requireOcspStaple_ = value;
          onChanged();
        } else {
          requireOcspStapleBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
       */
      public Builder setRequireOcspStaple(
          com.google.protobuf.BoolValue.Builder builderForValue) {
        if (requireOcspStapleBuilder_ == null) {
          requireOcspStaple_ = builderForValue.build();
          onChanged();
        } else {
          requireOcspStapleBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
       */
      public Builder mergeRequireOcspStaple(com.google.protobuf.BoolValue value) {
        if (requireOcspStapleBuilder_ == null) {
          if (requireOcspStaple_ != null) {
            requireOcspStaple_ =
              com.google.protobuf.BoolValue.newBuilder(requireOcspStaple_).mergeFrom(value).buildPartial();
          } else {
            requireOcspStaple_ = value;
          }
          onChanged();
        } else {
          requireOcspStapleBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
       */
      public Builder clearRequireOcspStaple() {
        if (requireOcspStapleBuilder_ == null) {
          requireOcspStaple_ = null;
          onChanged();
        } else {
          requireOcspStaple_ = null;
          requireOcspStapleBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
       */
      public com.google.protobuf.BoolValue.Builder getRequireOcspStapleBuilder() {
        
        onChanged();
        return getRequireOcspStapleFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
       */
      public com.google.protobuf.BoolValueOrBuilder getRequireOcspStapleOrBuilder() {
        if (requireOcspStapleBuilder_ != null) {
          return requireOcspStapleBuilder_.getMessageOrBuilder();
        } else {
          return requireOcspStaple_ == null ?
              com.google.protobuf.BoolValue.getDefaultInstance() : requireOcspStaple_;
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present a signed time-stamped OCSP response.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_ocsp_staple = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
          getRequireOcspStapleFieldBuilder() {
        if (requireOcspStapleBuilder_ == null) {
          requireOcspStapleBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                  getRequireOcspStaple(),
                  getParentForChildren(),
                  isClean());
          requireOcspStaple_ = null;
        }
        return requireOcspStapleBuilder_;
      }

      private com.google.protobuf.BoolValue requireSignedCertificateTimestamp_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> requireSignedCertificateTimestampBuilder_;
      /**
       * <pre>
       * [#not-implemented-hide:] Must present signed certificate time-stamp.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
       */
      public boolean hasRequireSignedCertificateTimestamp() {
        return requireSignedCertificateTimestampBuilder_ != null || requireSignedCertificateTimestamp_ != null;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present signed certificate time-stamp.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
       */
      public com.google.protobuf.BoolValue getRequireSignedCertificateTimestamp() {
        if (requireSignedCertificateTimestampBuilder_ == null) {
          return requireSignedCertificateTimestamp_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : requireSignedCertificateTimestamp_;
        } else {
          return requireSignedCertificateTimestampBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present signed certificate time-stamp.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
       */
      public Builder setRequireSignedCertificateTimestamp(com.google.protobuf.BoolValue value) {
        if (requireSignedCertificateTimestampBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          requireSignedCertificateTimestamp_ = value;
          onChanged();
        } else {
          requireSignedCertificateTimestampBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present signed certificate time-stamp.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
       */
      public Builder setRequireSignedCertificateTimestamp(
          com.google.protobuf.BoolValue.Builder builderForValue) {
        if (requireSignedCertificateTimestampBuilder_ == null) {
          requireSignedCertificateTimestamp_ = builderForValue.build();
          onChanged();
        } else {
          requireSignedCertificateTimestampBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present signed certificate time-stamp.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
       */
      public Builder mergeRequireSignedCertificateTimestamp(com.google.protobuf.BoolValue value) {
        if (requireSignedCertificateTimestampBuilder_ == null) {
          if (requireSignedCertificateTimestamp_ != null) {
            requireSignedCertificateTimestamp_ =
              com.google.protobuf.BoolValue.newBuilder(requireSignedCertificateTimestamp_).mergeFrom(value).buildPartial();
          } else {
            requireSignedCertificateTimestamp_ = value;
          }
          onChanged();
        } else {
          requireSignedCertificateTimestampBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present signed certificate time-stamp.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
       */
      public Builder clearRequireSignedCertificateTimestamp() {
        if (requireSignedCertificateTimestampBuilder_ == null) {
          requireSignedCertificateTimestamp_ = null;
          onChanged();
        } else {
          requireSignedCertificateTimestamp_ = null;
          requireSignedCertificateTimestampBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present signed certificate time-stamp.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
       */
      public com.google.protobuf.BoolValue.Builder getRequireSignedCertificateTimestampBuilder() {
        
        onChanged();
        return getRequireSignedCertificateTimestampFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present signed certificate time-stamp.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
       */
      public com.google.protobuf.BoolValueOrBuilder getRequireSignedCertificateTimestampOrBuilder() {
        if (requireSignedCertificateTimestampBuilder_ != null) {
          return requireSignedCertificateTimestampBuilder_.getMessageOrBuilder();
        } else {
          return requireSignedCertificateTimestamp_ == null ?
              com.google.protobuf.BoolValue.getDefaultInstance() : requireSignedCertificateTimestamp_;
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:] Must present signed certificate time-stamp.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_signed_certificate_timestamp = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
          getRequireSignedCertificateTimestampFieldBuilder() {
        if (requireSignedCertificateTimestampBuilder_ == null) {
          requireSignedCertificateTimestampBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                  getRequireSignedCertificateTimestamp(),
                  getParentForChildren(),
                  isClean());
          requireSignedCertificateTimestamp_ = null;
        }
        return requireSignedCertificateTimestampBuilder_;
      }

      private envoy.api.v2.core.Base.DataSource crl_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> crlBuilder_;
      /**
       * <pre>
       * An optional `certificate revocation list
       * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
       * (in PEM format). If specified, Envoy will verify that the presented peer
       * certificate has not been revoked by this CRL. If this DataSource contains
       * multiple CRLs, all of them will be used.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
       */
      public boolean hasCrl() {
        return crlBuilder_ != null || crl_ != null;
      }
      /**
       * <pre>
       * An optional `certificate revocation list
       * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
       * (in PEM format). If specified, Envoy will verify that the presented peer
       * certificate has not been revoked by this CRL. If this DataSource contains
       * multiple CRLs, all of them will be used.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
       */
      public envoy.api.v2.core.Base.DataSource getCrl() {
        if (crlBuilder_ == null) {
          return crl_ == null ? envoy.api.v2.core.Base.DataSource.getDefaultInstance() : crl_;
        } else {
          return crlBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * An optional `certificate revocation list
       * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
       * (in PEM format). If specified, Envoy will verify that the presented peer
       * certificate has not been revoked by this CRL. If this DataSource contains
       * multiple CRLs, all of them will be used.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
       */
      public Builder setCrl(envoy.api.v2.core.Base.DataSource value) {
        if (crlBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          crl_ = value;
          onChanged();
        } else {
          crlBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * An optional `certificate revocation list
       * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
       * (in PEM format). If specified, Envoy will verify that the presented peer
       * certificate has not been revoked by this CRL. If this DataSource contains
       * multiple CRLs, all of them will be used.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
       */
      public Builder setCrl(
          envoy.api.v2.core.Base.DataSource.Builder builderForValue) {
        if (crlBuilder_ == null) {
          crl_ = builderForValue.build();
          onChanged();
        } else {
          crlBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * An optional `certificate revocation list
       * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
       * (in PEM format). If specified, Envoy will verify that the presented peer
       * certificate has not been revoked by this CRL. If this DataSource contains
       * multiple CRLs, all of them will be used.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
       */
      public Builder mergeCrl(envoy.api.v2.core.Base.DataSource value) {
        if (crlBuilder_ == null) {
          if (crl_ != null) {
            crl_ =
              envoy.api.v2.core.Base.DataSource.newBuilder(crl_).mergeFrom(value).buildPartial();
          } else {
            crl_ = value;
          }
          onChanged();
        } else {
          crlBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * An optional `certificate revocation list
       * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
       * (in PEM format). If specified, Envoy will verify that the presented peer
       * certificate has not been revoked by this CRL. If this DataSource contains
       * multiple CRLs, all of them will be used.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
       */
      public Builder clearCrl() {
        if (crlBuilder_ == null) {
          crl_ = null;
          onChanged();
        } else {
          crl_ = null;
          crlBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * An optional `certificate revocation list
       * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
       * (in PEM format). If specified, Envoy will verify that the presented peer
       * certificate has not been revoked by this CRL. If this DataSource contains
       * multiple CRLs, all of them will be used.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
       */
      public envoy.api.v2.core.Base.DataSource.Builder getCrlBuilder() {
        
        onChanged();
        return getCrlFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * An optional `certificate revocation list
       * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
       * (in PEM format). If specified, Envoy will verify that the presented peer
       * certificate has not been revoked by this CRL. If this DataSource contains
       * multiple CRLs, all of them will be used.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
       */
      public envoy.api.v2.core.Base.DataSourceOrBuilder getCrlOrBuilder() {
        if (crlBuilder_ != null) {
          return crlBuilder_.getMessageOrBuilder();
        } else {
          return crl_ == null ?
              envoy.api.v2.core.Base.DataSource.getDefaultInstance() : crl_;
        }
      }
      /**
       * <pre>
       * An optional `certificate revocation list
       * &lt;http://https://en.wikipedia.org/wiki/Certificate_revocation_list&gt;`_
       * (in PEM format). If specified, Envoy will verify that the presented peer
       * certificate has not been revoked by this CRL. If this DataSource contains
       * multiple CRLs, all of them will be used.
       * </pre>
       *
       * <code>.envoy.api.v2.core.DataSource crl = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder> 
          getCrlFieldBuilder() {
        if (crlBuilder_ == null) {
          crlBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.core.Base.DataSource, envoy.api.v2.core.Base.DataSource.Builder, envoy.api.v2.core.Base.DataSourceOrBuilder>(
                  getCrl(),
                  getParentForChildren(),
                  isClean());
          crl_ = null;
        }
        return crlBuilder_;
      }

      private boolean allowExpiredCertificate_ ;
      /**
       * <pre>
       * If specified, Envoy will not reject expired certificates.
       * </pre>
       *
       * <code>bool allow_expired_certificate = 8;</code>
       */
      public boolean getAllowExpiredCertificate() {
        return allowExpiredCertificate_;
      }
      /**
       * <pre>
       * If specified, Envoy will not reject expired certificates.
       * </pre>
       *
       * <code>bool allow_expired_certificate = 8;</code>
       */
      public Builder setAllowExpiredCertificate(boolean value) {
        
        allowExpiredCertificate_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If specified, Envoy will not reject expired certificates.
       * </pre>
       *
       * <code>bool allow_expired_certificate = 8;</code>
       */
      public Builder clearAllowExpiredCertificate() {
        
        allowExpiredCertificate_ = false;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.auth.CertificateValidationContext)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.auth.CertificateValidationContext)
    private static final envoy.api.v2.auth.Cert.CertificateValidationContext DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new envoy.api.v2.auth.Cert.CertificateValidationContext();
    }

    public static envoy.api.v2.auth.Cert.CertificateValidationContext getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CertificateValidationContext>
        PARSER = new com.google.protobuf.AbstractParser<CertificateValidationContext>() {
      public CertificateValidationContext parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CertificateValidationContext(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CertificateValidationContext> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CertificateValidationContext> getParserForType() {
      return PARSER;
    }

    public envoy.api.v2.auth.Cert.CertificateValidationContext getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CommonTlsContextOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.auth.CommonTlsContext)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * TLS protocol versions, cipher suites etc.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
     */
    boolean hasTlsParams();
    /**
     * <pre>
     * TLS protocol versions, cipher suites etc.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
     */
    envoy.api.v2.auth.Cert.TlsParameters getTlsParams();
    /**
     * <pre>
     * TLS protocol versions, cipher suites etc.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
     */
    envoy.api.v2.auth.Cert.TlsParametersOrBuilder getTlsParamsOrBuilder();

    /**
     * <pre>
     * Multiple TLS certificates can be associated with the same context.
     * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
     * Only a single TLS certificate is supported in client contexts. In server contexts, the first
     * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
     * used for clients that support ECDSA.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
     */
    java.util.List<envoy.api.v2.auth.Cert.TlsCertificate> 
        getTlsCertificatesList();
    /**
     * <pre>
     * Multiple TLS certificates can be associated with the same context.
     * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
     * Only a single TLS certificate is supported in client contexts. In server contexts, the first
     * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
     * used for clients that support ECDSA.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
     */
    envoy.api.v2.auth.Cert.TlsCertificate getTlsCertificates(int index);
    /**
     * <pre>
     * Multiple TLS certificates can be associated with the same context.
     * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
     * Only a single TLS certificate is supported in client contexts. In server contexts, the first
     * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
     * used for clients that support ECDSA.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
     */
    int getTlsCertificatesCount();
    /**
     * <pre>
     * Multiple TLS certificates can be associated with the same context.
     * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
     * Only a single TLS certificate is supported in client contexts. In server contexts, the first
     * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
     * used for clients that support ECDSA.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
     */
    java.util.List<? extends envoy.api.v2.auth.Cert.TlsCertificateOrBuilder> 
        getTlsCertificatesOrBuilderList();
    /**
     * <pre>
     * Multiple TLS certificates can be associated with the same context.
     * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
     * Only a single TLS certificate is supported in client contexts. In server contexts, the first
     * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
     * used for clients that support ECDSA.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
     */
    envoy.api.v2.auth.Cert.TlsCertificateOrBuilder getTlsCertificatesOrBuilder(
        int index);

    /**
     * <pre>
     * Configs for fetching TLS certificates via SDS API.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
     */
    java.util.List<envoy.api.v2.auth.Cert.SdsSecretConfig> 
        getTlsCertificateSdsSecretConfigsList();
    /**
     * <pre>
     * Configs for fetching TLS certificates via SDS API.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
     */
    envoy.api.v2.auth.Cert.SdsSecretConfig getTlsCertificateSdsSecretConfigs(int index);
    /**
     * <pre>
     * Configs for fetching TLS certificates via SDS API.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
     */
    int getTlsCertificateSdsSecretConfigsCount();
    /**
     * <pre>
     * Configs for fetching TLS certificates via SDS API.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
     */
    java.util.List<? extends envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder> 
        getTlsCertificateSdsSecretConfigsOrBuilderList();
    /**
     * <pre>
     * Configs for fetching TLS certificates via SDS API.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
     */
    envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder getTlsCertificateSdsSecretConfigsOrBuilder(
        int index);

    /**
     * <pre>
     * How to validate peer certificates.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
     */
    boolean hasValidationContext();
    /**
     * <pre>
     * How to validate peer certificates.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
     */
    envoy.api.v2.auth.Cert.CertificateValidationContext getValidationContext();
    /**
     * <pre>
     * How to validate peer certificates.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
     */
    envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder getValidationContextOrBuilder();

    /**
     * <pre>
     * Config for fetching validation context via SDS API.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
     */
    boolean hasValidationContextSdsSecretConfig();
    /**
     * <pre>
     * Config for fetching validation context via SDS API.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
     */
    envoy.api.v2.auth.Cert.SdsSecretConfig getValidationContextSdsSecretConfig();
    /**
     * <pre>
     * Config for fetching validation context via SDS API.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
     */
    envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder getValidationContextSdsSecretConfigOrBuilder();

    /**
     * <pre>
     * Combined certificate validation context holds a default CertificateValidationContext
     * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
     * and default CertificateValidationContext are merged into a new CertificateValidationContext
     * for validation. This merge is done by Message::MergeFrom(), so dynamic
     * CertificateValidationContext overwrites singular fields in default
     * CertificateValidationContext, and concatenates repeated fields to default
     * CertificateValidationContext, and logical OR is applied to boolean fields.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
     */
    boolean hasCombinedValidationContext();
    /**
     * <pre>
     * Combined certificate validation context holds a default CertificateValidationContext
     * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
     * and default CertificateValidationContext are merged into a new CertificateValidationContext
     * for validation. This merge is done by Message::MergeFrom(), so dynamic
     * CertificateValidationContext overwrites singular fields in default
     * CertificateValidationContext, and concatenates repeated fields to default
     * CertificateValidationContext, and logical OR is applied to boolean fields.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
     */
    envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext getCombinedValidationContext();
    /**
     * <pre>
     * Combined certificate validation context holds a default CertificateValidationContext
     * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
     * and default CertificateValidationContext are merged into a new CertificateValidationContext
     * for validation. This merge is done by Message::MergeFrom(), so dynamic
     * CertificateValidationContext overwrites singular fields in default
     * CertificateValidationContext, and concatenates repeated fields to default
     * CertificateValidationContext, and logical OR is applied to boolean fields.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
     */
    envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContextOrBuilder getCombinedValidationContextOrBuilder();

    /**
     * <pre>
     * Supplies the list of ALPN protocols that the listener should expose. In
     * practice this is likely to be set to one of two values (see the
     * :ref:`codec_type
     * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
     * parameter in the HTTP connection manager for more information):
     * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
     * * "http/1.1" If the listener is only going to support HTTP/1.1.
     * There is no default for this parameter. If empty, Envoy will not expose ALPN.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 4;</code>
     */
    java.util.List<java.lang.String>
        getAlpnProtocolsList();
    /**
     * <pre>
     * Supplies the list of ALPN protocols that the listener should expose. In
     * practice this is likely to be set to one of two values (see the
     * :ref:`codec_type
     * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
     * parameter in the HTTP connection manager for more information):
     * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
     * * "http/1.1" If the listener is only going to support HTTP/1.1.
     * There is no default for this parameter. If empty, Envoy will not expose ALPN.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 4;</code>
     */
    int getAlpnProtocolsCount();
    /**
     * <pre>
     * Supplies the list of ALPN protocols that the listener should expose. In
     * practice this is likely to be set to one of two values (see the
     * :ref:`codec_type
     * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
     * parameter in the HTTP connection manager for more information):
     * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
     * * "http/1.1" If the listener is only going to support HTTP/1.1.
     * There is no default for this parameter. If empty, Envoy will not expose ALPN.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 4;</code>
     */
    java.lang.String getAlpnProtocols(int index);
    /**
     * <pre>
     * Supplies the list of ALPN protocols that the listener should expose. In
     * practice this is likely to be set to one of two values (see the
     * :ref:`codec_type
     * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
     * parameter in the HTTP connection manager for more information):
     * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
     * * "http/1.1" If the listener is only going to support HTTP/1.1.
     * There is no default for this parameter. If empty, Envoy will not expose ALPN.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 4;</code>
     */
    com.google.protobuf.ByteString
        getAlpnProtocolsBytes(int index);

    public envoy.api.v2.auth.Cert.CommonTlsContext.ValidationContextTypeCase getValidationContextTypeCase();
  }
  /**
   * <pre>
   * TLS context shared by both client and server TLS contexts.
   * </pre>
   *
   * Protobuf type {@code envoy.api.v2.auth.CommonTlsContext}
   */
  public  static final class CommonTlsContext extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.auth.CommonTlsContext)
      CommonTlsContextOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CommonTlsContext.newBuilder() to construct.
    private CommonTlsContext(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CommonTlsContext() {
      tlsCertificates_ = java.util.Collections.emptyList();
      tlsCertificateSdsSecretConfigs_ = java.util.Collections.emptyList();
      alpnProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private CommonTlsContext(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              envoy.api.v2.auth.Cert.TlsParameters.Builder subBuilder = null;
              if (tlsParams_ != null) {
                subBuilder = tlsParams_.toBuilder();
              }
              tlsParams_ = input.readMessage(envoy.api.v2.auth.Cert.TlsParameters.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(tlsParams_);
                tlsParams_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                tlsCertificates_ = new java.util.ArrayList<envoy.api.v2.auth.Cert.TlsCertificate>();
                mutable_bitField0_ |= 0x00000002;
              }
              tlsCertificates_.add(
                  input.readMessage(envoy.api.v2.auth.Cert.TlsCertificate.parser(), extensionRegistry));
              break;
            }
            case 26: {
              envoy.api.v2.auth.Cert.CertificateValidationContext.Builder subBuilder = null;
              if (validationContextTypeCase_ == 3) {
                subBuilder = ((envoy.api.v2.auth.Cert.CertificateValidationContext) validationContextType_).toBuilder();
              }
              validationContextType_ =
                  input.readMessage(envoy.api.v2.auth.Cert.CertificateValidationContext.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((envoy.api.v2.auth.Cert.CertificateValidationContext) validationContextType_);
                validationContextType_ = subBuilder.buildPartial();
              }
              validationContextTypeCase_ = 3;
              break;
            }
            case 34: {
              java.lang.String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
                alpnProtocols_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000040;
              }
              alpnProtocols_.add(s);
              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                tlsCertificateSdsSecretConfigs_ = new java.util.ArrayList<envoy.api.v2.auth.Cert.SdsSecretConfig>();
                mutable_bitField0_ |= 0x00000004;
              }
              tlsCertificateSdsSecretConfigs_.add(
                  input.readMessage(envoy.api.v2.auth.Cert.SdsSecretConfig.parser(), extensionRegistry));
              break;
            }
            case 58: {
              envoy.api.v2.auth.Cert.SdsSecretConfig.Builder subBuilder = null;
              if (validationContextTypeCase_ == 7) {
                subBuilder = ((envoy.api.v2.auth.Cert.SdsSecretConfig) validationContextType_).toBuilder();
              }
              validationContextType_ =
                  input.readMessage(envoy.api.v2.auth.Cert.SdsSecretConfig.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((envoy.api.v2.auth.Cert.SdsSecretConfig) validationContextType_);
                validationContextType_ = subBuilder.buildPartial();
              }
              validationContextTypeCase_ = 7;
              break;
            }
            case 66: {
              envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.Builder subBuilder = null;
              if (validationContextTypeCase_ == 8) {
                subBuilder = ((envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) validationContextType_).toBuilder();
              }
              validationContextType_ =
                  input.readMessage(envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) validationContextType_);
                validationContextType_ = subBuilder.buildPartial();
              }
              validationContextTypeCase_ = 8;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          tlsCertificates_ = java.util.Collections.unmodifiableList(tlsCertificates_);
        }
        if (((mutable_bitField0_ & 0x00000040) == 0x00000040)) {
          alpnProtocols_ = alpnProtocols_.getUnmodifiableView();
        }
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          tlsCertificateSdsSecretConfigs_ = java.util.Collections.unmodifiableList(tlsCertificateSdsSecretConfigs_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CommonTlsContext_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CommonTlsContext_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              envoy.api.v2.auth.Cert.CommonTlsContext.class, envoy.api.v2.auth.Cert.CommonTlsContext.Builder.class);
    }

    public interface CombinedCertificateValidationContextOrBuilder extends
        // @@protoc_insertion_point(interface_extends:envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
       */
      boolean hasDefaultValidationContext();
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
       */
      envoy.api.v2.auth.Cert.CertificateValidationContext getDefaultValidationContext();
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
       */
      envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder getDefaultValidationContextOrBuilder();

      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
       */
      boolean hasValidationContextSdsSecretConfig();
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
       */
      envoy.api.v2.auth.Cert.SdsSecretConfig getValidationContextSdsSecretConfig();
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
       */
      envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder getValidationContextSdsSecretConfigOrBuilder();
    }
    /**
     * Protobuf type {@code envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext}
     */
    public  static final class CombinedCertificateValidationContext extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext)
        CombinedCertificateValidationContextOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use CombinedCertificateValidationContext.newBuilder() to construct.
      private CombinedCertificateValidationContext(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private CombinedCertificateValidationContext() {
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      private CombinedCertificateValidationContext(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        this();
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        int mutable_bitField0_ = 0;
        com.google.protobuf.UnknownFieldSet.Builder unknownFields =
            com.google.protobuf.UnknownFieldSet.newBuilder();
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownFieldProto3(
                    input, unknownFields, extensionRegistry, tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                envoy.api.v2.auth.Cert.CertificateValidationContext.Builder subBuilder = null;
                if (defaultValidationContext_ != null) {
                  subBuilder = defaultValidationContext_.toBuilder();
                }
                defaultValidationContext_ = input.readMessage(envoy.api.v2.auth.Cert.CertificateValidationContext.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(defaultValidationContext_);
                  defaultValidationContext_ = subBuilder.buildPartial();
                }

                break;
              }
              case 18: {
                envoy.api.v2.auth.Cert.SdsSecretConfig.Builder subBuilder = null;
                if (validationContextSdsSecretConfig_ != null) {
                  subBuilder = validationContextSdsSecretConfig_.toBuilder();
                }
                validationContextSdsSecretConfig_ = input.readMessage(envoy.api.v2.auth.Cert.SdsSecretConfig.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(validationContextSdsSecretConfig_);
                  validationContextSdsSecretConfig_ = subBuilder.buildPartial();
                }

                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(this);
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(
              e).setUnfinishedMessage(this);
        } finally {
          this.unknownFields = unknownFields.build();
          makeExtensionsImmutable();
        }
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CommonTlsContext_CombinedCertificateValidationContext_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CommonTlsContext_CombinedCertificateValidationContext_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.class, envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.Builder.class);
      }

      public static final int DEFAULT_VALIDATION_CONTEXT_FIELD_NUMBER = 1;
      private envoy.api.v2.auth.Cert.CertificateValidationContext defaultValidationContext_;
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
       */
      public boolean hasDefaultValidationContext() {
        return defaultValidationContext_ != null;
      }
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
       */
      public envoy.api.v2.auth.Cert.CertificateValidationContext getDefaultValidationContext() {
        return defaultValidationContext_ == null ? envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance() : defaultValidationContext_;
      }
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
       */
      public envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder getDefaultValidationContextOrBuilder() {
        return getDefaultValidationContext();
      }

      public static final int VALIDATION_CONTEXT_SDS_SECRET_CONFIG_FIELD_NUMBER = 2;
      private envoy.api.v2.auth.Cert.SdsSecretConfig validationContextSdsSecretConfig_;
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
       */
      public boolean hasValidationContextSdsSecretConfig() {
        return validationContextSdsSecretConfig_ != null;
      }
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfig getValidationContextSdsSecretConfig() {
        return validationContextSdsSecretConfig_ == null ? envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance() : validationContextSdsSecretConfig_;
      }
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder getValidationContextSdsSecretConfigOrBuilder() {
        return getValidationContextSdsSecretConfig();
      }

      private byte memoizedIsInitialized = -1;
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (defaultValidationContext_ != null) {
          output.writeMessage(1, getDefaultValidationContext());
        }
        if (validationContextSdsSecretConfig_ != null) {
          output.writeMessage(2, getValidationContextSdsSecretConfig());
        }
        unknownFields.writeTo(output);
      }

      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (defaultValidationContext_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getDefaultValidationContext());
        }
        if (validationContextSdsSecretConfig_ != null) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, getValidationContextSdsSecretConfig());
        }
        size += unknownFields.getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext)) {
          return super.equals(obj);
        }
        envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext other = (envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) obj;

        boolean result = true;
        result = result && (hasDefaultValidationContext() == other.hasDefaultValidationContext());
        if (hasDefaultValidationContext()) {
          result = result && getDefaultValidationContext()
              .equals(other.getDefaultValidationContext());
        }
        result = result && (hasValidationContextSdsSecretConfig() == other.hasValidationContextSdsSecretConfig());
        if (hasValidationContextSdsSecretConfig()) {
          result = result && getValidationContextSdsSecretConfig()
              .equals(other.getValidationContextSdsSecretConfig());
        }
        result = result && unknownFields.equals(other.unknownFields);
        return result;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasDefaultValidationContext()) {
          hash = (37 * hash) + DEFAULT_VALIDATION_CONTEXT_FIELD_NUMBER;
          hash = (53 * hash) + getDefaultValidationContext().hashCode();
        }
        if (hasValidationContextSdsSecretConfig()) {
          hash = (37 * hash) + VALIDATION_CONTEXT_SDS_SECRET_CONFIG_FIELD_NUMBER;
          hash = (53 * hash) + getValidationContextSdsSecretConfig().hashCode();
        }
        hash = (29 * hash) + unknownFields.hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext)
          envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContextOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CommonTlsContext_CombinedCertificateValidationContext_descriptor;
        }

        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CommonTlsContext_CombinedCertificateValidationContext_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.class, envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.Builder.class);
        }

        // Construct using envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
          }
        }
        public Builder clear() {
          super.clear();
          if (defaultValidationContextBuilder_ == null) {
            defaultValidationContext_ = null;
          } else {
            defaultValidationContext_ = null;
            defaultValidationContextBuilder_ = null;
          }
          if (validationContextSdsSecretConfigBuilder_ == null) {
            validationContextSdsSecretConfig_ = null;
          } else {
            validationContextSdsSecretConfig_ = null;
            validationContextSdsSecretConfigBuilder_ = null;
          }
          return this;
        }

        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CommonTlsContext_CombinedCertificateValidationContext_descriptor;
        }

        public envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext getDefaultInstanceForType() {
          return envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.getDefaultInstance();
        }

        public envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext build() {
          envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        public envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext buildPartial() {
          envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext result = new envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext(this);
          if (defaultValidationContextBuilder_ == null) {
            result.defaultValidationContext_ = defaultValidationContext_;
          } else {
            result.defaultValidationContext_ = defaultValidationContextBuilder_.build();
          }
          if (validationContextSdsSecretConfigBuilder_ == null) {
            result.validationContextSdsSecretConfig_ = validationContextSdsSecretConfig_;
          } else {
            result.validationContextSdsSecretConfig_ = validationContextSdsSecretConfigBuilder_.build();
          }
          onBuilt();
          return result;
        }

        public Builder clone() {
          return (Builder) super.clone();
        }
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.setField(field, value);
        }
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return (Builder) super.clearField(field);
        }
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return (Builder) super.clearOneof(oneof);
        }
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return (Builder) super.setRepeatedField(field, index, value);
        }
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return (Builder) super.addRepeatedField(field, value);
        }
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) {
            return mergeFrom((envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext other) {
          if (other == envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.getDefaultInstance()) return this;
          if (other.hasDefaultValidationContext()) {
            mergeDefaultValidationContext(other.getDefaultValidationContext());
          }
          if (other.hasValidationContextSdsSecretConfig()) {
            mergeValidationContextSdsSecretConfig(other.getValidationContextSdsSecretConfig());
          }
          this.mergeUnknownFields(other.unknownFields);
          onChanged();
          return this;
        }

        public final boolean isInitialized() {
          return true;
        }

        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext parsedMessage = null;
          try {
            parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            parsedMessage = (envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) e.getUnfinishedMessage();
            throw e.unwrapIOException();
          } finally {
            if (parsedMessage != null) {
              mergeFrom(parsedMessage);
            }
          }
          return this;
        }

        private envoy.api.v2.auth.Cert.CertificateValidationContext defaultValidationContext_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            envoy.api.v2.auth.Cert.CertificateValidationContext, envoy.api.v2.auth.Cert.CertificateValidationContext.Builder, envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder> defaultValidationContextBuilder_;
        /**
         * <pre>
         * How to validate peer certificates.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
         */
        public boolean hasDefaultValidationContext() {
          return defaultValidationContextBuilder_ != null || defaultValidationContext_ != null;
        }
        /**
         * <pre>
         * How to validate peer certificates.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
         */
        public envoy.api.v2.auth.Cert.CertificateValidationContext getDefaultValidationContext() {
          if (defaultValidationContextBuilder_ == null) {
            return defaultValidationContext_ == null ? envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance() : defaultValidationContext_;
          } else {
            return defaultValidationContextBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * How to validate peer certificates.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
         */
        public Builder setDefaultValidationContext(envoy.api.v2.auth.Cert.CertificateValidationContext value) {
          if (defaultValidationContextBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            defaultValidationContext_ = value;
            onChanged();
          } else {
            defaultValidationContextBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <pre>
         * How to validate peer certificates.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
         */
        public Builder setDefaultValidationContext(
            envoy.api.v2.auth.Cert.CertificateValidationContext.Builder builderForValue) {
          if (defaultValidationContextBuilder_ == null) {
            defaultValidationContext_ = builderForValue.build();
            onChanged();
          } else {
            defaultValidationContextBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <pre>
         * How to validate peer certificates.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
         */
        public Builder mergeDefaultValidationContext(envoy.api.v2.auth.Cert.CertificateValidationContext value) {
          if (defaultValidationContextBuilder_ == null) {
            if (defaultValidationContext_ != null) {
              defaultValidationContext_ =
                envoy.api.v2.auth.Cert.CertificateValidationContext.newBuilder(defaultValidationContext_).mergeFrom(value).buildPartial();
            } else {
              defaultValidationContext_ = value;
            }
            onChanged();
          } else {
            defaultValidationContextBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <pre>
         * How to validate peer certificates.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
         */
        public Builder clearDefaultValidationContext() {
          if (defaultValidationContextBuilder_ == null) {
            defaultValidationContext_ = null;
            onChanged();
          } else {
            defaultValidationContext_ = null;
            defaultValidationContextBuilder_ = null;
          }

          return this;
        }
        /**
         * <pre>
         * How to validate peer certificates.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
         */
        public envoy.api.v2.auth.Cert.CertificateValidationContext.Builder getDefaultValidationContextBuilder() {
          
          onChanged();
          return getDefaultValidationContextFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * How to validate peer certificates.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
         */
        public envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder getDefaultValidationContextOrBuilder() {
          if (defaultValidationContextBuilder_ != null) {
            return defaultValidationContextBuilder_.getMessageOrBuilder();
          } else {
            return defaultValidationContext_ == null ?
                envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance() : defaultValidationContext_;
          }
        }
        /**
         * <pre>
         * How to validate peer certificates.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.CertificateValidationContext default_validation_context = 1 [(.validate.rules) = { ... }</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            envoy.api.v2.auth.Cert.CertificateValidationContext, envoy.api.v2.auth.Cert.CertificateValidationContext.Builder, envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder> 
            getDefaultValidationContextFieldBuilder() {
          if (defaultValidationContextBuilder_ == null) {
            defaultValidationContextBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                envoy.api.v2.auth.Cert.CertificateValidationContext, envoy.api.v2.auth.Cert.CertificateValidationContext.Builder, envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder>(
                    getDefaultValidationContext(),
                    getParentForChildren(),
                    isClean());
            defaultValidationContext_ = null;
          }
          return defaultValidationContextBuilder_;
        }

        private envoy.api.v2.auth.Cert.SdsSecretConfig validationContextSdsSecretConfig_ = null;
        private com.google.protobuf.SingleFieldBuilderV3<
            envoy.api.v2.auth.Cert.SdsSecretConfig, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder, envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder> validationContextSdsSecretConfigBuilder_;
        /**
         * <pre>
         * Config for fetching validation context via SDS API.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
         */
        public boolean hasValidationContextSdsSecretConfig() {
          return validationContextSdsSecretConfigBuilder_ != null || validationContextSdsSecretConfig_ != null;
        }
        /**
         * <pre>
         * Config for fetching validation context via SDS API.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
         */
        public envoy.api.v2.auth.Cert.SdsSecretConfig getValidationContextSdsSecretConfig() {
          if (validationContextSdsSecretConfigBuilder_ == null) {
            return validationContextSdsSecretConfig_ == null ? envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance() : validationContextSdsSecretConfig_;
          } else {
            return validationContextSdsSecretConfigBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Config for fetching validation context via SDS API.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
         */
        public Builder setValidationContextSdsSecretConfig(envoy.api.v2.auth.Cert.SdsSecretConfig value) {
          if (validationContextSdsSecretConfigBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            validationContextSdsSecretConfig_ = value;
            onChanged();
          } else {
            validationContextSdsSecretConfigBuilder_.setMessage(value);
          }

          return this;
        }
        /**
         * <pre>
         * Config for fetching validation context via SDS API.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
         */
        public Builder setValidationContextSdsSecretConfig(
            envoy.api.v2.auth.Cert.SdsSecretConfig.Builder builderForValue) {
          if (validationContextSdsSecretConfigBuilder_ == null) {
            validationContextSdsSecretConfig_ = builderForValue.build();
            onChanged();
          } else {
            validationContextSdsSecretConfigBuilder_.setMessage(builderForValue.build());
          }

          return this;
        }
        /**
         * <pre>
         * Config for fetching validation context via SDS API.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
         */
        public Builder mergeValidationContextSdsSecretConfig(envoy.api.v2.auth.Cert.SdsSecretConfig value) {
          if (validationContextSdsSecretConfigBuilder_ == null) {
            if (validationContextSdsSecretConfig_ != null) {
              validationContextSdsSecretConfig_ =
                envoy.api.v2.auth.Cert.SdsSecretConfig.newBuilder(validationContextSdsSecretConfig_).mergeFrom(value).buildPartial();
            } else {
              validationContextSdsSecretConfig_ = value;
            }
            onChanged();
          } else {
            validationContextSdsSecretConfigBuilder_.mergeFrom(value);
          }

          return this;
        }
        /**
         * <pre>
         * Config for fetching validation context via SDS API.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
         */
        public Builder clearValidationContextSdsSecretConfig() {
          if (validationContextSdsSecretConfigBuilder_ == null) {
            validationContextSdsSecretConfig_ = null;
            onChanged();
          } else {
            validationContextSdsSecretConfig_ = null;
            validationContextSdsSecretConfigBuilder_ = null;
          }

          return this;
        }
        /**
         * <pre>
         * Config for fetching validation context via SDS API.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
         */
        public envoy.api.v2.auth.Cert.SdsSecretConfig.Builder getValidationContextSdsSecretConfigBuilder() {
          
          onChanged();
          return getValidationContextSdsSecretConfigFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Config for fetching validation context via SDS API.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
         */
        public envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder getValidationContextSdsSecretConfigOrBuilder() {
          if (validationContextSdsSecretConfigBuilder_ != null) {
            return validationContextSdsSecretConfigBuilder_.getMessageOrBuilder();
          } else {
            return validationContextSdsSecretConfig_ == null ?
                envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance() : validationContextSdsSecretConfig_;
          }
        }
        /**
         * <pre>
         * Config for fetching validation context via SDS API.
         * </pre>
         *
         * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 2 [(.validate.rules) = { ... }</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            envoy.api.v2.auth.Cert.SdsSecretConfig, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder, envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder> 
            getValidationContextSdsSecretConfigFieldBuilder() {
          if (validationContextSdsSecretConfigBuilder_ == null) {
            validationContextSdsSecretConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                envoy.api.v2.auth.Cert.SdsSecretConfig, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder, envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder>(
                    getValidationContextSdsSecretConfig(),
                    getParentForChildren(),
                    isClean());
            validationContextSdsSecretConfig_ = null;
          }
          return validationContextSdsSecretConfigBuilder_;
        }
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFieldsProto3(unknownFields);
        }

        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext)
      }

      // @@protoc_insertion_point(class_scope:envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext)
      private static final envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext();
      }

      public static envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<CombinedCertificateValidationContext>
          PARSER = new com.google.protobuf.AbstractParser<CombinedCertificateValidationContext>() {
        public CombinedCertificateValidationContext parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return new CombinedCertificateValidationContext(input, extensionRegistry);
        }
      };

      public static com.google.protobuf.Parser<CombinedCertificateValidationContext> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<CombinedCertificateValidationContext> getParserForType() {
        return PARSER;
      }

      public envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    private int validationContextTypeCase_ = 0;
    private java.lang.Object validationContextType_;
    public enum ValidationContextTypeCase
        implements com.google.protobuf.Internal.EnumLite {
      VALIDATION_CONTEXT(3),
      VALIDATION_CONTEXT_SDS_SECRET_CONFIG(7),
      COMBINED_VALIDATION_CONTEXT(8),
      VALIDATIONCONTEXTTYPE_NOT_SET(0);
      private final int value;
      private ValidationContextTypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ValidationContextTypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static ValidationContextTypeCase forNumber(int value) {
        switch (value) {
          case 3: return VALIDATION_CONTEXT;
          case 7: return VALIDATION_CONTEXT_SDS_SECRET_CONFIG;
          case 8: return COMBINED_VALIDATION_CONTEXT;
          case 0: return VALIDATIONCONTEXTTYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public ValidationContextTypeCase
    getValidationContextTypeCase() {
      return ValidationContextTypeCase.forNumber(
          validationContextTypeCase_);
    }

    public static final int TLS_PARAMS_FIELD_NUMBER = 1;
    private envoy.api.v2.auth.Cert.TlsParameters tlsParams_;
    /**
     * <pre>
     * TLS protocol versions, cipher suites etc.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
     */
    public boolean hasTlsParams() {
      return tlsParams_ != null;
    }
    /**
     * <pre>
     * TLS protocol versions, cipher suites etc.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
     */
    public envoy.api.v2.auth.Cert.TlsParameters getTlsParams() {
      return tlsParams_ == null ? envoy.api.v2.auth.Cert.TlsParameters.getDefaultInstance() : tlsParams_;
    }
    /**
     * <pre>
     * TLS protocol versions, cipher suites etc.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
     */
    public envoy.api.v2.auth.Cert.TlsParametersOrBuilder getTlsParamsOrBuilder() {
      return getTlsParams();
    }

    public static final int TLS_CERTIFICATES_FIELD_NUMBER = 2;
    private java.util.List<envoy.api.v2.auth.Cert.TlsCertificate> tlsCertificates_;
    /**
     * <pre>
     * Multiple TLS certificates can be associated with the same context.
     * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
     * Only a single TLS certificate is supported in client contexts. In server contexts, the first
     * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
     * used for clients that support ECDSA.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
     */
    public java.util.List<envoy.api.v2.auth.Cert.TlsCertificate> getTlsCertificatesList() {
      return tlsCertificates_;
    }
    /**
     * <pre>
     * Multiple TLS certificates can be associated with the same context.
     * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
     * Only a single TLS certificate is supported in client contexts. In server contexts, the first
     * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
     * used for clients that support ECDSA.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
     */
    public java.util.List<? extends envoy.api.v2.auth.Cert.TlsCertificateOrBuilder> 
        getTlsCertificatesOrBuilderList() {
      return tlsCertificates_;
    }
    /**
     * <pre>
     * Multiple TLS certificates can be associated with the same context.
     * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
     * Only a single TLS certificate is supported in client contexts. In server contexts, the first
     * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
     * used for clients that support ECDSA.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
     */
    public int getTlsCertificatesCount() {
      return tlsCertificates_.size();
    }
    /**
     * <pre>
     * Multiple TLS certificates can be associated with the same context.
     * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
     * Only a single TLS certificate is supported in client contexts. In server contexts, the first
     * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
     * used for clients that support ECDSA.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
     */
    public envoy.api.v2.auth.Cert.TlsCertificate getTlsCertificates(int index) {
      return tlsCertificates_.get(index);
    }
    /**
     * <pre>
     * Multiple TLS certificates can be associated with the same context.
     * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
     * Only a single TLS certificate is supported in client contexts. In server contexts, the first
     * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
     * used for clients that support ECDSA.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
     */
    public envoy.api.v2.auth.Cert.TlsCertificateOrBuilder getTlsCertificatesOrBuilder(
        int index) {
      return tlsCertificates_.get(index);
    }

    public static final int TLS_CERTIFICATE_SDS_SECRET_CONFIGS_FIELD_NUMBER = 6;
    private java.util.List<envoy.api.v2.auth.Cert.SdsSecretConfig> tlsCertificateSdsSecretConfigs_;
    /**
     * <pre>
     * Configs for fetching TLS certificates via SDS API.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
     */
    public java.util.List<envoy.api.v2.auth.Cert.SdsSecretConfig> getTlsCertificateSdsSecretConfigsList() {
      return tlsCertificateSdsSecretConfigs_;
    }
    /**
     * <pre>
     * Configs for fetching TLS certificates via SDS API.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
     */
    public java.util.List<? extends envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder> 
        getTlsCertificateSdsSecretConfigsOrBuilderList() {
      return tlsCertificateSdsSecretConfigs_;
    }
    /**
     * <pre>
     * Configs for fetching TLS certificates via SDS API.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
     */
    public int getTlsCertificateSdsSecretConfigsCount() {
      return tlsCertificateSdsSecretConfigs_.size();
    }
    /**
     * <pre>
     * Configs for fetching TLS certificates via SDS API.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
     */
    public envoy.api.v2.auth.Cert.SdsSecretConfig getTlsCertificateSdsSecretConfigs(int index) {
      return tlsCertificateSdsSecretConfigs_.get(index);
    }
    /**
     * <pre>
     * Configs for fetching TLS certificates via SDS API.
     * </pre>
     *
     * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
     */
    public envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder getTlsCertificateSdsSecretConfigsOrBuilder(
        int index) {
      return tlsCertificateSdsSecretConfigs_.get(index);
    }

    public static final int VALIDATION_CONTEXT_FIELD_NUMBER = 3;
    /**
     * <pre>
     * How to validate peer certificates.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
     */
    public boolean hasValidationContext() {
      return validationContextTypeCase_ == 3;
    }
    /**
     * <pre>
     * How to validate peer certificates.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
     */
    public envoy.api.v2.auth.Cert.CertificateValidationContext getValidationContext() {
      if (validationContextTypeCase_ == 3) {
         return (envoy.api.v2.auth.Cert.CertificateValidationContext) validationContextType_;
      }
      return envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
    }
    /**
     * <pre>
     * How to validate peer certificates.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
     */
    public envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder getValidationContextOrBuilder() {
      if (validationContextTypeCase_ == 3) {
         return (envoy.api.v2.auth.Cert.CertificateValidationContext) validationContextType_;
      }
      return envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
    }

    public static final int VALIDATION_CONTEXT_SDS_SECRET_CONFIG_FIELD_NUMBER = 7;
    /**
     * <pre>
     * Config for fetching validation context via SDS API.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
     */
    public boolean hasValidationContextSdsSecretConfig() {
      return validationContextTypeCase_ == 7;
    }
    /**
     * <pre>
     * Config for fetching validation context via SDS API.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
     */
    public envoy.api.v2.auth.Cert.SdsSecretConfig getValidationContextSdsSecretConfig() {
      if (validationContextTypeCase_ == 7) {
         return (envoy.api.v2.auth.Cert.SdsSecretConfig) validationContextType_;
      }
      return envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
    }
    /**
     * <pre>
     * Config for fetching validation context via SDS API.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
     */
    public envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder getValidationContextSdsSecretConfigOrBuilder() {
      if (validationContextTypeCase_ == 7) {
         return (envoy.api.v2.auth.Cert.SdsSecretConfig) validationContextType_;
      }
      return envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
    }

    public static final int COMBINED_VALIDATION_CONTEXT_FIELD_NUMBER = 8;
    /**
     * <pre>
     * Combined certificate validation context holds a default CertificateValidationContext
     * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
     * and default CertificateValidationContext are merged into a new CertificateValidationContext
     * for validation. This merge is done by Message::MergeFrom(), so dynamic
     * CertificateValidationContext overwrites singular fields in default
     * CertificateValidationContext, and concatenates repeated fields to default
     * CertificateValidationContext, and logical OR is applied to boolean fields.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
     */
    public boolean hasCombinedValidationContext() {
      return validationContextTypeCase_ == 8;
    }
    /**
     * <pre>
     * Combined certificate validation context holds a default CertificateValidationContext
     * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
     * and default CertificateValidationContext are merged into a new CertificateValidationContext
     * for validation. This merge is done by Message::MergeFrom(), so dynamic
     * CertificateValidationContext overwrites singular fields in default
     * CertificateValidationContext, and concatenates repeated fields to default
     * CertificateValidationContext, and logical OR is applied to boolean fields.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
     */
    public envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext getCombinedValidationContext() {
      if (validationContextTypeCase_ == 8) {
         return (envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) validationContextType_;
      }
      return envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.getDefaultInstance();
    }
    /**
     * <pre>
     * Combined certificate validation context holds a default CertificateValidationContext
     * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
     * and default CertificateValidationContext are merged into a new CertificateValidationContext
     * for validation. This merge is done by Message::MergeFrom(), so dynamic
     * CertificateValidationContext overwrites singular fields in default
     * CertificateValidationContext, and concatenates repeated fields to default
     * CertificateValidationContext, and logical OR is applied to boolean fields.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
     */
    public envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContextOrBuilder getCombinedValidationContextOrBuilder() {
      if (validationContextTypeCase_ == 8) {
         return (envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) validationContextType_;
      }
      return envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.getDefaultInstance();
    }

    public static final int ALPN_PROTOCOLS_FIELD_NUMBER = 4;
    private com.google.protobuf.LazyStringList alpnProtocols_;
    /**
     * <pre>
     * Supplies the list of ALPN protocols that the listener should expose. In
     * practice this is likely to be set to one of two values (see the
     * :ref:`codec_type
     * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
     * parameter in the HTTP connection manager for more information):
     * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
     * * "http/1.1" If the listener is only going to support HTTP/1.1.
     * There is no default for this parameter. If empty, Envoy will not expose ALPN.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 4;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getAlpnProtocolsList() {
      return alpnProtocols_;
    }
    /**
     * <pre>
     * Supplies the list of ALPN protocols that the listener should expose. In
     * practice this is likely to be set to one of two values (see the
     * :ref:`codec_type
     * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
     * parameter in the HTTP connection manager for more information):
     * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
     * * "http/1.1" If the listener is only going to support HTTP/1.1.
     * There is no default for this parameter. If empty, Envoy will not expose ALPN.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 4;</code>
     */
    public int getAlpnProtocolsCount() {
      return alpnProtocols_.size();
    }
    /**
     * <pre>
     * Supplies the list of ALPN protocols that the listener should expose. In
     * practice this is likely to be set to one of two values (see the
     * :ref:`codec_type
     * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
     * parameter in the HTTP connection manager for more information):
     * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
     * * "http/1.1" If the listener is only going to support HTTP/1.1.
     * There is no default for this parameter. If empty, Envoy will not expose ALPN.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 4;</code>
     */
    public java.lang.String getAlpnProtocols(int index) {
      return alpnProtocols_.get(index);
    }
    /**
     * <pre>
     * Supplies the list of ALPN protocols that the listener should expose. In
     * practice this is likely to be set to one of two values (see the
     * :ref:`codec_type
     * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
     * parameter in the HTTP connection manager for more information):
     * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
     * * "http/1.1" If the listener is only going to support HTTP/1.1.
     * There is no default for this parameter. If empty, Envoy will not expose ALPN.
     * </pre>
     *
     * <code>repeated string alpn_protocols = 4;</code>
     */
    public com.google.protobuf.ByteString
        getAlpnProtocolsBytes(int index) {
      return alpnProtocols_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (tlsParams_ != null) {
        output.writeMessage(1, getTlsParams());
      }
      for (int i = 0; i < tlsCertificates_.size(); i++) {
        output.writeMessage(2, tlsCertificates_.get(i));
      }
      if (validationContextTypeCase_ == 3) {
        output.writeMessage(3, (envoy.api.v2.auth.Cert.CertificateValidationContext) validationContextType_);
      }
      for (int i = 0; i < alpnProtocols_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, alpnProtocols_.getRaw(i));
      }
      for (int i = 0; i < tlsCertificateSdsSecretConfigs_.size(); i++) {
        output.writeMessage(6, tlsCertificateSdsSecretConfigs_.get(i));
      }
      if (validationContextTypeCase_ == 7) {
        output.writeMessage(7, (envoy.api.v2.auth.Cert.SdsSecretConfig) validationContextType_);
      }
      if (validationContextTypeCase_ == 8) {
        output.writeMessage(8, (envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) validationContextType_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (tlsParams_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getTlsParams());
      }
      for (int i = 0; i < tlsCertificates_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, tlsCertificates_.get(i));
      }
      if (validationContextTypeCase_ == 3) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, (envoy.api.v2.auth.Cert.CertificateValidationContext) validationContextType_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < alpnProtocols_.size(); i++) {
          dataSize += computeStringSizeNoTag(alpnProtocols_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAlpnProtocolsList().size();
      }
      for (int i = 0; i < tlsCertificateSdsSecretConfigs_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, tlsCertificateSdsSecretConfigs_.get(i));
      }
      if (validationContextTypeCase_ == 7) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, (envoy.api.v2.auth.Cert.SdsSecretConfig) validationContextType_);
      }
      if (validationContextTypeCase_ == 8) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, (envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) validationContextType_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof envoy.api.v2.auth.Cert.CommonTlsContext)) {
        return super.equals(obj);
      }
      envoy.api.v2.auth.Cert.CommonTlsContext other = (envoy.api.v2.auth.Cert.CommonTlsContext) obj;

      boolean result = true;
      result = result && (hasTlsParams() == other.hasTlsParams());
      if (hasTlsParams()) {
        result = result && getTlsParams()
            .equals(other.getTlsParams());
      }
      result = result && getTlsCertificatesList()
          .equals(other.getTlsCertificatesList());
      result = result && getTlsCertificateSdsSecretConfigsList()
          .equals(other.getTlsCertificateSdsSecretConfigsList());
      result = result && getAlpnProtocolsList()
          .equals(other.getAlpnProtocolsList());
      result = result && getValidationContextTypeCase().equals(
          other.getValidationContextTypeCase());
      if (!result) return false;
      switch (validationContextTypeCase_) {
        case 3:
          result = result && getValidationContext()
              .equals(other.getValidationContext());
          break;
        case 7:
          result = result && getValidationContextSdsSecretConfig()
              .equals(other.getValidationContextSdsSecretConfig());
          break;
        case 8:
          result = result && getCombinedValidationContext()
              .equals(other.getCombinedValidationContext());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTlsParams()) {
        hash = (37 * hash) + TLS_PARAMS_FIELD_NUMBER;
        hash = (53 * hash) + getTlsParams().hashCode();
      }
      if (getTlsCertificatesCount() > 0) {
        hash = (37 * hash) + TLS_CERTIFICATES_FIELD_NUMBER;
        hash = (53 * hash) + getTlsCertificatesList().hashCode();
      }
      if (getTlsCertificateSdsSecretConfigsCount() > 0) {
        hash = (37 * hash) + TLS_CERTIFICATE_SDS_SECRET_CONFIGS_FIELD_NUMBER;
        hash = (53 * hash) + getTlsCertificateSdsSecretConfigsList().hashCode();
      }
      if (getAlpnProtocolsCount() > 0) {
        hash = (37 * hash) + ALPN_PROTOCOLS_FIELD_NUMBER;
        hash = (53 * hash) + getAlpnProtocolsList().hashCode();
      }
      switch (validationContextTypeCase_) {
        case 3:
          hash = (37 * hash) + VALIDATION_CONTEXT_FIELD_NUMBER;
          hash = (53 * hash) + getValidationContext().hashCode();
          break;
        case 7:
          hash = (37 * hash) + VALIDATION_CONTEXT_SDS_SECRET_CONFIG_FIELD_NUMBER;
          hash = (53 * hash) + getValidationContextSdsSecretConfig().hashCode();
          break;
        case 8:
          hash = (37 * hash) + COMBINED_VALIDATION_CONTEXT_FIELD_NUMBER;
          hash = (53 * hash) + getCombinedValidationContext().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static envoy.api.v2.auth.Cert.CommonTlsContext parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.CommonTlsContext parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.CommonTlsContext parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.CommonTlsContext parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.CommonTlsContext parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.CommonTlsContext parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.CommonTlsContext parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.CommonTlsContext parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.CommonTlsContext parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.CommonTlsContext parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.CommonTlsContext parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.CommonTlsContext parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(envoy.api.v2.auth.Cert.CommonTlsContext prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * TLS context shared by both client and server TLS contexts.
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.auth.CommonTlsContext}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.auth.CommonTlsContext)
        envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CommonTlsContext_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CommonTlsContext_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                envoy.api.v2.auth.Cert.CommonTlsContext.class, envoy.api.v2.auth.Cert.CommonTlsContext.Builder.class);
      }

      // Construct using envoy.api.v2.auth.Cert.CommonTlsContext.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getTlsCertificatesFieldBuilder();
          getTlsCertificateSdsSecretConfigsFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (tlsParamsBuilder_ == null) {
          tlsParams_ = null;
        } else {
          tlsParams_ = null;
          tlsParamsBuilder_ = null;
        }
        if (tlsCertificatesBuilder_ == null) {
          tlsCertificates_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          tlsCertificatesBuilder_.clear();
        }
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          tlsCertificateSdsSecretConfigs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
        } else {
          tlsCertificateSdsSecretConfigsBuilder_.clear();
        }
        alpnProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000040);
        validationContextTypeCase_ = 0;
        validationContextType_ = null;
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_CommonTlsContext_descriptor;
      }

      public envoy.api.v2.auth.Cert.CommonTlsContext getDefaultInstanceForType() {
        return envoy.api.v2.auth.Cert.CommonTlsContext.getDefaultInstance();
      }

      public envoy.api.v2.auth.Cert.CommonTlsContext build() {
        envoy.api.v2.auth.Cert.CommonTlsContext result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public envoy.api.v2.auth.Cert.CommonTlsContext buildPartial() {
        envoy.api.v2.auth.Cert.CommonTlsContext result = new envoy.api.v2.auth.Cert.CommonTlsContext(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (tlsParamsBuilder_ == null) {
          result.tlsParams_ = tlsParams_;
        } else {
          result.tlsParams_ = tlsParamsBuilder_.build();
        }
        if (tlsCertificatesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            tlsCertificates_ = java.util.Collections.unmodifiableList(tlsCertificates_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.tlsCertificates_ = tlsCertificates_;
        } else {
          result.tlsCertificates_ = tlsCertificatesBuilder_.build();
        }
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004)) {
            tlsCertificateSdsSecretConfigs_ = java.util.Collections.unmodifiableList(tlsCertificateSdsSecretConfigs_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.tlsCertificateSdsSecretConfigs_ = tlsCertificateSdsSecretConfigs_;
        } else {
          result.tlsCertificateSdsSecretConfigs_ = tlsCertificateSdsSecretConfigsBuilder_.build();
        }
        if (validationContextTypeCase_ == 3) {
          if (validationContextBuilder_ == null) {
            result.validationContextType_ = validationContextType_;
          } else {
            result.validationContextType_ = validationContextBuilder_.build();
          }
        }
        if (validationContextTypeCase_ == 7) {
          if (validationContextSdsSecretConfigBuilder_ == null) {
            result.validationContextType_ = validationContextType_;
          } else {
            result.validationContextType_ = validationContextSdsSecretConfigBuilder_.build();
          }
        }
        if (validationContextTypeCase_ == 8) {
          if (combinedValidationContextBuilder_ == null) {
            result.validationContextType_ = validationContextType_;
          } else {
            result.validationContextType_ = combinedValidationContextBuilder_.build();
          }
        }
        if (((bitField0_ & 0x00000040) == 0x00000040)) {
          alpnProtocols_ = alpnProtocols_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000040);
        }
        result.alpnProtocols_ = alpnProtocols_;
        result.bitField0_ = to_bitField0_;
        result.validationContextTypeCase_ = validationContextTypeCase_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof envoy.api.v2.auth.Cert.CommonTlsContext) {
          return mergeFrom((envoy.api.v2.auth.Cert.CommonTlsContext)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(envoy.api.v2.auth.Cert.CommonTlsContext other) {
        if (other == envoy.api.v2.auth.Cert.CommonTlsContext.getDefaultInstance()) return this;
        if (other.hasTlsParams()) {
          mergeTlsParams(other.getTlsParams());
        }
        if (tlsCertificatesBuilder_ == null) {
          if (!other.tlsCertificates_.isEmpty()) {
            if (tlsCertificates_.isEmpty()) {
              tlsCertificates_ = other.tlsCertificates_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureTlsCertificatesIsMutable();
              tlsCertificates_.addAll(other.tlsCertificates_);
            }
            onChanged();
          }
        } else {
          if (!other.tlsCertificates_.isEmpty()) {
            if (tlsCertificatesBuilder_.isEmpty()) {
              tlsCertificatesBuilder_.dispose();
              tlsCertificatesBuilder_ = null;
              tlsCertificates_ = other.tlsCertificates_;
              bitField0_ = (bitField0_ & ~0x00000002);
              tlsCertificatesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getTlsCertificatesFieldBuilder() : null;
            } else {
              tlsCertificatesBuilder_.addAllMessages(other.tlsCertificates_);
            }
          }
        }
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          if (!other.tlsCertificateSdsSecretConfigs_.isEmpty()) {
            if (tlsCertificateSdsSecretConfigs_.isEmpty()) {
              tlsCertificateSdsSecretConfigs_ = other.tlsCertificateSdsSecretConfigs_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureTlsCertificateSdsSecretConfigsIsMutable();
              tlsCertificateSdsSecretConfigs_.addAll(other.tlsCertificateSdsSecretConfigs_);
            }
            onChanged();
          }
        } else {
          if (!other.tlsCertificateSdsSecretConfigs_.isEmpty()) {
            if (tlsCertificateSdsSecretConfigsBuilder_.isEmpty()) {
              tlsCertificateSdsSecretConfigsBuilder_.dispose();
              tlsCertificateSdsSecretConfigsBuilder_ = null;
              tlsCertificateSdsSecretConfigs_ = other.tlsCertificateSdsSecretConfigs_;
              bitField0_ = (bitField0_ & ~0x00000004);
              tlsCertificateSdsSecretConfigsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getTlsCertificateSdsSecretConfigsFieldBuilder() : null;
            } else {
              tlsCertificateSdsSecretConfigsBuilder_.addAllMessages(other.tlsCertificateSdsSecretConfigs_);
            }
          }
        }
        if (!other.alpnProtocols_.isEmpty()) {
          if (alpnProtocols_.isEmpty()) {
            alpnProtocols_ = other.alpnProtocols_;
            bitField0_ = (bitField0_ & ~0x00000040);
          } else {
            ensureAlpnProtocolsIsMutable();
            alpnProtocols_.addAll(other.alpnProtocols_);
          }
          onChanged();
        }
        switch (other.getValidationContextTypeCase()) {
          case VALIDATION_CONTEXT: {
            mergeValidationContext(other.getValidationContext());
            break;
          }
          case VALIDATION_CONTEXT_SDS_SECRET_CONFIG: {
            mergeValidationContextSdsSecretConfig(other.getValidationContextSdsSecretConfig());
            break;
          }
          case COMBINED_VALIDATION_CONTEXT: {
            mergeCombinedValidationContext(other.getCombinedValidationContext());
            break;
          }
          case VALIDATIONCONTEXTTYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        envoy.api.v2.auth.Cert.CommonTlsContext parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (envoy.api.v2.auth.Cert.CommonTlsContext) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int validationContextTypeCase_ = 0;
      private java.lang.Object validationContextType_;
      public ValidationContextTypeCase
          getValidationContextTypeCase() {
        return ValidationContextTypeCase.forNumber(
            validationContextTypeCase_);
      }

      public Builder clearValidationContextType() {
        validationContextTypeCase_ = 0;
        validationContextType_ = null;
        onChanged();
        return this;
      }

      private int bitField0_;

      private envoy.api.v2.auth.Cert.TlsParameters tlsParams_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.TlsParameters, envoy.api.v2.auth.Cert.TlsParameters.Builder, envoy.api.v2.auth.Cert.TlsParametersOrBuilder> tlsParamsBuilder_;
      /**
       * <pre>
       * TLS protocol versions, cipher suites etc.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
       */
      public boolean hasTlsParams() {
        return tlsParamsBuilder_ != null || tlsParams_ != null;
      }
      /**
       * <pre>
       * TLS protocol versions, cipher suites etc.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
       */
      public envoy.api.v2.auth.Cert.TlsParameters getTlsParams() {
        if (tlsParamsBuilder_ == null) {
          return tlsParams_ == null ? envoy.api.v2.auth.Cert.TlsParameters.getDefaultInstance() : tlsParams_;
        } else {
          return tlsParamsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * TLS protocol versions, cipher suites etc.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
       */
      public Builder setTlsParams(envoy.api.v2.auth.Cert.TlsParameters value) {
        if (tlsParamsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          tlsParams_ = value;
          onChanged();
        } else {
          tlsParamsBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * TLS protocol versions, cipher suites etc.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
       */
      public Builder setTlsParams(
          envoy.api.v2.auth.Cert.TlsParameters.Builder builderForValue) {
        if (tlsParamsBuilder_ == null) {
          tlsParams_ = builderForValue.build();
          onChanged();
        } else {
          tlsParamsBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * TLS protocol versions, cipher suites etc.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
       */
      public Builder mergeTlsParams(envoy.api.v2.auth.Cert.TlsParameters value) {
        if (tlsParamsBuilder_ == null) {
          if (tlsParams_ != null) {
            tlsParams_ =
              envoy.api.v2.auth.Cert.TlsParameters.newBuilder(tlsParams_).mergeFrom(value).buildPartial();
          } else {
            tlsParams_ = value;
          }
          onChanged();
        } else {
          tlsParamsBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * TLS protocol versions, cipher suites etc.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
       */
      public Builder clearTlsParams() {
        if (tlsParamsBuilder_ == null) {
          tlsParams_ = null;
          onChanged();
        } else {
          tlsParams_ = null;
          tlsParamsBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * TLS protocol versions, cipher suites etc.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
       */
      public envoy.api.v2.auth.Cert.TlsParameters.Builder getTlsParamsBuilder() {
        
        onChanged();
        return getTlsParamsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * TLS protocol versions, cipher suites etc.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
       */
      public envoy.api.v2.auth.Cert.TlsParametersOrBuilder getTlsParamsOrBuilder() {
        if (tlsParamsBuilder_ != null) {
          return tlsParamsBuilder_.getMessageOrBuilder();
        } else {
          return tlsParams_ == null ?
              envoy.api.v2.auth.Cert.TlsParameters.getDefaultInstance() : tlsParams_;
        }
      }
      /**
       * <pre>
       * TLS protocol versions, cipher suites etc.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsParameters tls_params = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.TlsParameters, envoy.api.v2.auth.Cert.TlsParameters.Builder, envoy.api.v2.auth.Cert.TlsParametersOrBuilder> 
          getTlsParamsFieldBuilder() {
        if (tlsParamsBuilder_ == null) {
          tlsParamsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.auth.Cert.TlsParameters, envoy.api.v2.auth.Cert.TlsParameters.Builder, envoy.api.v2.auth.Cert.TlsParametersOrBuilder>(
                  getTlsParams(),
                  getParentForChildren(),
                  isClean());
          tlsParams_ = null;
        }
        return tlsParamsBuilder_;
      }

      private java.util.List<envoy.api.v2.auth.Cert.TlsCertificate> tlsCertificates_ =
        java.util.Collections.emptyList();
      private void ensureTlsCertificatesIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          tlsCertificates_ = new java.util.ArrayList<envoy.api.v2.auth.Cert.TlsCertificate>(tlsCertificates_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          envoy.api.v2.auth.Cert.TlsCertificate, envoy.api.v2.auth.Cert.TlsCertificate.Builder, envoy.api.v2.auth.Cert.TlsCertificateOrBuilder> tlsCertificatesBuilder_;

      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public java.util.List<envoy.api.v2.auth.Cert.TlsCertificate> getTlsCertificatesList() {
        if (tlsCertificatesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(tlsCertificates_);
        } else {
          return tlsCertificatesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public int getTlsCertificatesCount() {
        if (tlsCertificatesBuilder_ == null) {
          return tlsCertificates_.size();
        } else {
          return tlsCertificatesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public envoy.api.v2.auth.Cert.TlsCertificate getTlsCertificates(int index) {
        if (tlsCertificatesBuilder_ == null) {
          return tlsCertificates_.get(index);
        } else {
          return tlsCertificatesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public Builder setTlsCertificates(
          int index, envoy.api.v2.auth.Cert.TlsCertificate value) {
        if (tlsCertificatesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTlsCertificatesIsMutable();
          tlsCertificates_.set(index, value);
          onChanged();
        } else {
          tlsCertificatesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public Builder setTlsCertificates(
          int index, envoy.api.v2.auth.Cert.TlsCertificate.Builder builderForValue) {
        if (tlsCertificatesBuilder_ == null) {
          ensureTlsCertificatesIsMutable();
          tlsCertificates_.set(index, builderForValue.build());
          onChanged();
        } else {
          tlsCertificatesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public Builder addTlsCertificates(envoy.api.v2.auth.Cert.TlsCertificate value) {
        if (tlsCertificatesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTlsCertificatesIsMutable();
          tlsCertificates_.add(value);
          onChanged();
        } else {
          tlsCertificatesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public Builder addTlsCertificates(
          int index, envoy.api.v2.auth.Cert.TlsCertificate value) {
        if (tlsCertificatesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTlsCertificatesIsMutable();
          tlsCertificates_.add(index, value);
          onChanged();
        } else {
          tlsCertificatesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public Builder addTlsCertificates(
          envoy.api.v2.auth.Cert.TlsCertificate.Builder builderForValue) {
        if (tlsCertificatesBuilder_ == null) {
          ensureTlsCertificatesIsMutable();
          tlsCertificates_.add(builderForValue.build());
          onChanged();
        } else {
          tlsCertificatesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public Builder addTlsCertificates(
          int index, envoy.api.v2.auth.Cert.TlsCertificate.Builder builderForValue) {
        if (tlsCertificatesBuilder_ == null) {
          ensureTlsCertificatesIsMutable();
          tlsCertificates_.add(index, builderForValue.build());
          onChanged();
        } else {
          tlsCertificatesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public Builder addAllTlsCertificates(
          java.lang.Iterable<? extends envoy.api.v2.auth.Cert.TlsCertificate> values) {
        if (tlsCertificatesBuilder_ == null) {
          ensureTlsCertificatesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, tlsCertificates_);
          onChanged();
        } else {
          tlsCertificatesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public Builder clearTlsCertificates() {
        if (tlsCertificatesBuilder_ == null) {
          tlsCertificates_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          tlsCertificatesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public Builder removeTlsCertificates(int index) {
        if (tlsCertificatesBuilder_ == null) {
          ensureTlsCertificatesIsMutable();
          tlsCertificates_.remove(index);
          onChanged();
        } else {
          tlsCertificatesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public envoy.api.v2.auth.Cert.TlsCertificate.Builder getTlsCertificatesBuilder(
          int index) {
        return getTlsCertificatesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public envoy.api.v2.auth.Cert.TlsCertificateOrBuilder getTlsCertificatesOrBuilder(
          int index) {
        if (tlsCertificatesBuilder_ == null) {
          return tlsCertificates_.get(index);  } else {
          return tlsCertificatesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public java.util.List<? extends envoy.api.v2.auth.Cert.TlsCertificateOrBuilder> 
           getTlsCertificatesOrBuilderList() {
        if (tlsCertificatesBuilder_ != null) {
          return tlsCertificatesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(tlsCertificates_);
        }
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public envoy.api.v2.auth.Cert.TlsCertificate.Builder addTlsCertificatesBuilder() {
        return getTlsCertificatesFieldBuilder().addBuilder(
            envoy.api.v2.auth.Cert.TlsCertificate.getDefaultInstance());
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public envoy.api.v2.auth.Cert.TlsCertificate.Builder addTlsCertificatesBuilder(
          int index) {
        return getTlsCertificatesFieldBuilder().addBuilder(
            index, envoy.api.v2.auth.Cert.TlsCertificate.getDefaultInstance());
      }
      /**
       * <pre>
       * Multiple TLS certificates can be associated with the same context.
       * E.g. to allow both RSA and ECDSA certificates, two TLS certificates can be configured.
       * Only a single TLS certificate is supported in client contexts. In server contexts, the first
       * RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
       * used for clients that support ECDSA.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.TlsCertificate tls_certificates = 2;</code>
       */
      public java.util.List<envoy.api.v2.auth.Cert.TlsCertificate.Builder> 
           getTlsCertificatesBuilderList() {
        return getTlsCertificatesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          envoy.api.v2.auth.Cert.TlsCertificate, envoy.api.v2.auth.Cert.TlsCertificate.Builder, envoy.api.v2.auth.Cert.TlsCertificateOrBuilder> 
          getTlsCertificatesFieldBuilder() {
        if (tlsCertificatesBuilder_ == null) {
          tlsCertificatesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              envoy.api.v2.auth.Cert.TlsCertificate, envoy.api.v2.auth.Cert.TlsCertificate.Builder, envoy.api.v2.auth.Cert.TlsCertificateOrBuilder>(
                  tlsCertificates_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          tlsCertificates_ = null;
        }
        return tlsCertificatesBuilder_;
      }

      private java.util.List<envoy.api.v2.auth.Cert.SdsSecretConfig> tlsCertificateSdsSecretConfigs_ =
        java.util.Collections.emptyList();
      private void ensureTlsCertificateSdsSecretConfigsIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          tlsCertificateSdsSecretConfigs_ = new java.util.ArrayList<envoy.api.v2.auth.Cert.SdsSecretConfig>(tlsCertificateSdsSecretConfigs_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          envoy.api.v2.auth.Cert.SdsSecretConfig, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder, envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder> tlsCertificateSdsSecretConfigsBuilder_;

      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public java.util.List<envoy.api.v2.auth.Cert.SdsSecretConfig> getTlsCertificateSdsSecretConfigsList() {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(tlsCertificateSdsSecretConfigs_);
        } else {
          return tlsCertificateSdsSecretConfigsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public int getTlsCertificateSdsSecretConfigsCount() {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          return tlsCertificateSdsSecretConfigs_.size();
        } else {
          return tlsCertificateSdsSecretConfigsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfig getTlsCertificateSdsSecretConfigs(int index) {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          return tlsCertificateSdsSecretConfigs_.get(index);
        } else {
          return tlsCertificateSdsSecretConfigsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public Builder setTlsCertificateSdsSecretConfigs(
          int index, envoy.api.v2.auth.Cert.SdsSecretConfig value) {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTlsCertificateSdsSecretConfigsIsMutable();
          tlsCertificateSdsSecretConfigs_.set(index, value);
          onChanged();
        } else {
          tlsCertificateSdsSecretConfigsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public Builder setTlsCertificateSdsSecretConfigs(
          int index, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder builderForValue) {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          ensureTlsCertificateSdsSecretConfigsIsMutable();
          tlsCertificateSdsSecretConfigs_.set(index, builderForValue.build());
          onChanged();
        } else {
          tlsCertificateSdsSecretConfigsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public Builder addTlsCertificateSdsSecretConfigs(envoy.api.v2.auth.Cert.SdsSecretConfig value) {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTlsCertificateSdsSecretConfigsIsMutable();
          tlsCertificateSdsSecretConfigs_.add(value);
          onChanged();
        } else {
          tlsCertificateSdsSecretConfigsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public Builder addTlsCertificateSdsSecretConfigs(
          int index, envoy.api.v2.auth.Cert.SdsSecretConfig value) {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureTlsCertificateSdsSecretConfigsIsMutable();
          tlsCertificateSdsSecretConfigs_.add(index, value);
          onChanged();
        } else {
          tlsCertificateSdsSecretConfigsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public Builder addTlsCertificateSdsSecretConfigs(
          envoy.api.v2.auth.Cert.SdsSecretConfig.Builder builderForValue) {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          ensureTlsCertificateSdsSecretConfigsIsMutable();
          tlsCertificateSdsSecretConfigs_.add(builderForValue.build());
          onChanged();
        } else {
          tlsCertificateSdsSecretConfigsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public Builder addTlsCertificateSdsSecretConfigs(
          int index, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder builderForValue) {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          ensureTlsCertificateSdsSecretConfigsIsMutable();
          tlsCertificateSdsSecretConfigs_.add(index, builderForValue.build());
          onChanged();
        } else {
          tlsCertificateSdsSecretConfigsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public Builder addAllTlsCertificateSdsSecretConfigs(
          java.lang.Iterable<? extends envoy.api.v2.auth.Cert.SdsSecretConfig> values) {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          ensureTlsCertificateSdsSecretConfigsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, tlsCertificateSdsSecretConfigs_);
          onChanged();
        } else {
          tlsCertificateSdsSecretConfigsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public Builder clearTlsCertificateSdsSecretConfigs() {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          tlsCertificateSdsSecretConfigs_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          tlsCertificateSdsSecretConfigsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public Builder removeTlsCertificateSdsSecretConfigs(int index) {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          ensureTlsCertificateSdsSecretConfigsIsMutable();
          tlsCertificateSdsSecretConfigs_.remove(index);
          onChanged();
        } else {
          tlsCertificateSdsSecretConfigsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfig.Builder getTlsCertificateSdsSecretConfigsBuilder(
          int index) {
        return getTlsCertificateSdsSecretConfigsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder getTlsCertificateSdsSecretConfigsOrBuilder(
          int index) {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          return tlsCertificateSdsSecretConfigs_.get(index);  } else {
          return tlsCertificateSdsSecretConfigsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public java.util.List<? extends envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder> 
           getTlsCertificateSdsSecretConfigsOrBuilderList() {
        if (tlsCertificateSdsSecretConfigsBuilder_ != null) {
          return tlsCertificateSdsSecretConfigsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(tlsCertificateSdsSecretConfigs_);
        }
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfig.Builder addTlsCertificateSdsSecretConfigsBuilder() {
        return getTlsCertificateSdsSecretConfigsFieldBuilder().addBuilder(
            envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance());
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfig.Builder addTlsCertificateSdsSecretConfigsBuilder(
          int index) {
        return getTlsCertificateSdsSecretConfigsFieldBuilder().addBuilder(
            index, envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance());
      }
      /**
       * <pre>
       * Configs for fetching TLS certificates via SDS API.
       * </pre>
       *
       * <code>repeated .envoy.api.v2.auth.SdsSecretConfig tls_certificate_sds_secret_configs = 6;</code>
       */
      public java.util.List<envoy.api.v2.auth.Cert.SdsSecretConfig.Builder> 
           getTlsCertificateSdsSecretConfigsBuilderList() {
        return getTlsCertificateSdsSecretConfigsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          envoy.api.v2.auth.Cert.SdsSecretConfig, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder, envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder> 
          getTlsCertificateSdsSecretConfigsFieldBuilder() {
        if (tlsCertificateSdsSecretConfigsBuilder_ == null) {
          tlsCertificateSdsSecretConfigsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              envoy.api.v2.auth.Cert.SdsSecretConfig, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder, envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder>(
                  tlsCertificateSdsSecretConfigs_,
                  ((bitField0_ & 0x00000004) == 0x00000004),
                  getParentForChildren(),
                  isClean());
          tlsCertificateSdsSecretConfigs_ = null;
        }
        return tlsCertificateSdsSecretConfigsBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.CertificateValidationContext, envoy.api.v2.auth.Cert.CertificateValidationContext.Builder, envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder> validationContextBuilder_;
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
       */
      public boolean hasValidationContext() {
        return validationContextTypeCase_ == 3;
      }
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
       */
      public envoy.api.v2.auth.Cert.CertificateValidationContext getValidationContext() {
        if (validationContextBuilder_ == null) {
          if (validationContextTypeCase_ == 3) {
            return (envoy.api.v2.auth.Cert.CertificateValidationContext) validationContextType_;
          }
          return envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
        } else {
          if (validationContextTypeCase_ == 3) {
            return validationContextBuilder_.getMessage();
          }
          return envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
       */
      public Builder setValidationContext(envoy.api.v2.auth.Cert.CertificateValidationContext value) {
        if (validationContextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          validationContextType_ = value;
          onChanged();
        } else {
          validationContextBuilder_.setMessage(value);
        }
        validationContextTypeCase_ = 3;
        return this;
      }
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
       */
      public Builder setValidationContext(
          envoy.api.v2.auth.Cert.CertificateValidationContext.Builder builderForValue) {
        if (validationContextBuilder_ == null) {
          validationContextType_ = builderForValue.build();
          onChanged();
        } else {
          validationContextBuilder_.setMessage(builderForValue.build());
        }
        validationContextTypeCase_ = 3;
        return this;
      }
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
       */
      public Builder mergeValidationContext(envoy.api.v2.auth.Cert.CertificateValidationContext value) {
        if (validationContextBuilder_ == null) {
          if (validationContextTypeCase_ == 3 &&
              validationContextType_ != envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance()) {
            validationContextType_ = envoy.api.v2.auth.Cert.CertificateValidationContext.newBuilder((envoy.api.v2.auth.Cert.CertificateValidationContext) validationContextType_)
                .mergeFrom(value).buildPartial();
          } else {
            validationContextType_ = value;
          }
          onChanged();
        } else {
          if (validationContextTypeCase_ == 3) {
            validationContextBuilder_.mergeFrom(value);
          }
          validationContextBuilder_.setMessage(value);
        }
        validationContextTypeCase_ = 3;
        return this;
      }
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
       */
      public Builder clearValidationContext() {
        if (validationContextBuilder_ == null) {
          if (validationContextTypeCase_ == 3) {
            validationContextTypeCase_ = 0;
            validationContextType_ = null;
            onChanged();
          }
        } else {
          if (validationContextTypeCase_ == 3) {
            validationContextTypeCase_ = 0;
            validationContextType_ = null;
          }
          validationContextBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
       */
      public envoy.api.v2.auth.Cert.CertificateValidationContext.Builder getValidationContextBuilder() {
        return getValidationContextFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
       */
      public envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder getValidationContextOrBuilder() {
        if ((validationContextTypeCase_ == 3) && (validationContextBuilder_ != null)) {
          return validationContextBuilder_.getMessageOrBuilder();
        } else {
          if (validationContextTypeCase_ == 3) {
            return (envoy.api.v2.auth.Cert.CertificateValidationContext) validationContextType_;
          }
          return envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * How to validate peer certificates.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.CertificateValidationContext, envoy.api.v2.auth.Cert.CertificateValidationContext.Builder, envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder> 
          getValidationContextFieldBuilder() {
        if (validationContextBuilder_ == null) {
          if (!(validationContextTypeCase_ == 3)) {
            validationContextType_ = envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
          }
          validationContextBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.auth.Cert.CertificateValidationContext, envoy.api.v2.auth.Cert.CertificateValidationContext.Builder, envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder>(
                  (envoy.api.v2.auth.Cert.CertificateValidationContext) validationContextType_,
                  getParentForChildren(),
                  isClean());
          validationContextType_ = null;
        }
        validationContextTypeCase_ = 3;
        onChanged();;
        return validationContextBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.SdsSecretConfig, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder, envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder> validationContextSdsSecretConfigBuilder_;
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
       */
      public boolean hasValidationContextSdsSecretConfig() {
        return validationContextTypeCase_ == 7;
      }
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfig getValidationContextSdsSecretConfig() {
        if (validationContextSdsSecretConfigBuilder_ == null) {
          if (validationContextTypeCase_ == 7) {
            return (envoy.api.v2.auth.Cert.SdsSecretConfig) validationContextType_;
          }
          return envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
        } else {
          if (validationContextTypeCase_ == 7) {
            return validationContextSdsSecretConfigBuilder_.getMessage();
          }
          return envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
       */
      public Builder setValidationContextSdsSecretConfig(envoy.api.v2.auth.Cert.SdsSecretConfig value) {
        if (validationContextSdsSecretConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          validationContextType_ = value;
          onChanged();
        } else {
          validationContextSdsSecretConfigBuilder_.setMessage(value);
        }
        validationContextTypeCase_ = 7;
        return this;
      }
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
       */
      public Builder setValidationContextSdsSecretConfig(
          envoy.api.v2.auth.Cert.SdsSecretConfig.Builder builderForValue) {
        if (validationContextSdsSecretConfigBuilder_ == null) {
          validationContextType_ = builderForValue.build();
          onChanged();
        } else {
          validationContextSdsSecretConfigBuilder_.setMessage(builderForValue.build());
        }
        validationContextTypeCase_ = 7;
        return this;
      }
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
       */
      public Builder mergeValidationContextSdsSecretConfig(envoy.api.v2.auth.Cert.SdsSecretConfig value) {
        if (validationContextSdsSecretConfigBuilder_ == null) {
          if (validationContextTypeCase_ == 7 &&
              validationContextType_ != envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance()) {
            validationContextType_ = envoy.api.v2.auth.Cert.SdsSecretConfig.newBuilder((envoy.api.v2.auth.Cert.SdsSecretConfig) validationContextType_)
                .mergeFrom(value).buildPartial();
          } else {
            validationContextType_ = value;
          }
          onChanged();
        } else {
          if (validationContextTypeCase_ == 7) {
            validationContextSdsSecretConfigBuilder_.mergeFrom(value);
          }
          validationContextSdsSecretConfigBuilder_.setMessage(value);
        }
        validationContextTypeCase_ = 7;
        return this;
      }
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
       */
      public Builder clearValidationContextSdsSecretConfig() {
        if (validationContextSdsSecretConfigBuilder_ == null) {
          if (validationContextTypeCase_ == 7) {
            validationContextTypeCase_ = 0;
            validationContextType_ = null;
            onChanged();
          }
        } else {
          if (validationContextTypeCase_ == 7) {
            validationContextTypeCase_ = 0;
            validationContextType_ = null;
          }
          validationContextSdsSecretConfigBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfig.Builder getValidationContextSdsSecretConfigBuilder() {
        return getValidationContextSdsSecretConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder getValidationContextSdsSecretConfigOrBuilder() {
        if ((validationContextTypeCase_ == 7) && (validationContextSdsSecretConfigBuilder_ != null)) {
          return validationContextSdsSecretConfigBuilder_.getMessageOrBuilder();
        } else {
          if (validationContextTypeCase_ == 7) {
            return (envoy.api.v2.auth.Cert.SdsSecretConfig) validationContextType_;
          }
          return envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Config for fetching validation context via SDS API.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig validation_context_sds_secret_config = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.SdsSecretConfig, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder, envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder> 
          getValidationContextSdsSecretConfigFieldBuilder() {
        if (validationContextSdsSecretConfigBuilder_ == null) {
          if (!(validationContextTypeCase_ == 7)) {
            validationContextType_ = envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
          }
          validationContextSdsSecretConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.auth.Cert.SdsSecretConfig, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder, envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder>(
                  (envoy.api.v2.auth.Cert.SdsSecretConfig) validationContextType_,
                  getParentForChildren(),
                  isClean());
          validationContextType_ = null;
        }
        validationContextTypeCase_ = 7;
        onChanged();;
        return validationContextSdsSecretConfigBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext, envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.Builder, envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContextOrBuilder> combinedValidationContextBuilder_;
      /**
       * <pre>
       * Combined certificate validation context holds a default CertificateValidationContext
       * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
       * and default CertificateValidationContext are merged into a new CertificateValidationContext
       * for validation. This merge is done by Message::MergeFrom(), so dynamic
       * CertificateValidationContext overwrites singular fields in default
       * CertificateValidationContext, and concatenates repeated fields to default
       * CertificateValidationContext, and logical OR is applied to boolean fields.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
       */
      public boolean hasCombinedValidationContext() {
        return validationContextTypeCase_ == 8;
      }
      /**
       * <pre>
       * Combined certificate validation context holds a default CertificateValidationContext
       * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
       * and default CertificateValidationContext are merged into a new CertificateValidationContext
       * for validation. This merge is done by Message::MergeFrom(), so dynamic
       * CertificateValidationContext overwrites singular fields in default
       * CertificateValidationContext, and concatenates repeated fields to default
       * CertificateValidationContext, and logical OR is applied to boolean fields.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
       */
      public envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext getCombinedValidationContext() {
        if (combinedValidationContextBuilder_ == null) {
          if (validationContextTypeCase_ == 8) {
            return (envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) validationContextType_;
          }
          return envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.getDefaultInstance();
        } else {
          if (validationContextTypeCase_ == 8) {
            return combinedValidationContextBuilder_.getMessage();
          }
          return envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Combined certificate validation context holds a default CertificateValidationContext
       * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
       * and default CertificateValidationContext are merged into a new CertificateValidationContext
       * for validation. This merge is done by Message::MergeFrom(), so dynamic
       * CertificateValidationContext overwrites singular fields in default
       * CertificateValidationContext, and concatenates repeated fields to default
       * CertificateValidationContext, and logical OR is applied to boolean fields.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
       */
      public Builder setCombinedValidationContext(envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext value) {
        if (combinedValidationContextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          validationContextType_ = value;
          onChanged();
        } else {
          combinedValidationContextBuilder_.setMessage(value);
        }
        validationContextTypeCase_ = 8;
        return this;
      }
      /**
       * <pre>
       * Combined certificate validation context holds a default CertificateValidationContext
       * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
       * and default CertificateValidationContext are merged into a new CertificateValidationContext
       * for validation. This merge is done by Message::MergeFrom(), so dynamic
       * CertificateValidationContext overwrites singular fields in default
       * CertificateValidationContext, and concatenates repeated fields to default
       * CertificateValidationContext, and logical OR is applied to boolean fields.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
       */
      public Builder setCombinedValidationContext(
          envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.Builder builderForValue) {
        if (combinedValidationContextBuilder_ == null) {
          validationContextType_ = builderForValue.build();
          onChanged();
        } else {
          combinedValidationContextBuilder_.setMessage(builderForValue.build());
        }
        validationContextTypeCase_ = 8;
        return this;
      }
      /**
       * <pre>
       * Combined certificate validation context holds a default CertificateValidationContext
       * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
       * and default CertificateValidationContext are merged into a new CertificateValidationContext
       * for validation. This merge is done by Message::MergeFrom(), so dynamic
       * CertificateValidationContext overwrites singular fields in default
       * CertificateValidationContext, and concatenates repeated fields to default
       * CertificateValidationContext, and logical OR is applied to boolean fields.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
       */
      public Builder mergeCombinedValidationContext(envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext value) {
        if (combinedValidationContextBuilder_ == null) {
          if (validationContextTypeCase_ == 8 &&
              validationContextType_ != envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.getDefaultInstance()) {
            validationContextType_ = envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.newBuilder((envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) validationContextType_)
                .mergeFrom(value).buildPartial();
          } else {
            validationContextType_ = value;
          }
          onChanged();
        } else {
          if (validationContextTypeCase_ == 8) {
            combinedValidationContextBuilder_.mergeFrom(value);
          }
          combinedValidationContextBuilder_.setMessage(value);
        }
        validationContextTypeCase_ = 8;
        return this;
      }
      /**
       * <pre>
       * Combined certificate validation context holds a default CertificateValidationContext
       * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
       * and default CertificateValidationContext are merged into a new CertificateValidationContext
       * for validation. This merge is done by Message::MergeFrom(), so dynamic
       * CertificateValidationContext overwrites singular fields in default
       * CertificateValidationContext, and concatenates repeated fields to default
       * CertificateValidationContext, and logical OR is applied to boolean fields.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
       */
      public Builder clearCombinedValidationContext() {
        if (combinedValidationContextBuilder_ == null) {
          if (validationContextTypeCase_ == 8) {
            validationContextTypeCase_ = 0;
            validationContextType_ = null;
            onChanged();
          }
        } else {
          if (validationContextTypeCase_ == 8) {
            validationContextTypeCase_ = 0;
            validationContextType_ = null;
          }
          combinedValidationContextBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Combined certificate validation context holds a default CertificateValidationContext
       * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
       * and default CertificateValidationContext are merged into a new CertificateValidationContext
       * for validation. This merge is done by Message::MergeFrom(), so dynamic
       * CertificateValidationContext overwrites singular fields in default
       * CertificateValidationContext, and concatenates repeated fields to default
       * CertificateValidationContext, and logical OR is applied to boolean fields.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
       */
      public envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.Builder getCombinedValidationContextBuilder() {
        return getCombinedValidationContextFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Combined certificate validation context holds a default CertificateValidationContext
       * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
       * and default CertificateValidationContext are merged into a new CertificateValidationContext
       * for validation. This merge is done by Message::MergeFrom(), so dynamic
       * CertificateValidationContext overwrites singular fields in default
       * CertificateValidationContext, and concatenates repeated fields to default
       * CertificateValidationContext, and logical OR is applied to boolean fields.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
       */
      public envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContextOrBuilder getCombinedValidationContextOrBuilder() {
        if ((validationContextTypeCase_ == 8) && (combinedValidationContextBuilder_ != null)) {
          return combinedValidationContextBuilder_.getMessageOrBuilder();
        } else {
          if (validationContextTypeCase_ == 8) {
            return (envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) validationContextType_;
          }
          return envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Combined certificate validation context holds a default CertificateValidationContext
       * and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
       * and default CertificateValidationContext are merged into a new CertificateValidationContext
       * for validation. This merge is done by Message::MergeFrom(), so dynamic
       * CertificateValidationContext overwrites singular fields in default
       * CertificateValidationContext, and concatenates repeated fields to default
       * CertificateValidationContext, and logical OR is applied to boolean fields.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext.CombinedCertificateValidationContext combined_validation_context = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext, envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.Builder, envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContextOrBuilder> 
          getCombinedValidationContextFieldBuilder() {
        if (combinedValidationContextBuilder_ == null) {
          if (!(validationContextTypeCase_ == 8)) {
            validationContextType_ = envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.getDefaultInstance();
          }
          combinedValidationContextBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext, envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext.Builder, envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContextOrBuilder>(
                  (envoy.api.v2.auth.Cert.CommonTlsContext.CombinedCertificateValidationContext) validationContextType_,
                  getParentForChildren(),
                  isClean());
          validationContextType_ = null;
        }
        validationContextTypeCase_ = 8;
        onChanged();;
        return combinedValidationContextBuilder_;
      }

      private com.google.protobuf.LazyStringList alpnProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureAlpnProtocolsIsMutable() {
        if (!((bitField0_ & 0x00000040) == 0x00000040)) {
          alpnProtocols_ = new com.google.protobuf.LazyStringArrayList(alpnProtocols_);
          bitField0_ |= 0x00000040;
         }
      }
      /**
       * <pre>
       * Supplies the list of ALPN protocols that the listener should expose. In
       * practice this is likely to be set to one of two values (see the
       * :ref:`codec_type
       * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
       * parameter in the HTTP connection manager for more information):
       * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
       * * "http/1.1" If the listener is only going to support HTTP/1.1.
       * There is no default for this parameter. If empty, Envoy will not expose ALPN.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 4;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getAlpnProtocolsList() {
        return alpnProtocols_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Supplies the list of ALPN protocols that the listener should expose. In
       * practice this is likely to be set to one of two values (see the
       * :ref:`codec_type
       * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
       * parameter in the HTTP connection manager for more information):
       * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
       * * "http/1.1" If the listener is only going to support HTTP/1.1.
       * There is no default for this parameter. If empty, Envoy will not expose ALPN.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 4;</code>
       */
      public int getAlpnProtocolsCount() {
        return alpnProtocols_.size();
      }
      /**
       * <pre>
       * Supplies the list of ALPN protocols that the listener should expose. In
       * practice this is likely to be set to one of two values (see the
       * :ref:`codec_type
       * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
       * parameter in the HTTP connection manager for more information):
       * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
       * * "http/1.1" If the listener is only going to support HTTP/1.1.
       * There is no default for this parameter. If empty, Envoy will not expose ALPN.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 4;</code>
       */
      public java.lang.String getAlpnProtocols(int index) {
        return alpnProtocols_.get(index);
      }
      /**
       * <pre>
       * Supplies the list of ALPN protocols that the listener should expose. In
       * practice this is likely to be set to one of two values (see the
       * :ref:`codec_type
       * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
       * parameter in the HTTP connection manager for more information):
       * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
       * * "http/1.1" If the listener is only going to support HTTP/1.1.
       * There is no default for this parameter. If empty, Envoy will not expose ALPN.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 4;</code>
       */
      public com.google.protobuf.ByteString
          getAlpnProtocolsBytes(int index) {
        return alpnProtocols_.getByteString(index);
      }
      /**
       * <pre>
       * Supplies the list of ALPN protocols that the listener should expose. In
       * practice this is likely to be set to one of two values (see the
       * :ref:`codec_type
       * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
       * parameter in the HTTP connection manager for more information):
       * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
       * * "http/1.1" If the listener is only going to support HTTP/1.1.
       * There is no default for this parameter. If empty, Envoy will not expose ALPN.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 4;</code>
       */
      public Builder setAlpnProtocols(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAlpnProtocolsIsMutable();
        alpnProtocols_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Supplies the list of ALPN protocols that the listener should expose. In
       * practice this is likely to be set to one of two values (see the
       * :ref:`codec_type
       * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
       * parameter in the HTTP connection manager for more information):
       * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
       * * "http/1.1" If the listener is only going to support HTTP/1.1.
       * There is no default for this parameter. If empty, Envoy will not expose ALPN.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 4;</code>
       */
      public Builder addAlpnProtocols(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureAlpnProtocolsIsMutable();
        alpnProtocols_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Supplies the list of ALPN protocols that the listener should expose. In
       * practice this is likely to be set to one of two values (see the
       * :ref:`codec_type
       * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
       * parameter in the HTTP connection manager for more information):
       * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
       * * "http/1.1" If the listener is only going to support HTTP/1.1.
       * There is no default for this parameter. If empty, Envoy will not expose ALPN.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 4;</code>
       */
      public Builder addAllAlpnProtocols(
          java.lang.Iterable<java.lang.String> values) {
        ensureAlpnProtocolsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, alpnProtocols_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Supplies the list of ALPN protocols that the listener should expose. In
       * practice this is likely to be set to one of two values (see the
       * :ref:`codec_type
       * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
       * parameter in the HTTP connection manager for more information):
       * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
       * * "http/1.1" If the listener is only going to support HTTP/1.1.
       * There is no default for this parameter. If empty, Envoy will not expose ALPN.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 4;</code>
       */
      public Builder clearAlpnProtocols() {
        alpnProtocols_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000040);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Supplies the list of ALPN protocols that the listener should expose. In
       * practice this is likely to be set to one of two values (see the
       * :ref:`codec_type
       * &lt;envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type&gt;`
       * parameter in the HTTP connection manager for more information):
       * * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
       * * "http/1.1" If the listener is only going to support HTTP/1.1.
       * There is no default for this parameter. If empty, Envoy will not expose ALPN.
       * </pre>
       *
       * <code>repeated string alpn_protocols = 4;</code>
       */
      public Builder addAlpnProtocolsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureAlpnProtocolsIsMutable();
        alpnProtocols_.add(value);
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.auth.CommonTlsContext)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.auth.CommonTlsContext)
    private static final envoy.api.v2.auth.Cert.CommonTlsContext DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new envoy.api.v2.auth.Cert.CommonTlsContext();
    }

    public static envoy.api.v2.auth.Cert.CommonTlsContext getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<CommonTlsContext>
        PARSER = new com.google.protobuf.AbstractParser<CommonTlsContext>() {
      public CommonTlsContext parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new CommonTlsContext(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<CommonTlsContext> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CommonTlsContext> getParserForType() {
      return PARSER;
    }

    public envoy.api.v2.auth.Cert.CommonTlsContext getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface UpstreamTlsContextOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.auth.UpstreamTlsContext)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Common TLS context settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
     */
    boolean hasCommonTlsContext();
    /**
     * <pre>
     * Common TLS context settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
     */
    envoy.api.v2.auth.Cert.CommonTlsContext getCommonTlsContext();
    /**
     * <pre>
     * Common TLS context settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
     */
    envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder getCommonTlsContextOrBuilder();

    /**
     * <pre>
     * SNI string to use when creating TLS backend connections.
     * </pre>
     *
     * <code>string sni = 2 [(.validate.rules) = { ... }</code>
     */
    java.lang.String getSni();
    /**
     * <pre>
     * SNI string to use when creating TLS backend connections.
     * </pre>
     *
     * <code>string sni = 2 [(.validate.rules) = { ... }</code>
     */
    com.google.protobuf.ByteString
        getSniBytes();

    /**
     * <pre>
     * If true, server-initiated TLS renegotiation will be allowed.
     * .. attention::
     *   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
     * </pre>
     *
     * <code>bool allow_renegotiation = 3;</code>
     */
    boolean getAllowRenegotiation();

    /**
     * <pre>
     * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
     * for TLSv1.2 and older) to store for the purpose of session resumption.
     * Defaults to 1, setting this to 0 disables session resumption.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
     */
    boolean hasMaxSessionKeys();
    /**
     * <pre>
     * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
     * for TLSv1.2 and older) to store for the purpose of session resumption.
     * Defaults to 1, setting this to 0 disables session resumption.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
     */
    com.google.protobuf.UInt32Value getMaxSessionKeys();
    /**
     * <pre>
     * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
     * for TLSv1.2 and older) to store for the purpose of session resumption.
     * Defaults to 1, setting this to 0 disables session resumption.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
     */
    com.google.protobuf.UInt32ValueOrBuilder getMaxSessionKeysOrBuilder();
  }
  /**
   * Protobuf type {@code envoy.api.v2.auth.UpstreamTlsContext}
   */
  public  static final class UpstreamTlsContext extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.auth.UpstreamTlsContext)
      UpstreamTlsContextOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use UpstreamTlsContext.newBuilder() to construct.
    private UpstreamTlsContext(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private UpstreamTlsContext() {
      sni_ = "";
      allowRenegotiation_ = false;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private UpstreamTlsContext(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              envoy.api.v2.auth.Cert.CommonTlsContext.Builder subBuilder = null;
              if (commonTlsContext_ != null) {
                subBuilder = commonTlsContext_.toBuilder();
              }
              commonTlsContext_ = input.readMessage(envoy.api.v2.auth.Cert.CommonTlsContext.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(commonTlsContext_);
                commonTlsContext_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              sni_ = s;
              break;
            }
            case 24: {

              allowRenegotiation_ = input.readBool();
              break;
            }
            case 34: {
              com.google.protobuf.UInt32Value.Builder subBuilder = null;
              if (maxSessionKeys_ != null) {
                subBuilder = maxSessionKeys_.toBuilder();
              }
              maxSessionKeys_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(maxSessionKeys_);
                maxSessionKeys_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_UpstreamTlsContext_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_UpstreamTlsContext_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              envoy.api.v2.auth.Cert.UpstreamTlsContext.class, envoy.api.v2.auth.Cert.UpstreamTlsContext.Builder.class);
    }

    public static final int COMMON_TLS_CONTEXT_FIELD_NUMBER = 1;
    private envoy.api.v2.auth.Cert.CommonTlsContext commonTlsContext_;
    /**
     * <pre>
     * Common TLS context settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
     */
    public boolean hasCommonTlsContext() {
      return commonTlsContext_ != null;
    }
    /**
     * <pre>
     * Common TLS context settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
     */
    public envoy.api.v2.auth.Cert.CommonTlsContext getCommonTlsContext() {
      return commonTlsContext_ == null ? envoy.api.v2.auth.Cert.CommonTlsContext.getDefaultInstance() : commonTlsContext_;
    }
    /**
     * <pre>
     * Common TLS context settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
     */
    public envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder getCommonTlsContextOrBuilder() {
      return getCommonTlsContext();
    }

    public static final int SNI_FIELD_NUMBER = 2;
    private volatile java.lang.Object sni_;
    /**
     * <pre>
     * SNI string to use when creating TLS backend connections.
     * </pre>
     *
     * <code>string sni = 2 [(.validate.rules) = { ... }</code>
     */
    public java.lang.String getSni() {
      java.lang.Object ref = sni_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        sni_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * SNI string to use when creating TLS backend connections.
     * </pre>
     *
     * <code>string sni = 2 [(.validate.rules) = { ... }</code>
     */
    public com.google.protobuf.ByteString
        getSniBytes() {
      java.lang.Object ref = sni_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        sni_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ALLOW_RENEGOTIATION_FIELD_NUMBER = 3;
    private boolean allowRenegotiation_;
    /**
     * <pre>
     * If true, server-initiated TLS renegotiation will be allowed.
     * .. attention::
     *   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
     * </pre>
     *
     * <code>bool allow_renegotiation = 3;</code>
     */
    public boolean getAllowRenegotiation() {
      return allowRenegotiation_;
    }

    public static final int MAX_SESSION_KEYS_FIELD_NUMBER = 4;
    private com.google.protobuf.UInt32Value maxSessionKeys_;
    /**
     * <pre>
     * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
     * for TLSv1.2 and older) to store for the purpose of session resumption.
     * Defaults to 1, setting this to 0 disables session resumption.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
     */
    public boolean hasMaxSessionKeys() {
      return maxSessionKeys_ != null;
    }
    /**
     * <pre>
     * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
     * for TLSv1.2 and older) to store for the purpose of session resumption.
     * Defaults to 1, setting this to 0 disables session resumption.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
     */
    public com.google.protobuf.UInt32Value getMaxSessionKeys() {
      return maxSessionKeys_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxSessionKeys_;
    }
    /**
     * <pre>
     * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
     * for TLSv1.2 and older) to store for the purpose of session resumption.
     * Defaults to 1, setting this to 0 disables session resumption.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getMaxSessionKeysOrBuilder() {
      return getMaxSessionKeys();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (commonTlsContext_ != null) {
        output.writeMessage(1, getCommonTlsContext());
      }
      if (!getSniBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, sni_);
      }
      if (allowRenegotiation_ != false) {
        output.writeBool(3, allowRenegotiation_);
      }
      if (maxSessionKeys_ != null) {
        output.writeMessage(4, getMaxSessionKeys());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (commonTlsContext_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getCommonTlsContext());
      }
      if (!getSniBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, sni_);
      }
      if (allowRenegotiation_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, allowRenegotiation_);
      }
      if (maxSessionKeys_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getMaxSessionKeys());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof envoy.api.v2.auth.Cert.UpstreamTlsContext)) {
        return super.equals(obj);
      }
      envoy.api.v2.auth.Cert.UpstreamTlsContext other = (envoy.api.v2.auth.Cert.UpstreamTlsContext) obj;

      boolean result = true;
      result = result && (hasCommonTlsContext() == other.hasCommonTlsContext());
      if (hasCommonTlsContext()) {
        result = result && getCommonTlsContext()
            .equals(other.getCommonTlsContext());
      }
      result = result && getSni()
          .equals(other.getSni());
      result = result && (getAllowRenegotiation()
          == other.getAllowRenegotiation());
      result = result && (hasMaxSessionKeys() == other.hasMaxSessionKeys());
      if (hasMaxSessionKeys()) {
        result = result && getMaxSessionKeys()
            .equals(other.getMaxSessionKeys());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCommonTlsContext()) {
        hash = (37 * hash) + COMMON_TLS_CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + getCommonTlsContext().hashCode();
      }
      hash = (37 * hash) + SNI_FIELD_NUMBER;
      hash = (53 * hash) + getSni().hashCode();
      hash = (37 * hash) + ALLOW_RENEGOTIATION_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getAllowRenegotiation());
      if (hasMaxSessionKeys()) {
        hash = (37 * hash) + MAX_SESSION_KEYS_FIELD_NUMBER;
        hash = (53 * hash) + getMaxSessionKeys().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static envoy.api.v2.auth.Cert.UpstreamTlsContext parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.UpstreamTlsContext parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.UpstreamTlsContext parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.UpstreamTlsContext parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.UpstreamTlsContext parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.UpstreamTlsContext parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.UpstreamTlsContext parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.UpstreamTlsContext parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.UpstreamTlsContext parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.UpstreamTlsContext parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.UpstreamTlsContext parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.UpstreamTlsContext parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(envoy.api.v2.auth.Cert.UpstreamTlsContext prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code envoy.api.v2.auth.UpstreamTlsContext}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.auth.UpstreamTlsContext)
        envoy.api.v2.auth.Cert.UpstreamTlsContextOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_UpstreamTlsContext_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_UpstreamTlsContext_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                envoy.api.v2.auth.Cert.UpstreamTlsContext.class, envoy.api.v2.auth.Cert.UpstreamTlsContext.Builder.class);
      }

      // Construct using envoy.api.v2.auth.Cert.UpstreamTlsContext.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (commonTlsContextBuilder_ == null) {
          commonTlsContext_ = null;
        } else {
          commonTlsContext_ = null;
          commonTlsContextBuilder_ = null;
        }
        sni_ = "";

        allowRenegotiation_ = false;

        if (maxSessionKeysBuilder_ == null) {
          maxSessionKeys_ = null;
        } else {
          maxSessionKeys_ = null;
          maxSessionKeysBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_UpstreamTlsContext_descriptor;
      }

      public envoy.api.v2.auth.Cert.UpstreamTlsContext getDefaultInstanceForType() {
        return envoy.api.v2.auth.Cert.UpstreamTlsContext.getDefaultInstance();
      }

      public envoy.api.v2.auth.Cert.UpstreamTlsContext build() {
        envoy.api.v2.auth.Cert.UpstreamTlsContext result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public envoy.api.v2.auth.Cert.UpstreamTlsContext buildPartial() {
        envoy.api.v2.auth.Cert.UpstreamTlsContext result = new envoy.api.v2.auth.Cert.UpstreamTlsContext(this);
        if (commonTlsContextBuilder_ == null) {
          result.commonTlsContext_ = commonTlsContext_;
        } else {
          result.commonTlsContext_ = commonTlsContextBuilder_.build();
        }
        result.sni_ = sni_;
        result.allowRenegotiation_ = allowRenegotiation_;
        if (maxSessionKeysBuilder_ == null) {
          result.maxSessionKeys_ = maxSessionKeys_;
        } else {
          result.maxSessionKeys_ = maxSessionKeysBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof envoy.api.v2.auth.Cert.UpstreamTlsContext) {
          return mergeFrom((envoy.api.v2.auth.Cert.UpstreamTlsContext)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(envoy.api.v2.auth.Cert.UpstreamTlsContext other) {
        if (other == envoy.api.v2.auth.Cert.UpstreamTlsContext.getDefaultInstance()) return this;
        if (other.hasCommonTlsContext()) {
          mergeCommonTlsContext(other.getCommonTlsContext());
        }
        if (!other.getSni().isEmpty()) {
          sni_ = other.sni_;
          onChanged();
        }
        if (other.getAllowRenegotiation() != false) {
          setAllowRenegotiation(other.getAllowRenegotiation());
        }
        if (other.hasMaxSessionKeys()) {
          mergeMaxSessionKeys(other.getMaxSessionKeys());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        envoy.api.v2.auth.Cert.UpstreamTlsContext parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (envoy.api.v2.auth.Cert.UpstreamTlsContext) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private envoy.api.v2.auth.Cert.CommonTlsContext commonTlsContext_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.CommonTlsContext, envoy.api.v2.auth.Cert.CommonTlsContext.Builder, envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder> commonTlsContextBuilder_;
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public boolean hasCommonTlsContext() {
        return commonTlsContextBuilder_ != null || commonTlsContext_ != null;
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public envoy.api.v2.auth.Cert.CommonTlsContext getCommonTlsContext() {
        if (commonTlsContextBuilder_ == null) {
          return commonTlsContext_ == null ? envoy.api.v2.auth.Cert.CommonTlsContext.getDefaultInstance() : commonTlsContext_;
        } else {
          return commonTlsContextBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public Builder setCommonTlsContext(envoy.api.v2.auth.Cert.CommonTlsContext value) {
        if (commonTlsContextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          commonTlsContext_ = value;
          onChanged();
        } else {
          commonTlsContextBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public Builder setCommonTlsContext(
          envoy.api.v2.auth.Cert.CommonTlsContext.Builder builderForValue) {
        if (commonTlsContextBuilder_ == null) {
          commonTlsContext_ = builderForValue.build();
          onChanged();
        } else {
          commonTlsContextBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public Builder mergeCommonTlsContext(envoy.api.v2.auth.Cert.CommonTlsContext value) {
        if (commonTlsContextBuilder_ == null) {
          if (commonTlsContext_ != null) {
            commonTlsContext_ =
              envoy.api.v2.auth.Cert.CommonTlsContext.newBuilder(commonTlsContext_).mergeFrom(value).buildPartial();
          } else {
            commonTlsContext_ = value;
          }
          onChanged();
        } else {
          commonTlsContextBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public Builder clearCommonTlsContext() {
        if (commonTlsContextBuilder_ == null) {
          commonTlsContext_ = null;
          onChanged();
        } else {
          commonTlsContext_ = null;
          commonTlsContextBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public envoy.api.v2.auth.Cert.CommonTlsContext.Builder getCommonTlsContextBuilder() {
        
        onChanged();
        return getCommonTlsContextFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder getCommonTlsContextOrBuilder() {
        if (commonTlsContextBuilder_ != null) {
          return commonTlsContextBuilder_.getMessageOrBuilder();
        } else {
          return commonTlsContext_ == null ?
              envoy.api.v2.auth.Cert.CommonTlsContext.getDefaultInstance() : commonTlsContext_;
        }
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.CommonTlsContext, envoy.api.v2.auth.Cert.CommonTlsContext.Builder, envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder> 
          getCommonTlsContextFieldBuilder() {
        if (commonTlsContextBuilder_ == null) {
          commonTlsContextBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.auth.Cert.CommonTlsContext, envoy.api.v2.auth.Cert.CommonTlsContext.Builder, envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder>(
                  getCommonTlsContext(),
                  getParentForChildren(),
                  isClean());
          commonTlsContext_ = null;
        }
        return commonTlsContextBuilder_;
      }

      private java.lang.Object sni_ = "";
      /**
       * <pre>
       * SNI string to use when creating TLS backend connections.
       * </pre>
       *
       * <code>string sni = 2 [(.validate.rules) = { ... }</code>
       */
      public java.lang.String getSni() {
        java.lang.Object ref = sni_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          sni_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * SNI string to use when creating TLS backend connections.
       * </pre>
       *
       * <code>string sni = 2 [(.validate.rules) = { ... }</code>
       */
      public com.google.protobuf.ByteString
          getSniBytes() {
        java.lang.Object ref = sni_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          sni_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * SNI string to use when creating TLS backend connections.
       * </pre>
       *
       * <code>string sni = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder setSni(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        sni_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SNI string to use when creating TLS backend connections.
       * </pre>
       *
       * <code>string sni = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder clearSni() {
        
        sni_ = getDefaultInstance().getSni();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * SNI string to use when creating TLS backend connections.
       * </pre>
       *
       * <code>string sni = 2 [(.validate.rules) = { ... }</code>
       */
      public Builder setSniBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        sni_ = value;
        onChanged();
        return this;
      }

      private boolean allowRenegotiation_ ;
      /**
       * <pre>
       * If true, server-initiated TLS renegotiation will be allowed.
       * .. attention::
       *   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
       * </pre>
       *
       * <code>bool allow_renegotiation = 3;</code>
       */
      public boolean getAllowRenegotiation() {
        return allowRenegotiation_;
      }
      /**
       * <pre>
       * If true, server-initiated TLS renegotiation will be allowed.
       * .. attention::
       *   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
       * </pre>
       *
       * <code>bool allow_renegotiation = 3;</code>
       */
      public Builder setAllowRenegotiation(boolean value) {
        
        allowRenegotiation_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, server-initiated TLS renegotiation will be allowed.
       * .. attention::
       *   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
       * </pre>
       *
       * <code>bool allow_renegotiation = 3;</code>
       */
      public Builder clearAllowRenegotiation() {
        
        allowRenegotiation_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.UInt32Value maxSessionKeys_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> maxSessionKeysBuilder_;
      /**
       * <pre>
       * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
       * for TLSv1.2 and older) to store for the purpose of session resumption.
       * Defaults to 1, setting this to 0 disables session resumption.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
       */
      public boolean hasMaxSessionKeys() {
        return maxSessionKeysBuilder_ != null || maxSessionKeys_ != null;
      }
      /**
       * <pre>
       * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
       * for TLSv1.2 and older) to store for the purpose of session resumption.
       * Defaults to 1, setting this to 0 disables session resumption.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
       */
      public com.google.protobuf.UInt32Value getMaxSessionKeys() {
        if (maxSessionKeysBuilder_ == null) {
          return maxSessionKeys_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxSessionKeys_;
        } else {
          return maxSessionKeysBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
       * for TLSv1.2 and older) to store for the purpose of session resumption.
       * Defaults to 1, setting this to 0 disables session resumption.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
       */
      public Builder setMaxSessionKeys(com.google.protobuf.UInt32Value value) {
        if (maxSessionKeysBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxSessionKeys_ = value;
          onChanged();
        } else {
          maxSessionKeysBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
       * for TLSv1.2 and older) to store for the purpose of session resumption.
       * Defaults to 1, setting this to 0 disables session resumption.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
       */
      public Builder setMaxSessionKeys(
          com.google.protobuf.UInt32Value.Builder builderForValue) {
        if (maxSessionKeysBuilder_ == null) {
          maxSessionKeys_ = builderForValue.build();
          onChanged();
        } else {
          maxSessionKeysBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
       * for TLSv1.2 and older) to store for the purpose of session resumption.
       * Defaults to 1, setting this to 0 disables session resumption.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
       */
      public Builder mergeMaxSessionKeys(com.google.protobuf.UInt32Value value) {
        if (maxSessionKeysBuilder_ == null) {
          if (maxSessionKeys_ != null) {
            maxSessionKeys_ =
              com.google.protobuf.UInt32Value.newBuilder(maxSessionKeys_).mergeFrom(value).buildPartial();
          } else {
            maxSessionKeys_ = value;
          }
          onChanged();
        } else {
          maxSessionKeysBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
       * for TLSv1.2 and older) to store for the purpose of session resumption.
       * Defaults to 1, setting this to 0 disables session resumption.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
       */
      public Builder clearMaxSessionKeys() {
        if (maxSessionKeysBuilder_ == null) {
          maxSessionKeys_ = null;
          onChanged();
        } else {
          maxSessionKeys_ = null;
          maxSessionKeysBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
       * for TLSv1.2 and older) to store for the purpose of session resumption.
       * Defaults to 1, setting this to 0 disables session resumption.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
       */
      public com.google.protobuf.UInt32Value.Builder getMaxSessionKeysBuilder() {
        
        onChanged();
        return getMaxSessionKeysFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
       * for TLSv1.2 and older) to store for the purpose of session resumption.
       * Defaults to 1, setting this to 0 disables session resumption.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
       */
      public com.google.protobuf.UInt32ValueOrBuilder getMaxSessionKeysOrBuilder() {
        if (maxSessionKeysBuilder_ != null) {
          return maxSessionKeysBuilder_.getMessageOrBuilder();
        } else {
          return maxSessionKeys_ == null ?
              com.google.protobuf.UInt32Value.getDefaultInstance() : maxSessionKeys_;
        }
      }
      /**
       * <pre>
       * Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
       * for TLSv1.2 and older) to store for the purpose of session resumption.
       * Defaults to 1, setting this to 0 disables session resumption.
       * </pre>
       *
       * <code>.google.protobuf.UInt32Value max_session_keys = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
          getMaxSessionKeysFieldBuilder() {
        if (maxSessionKeysBuilder_ == null) {
          maxSessionKeysBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                  getMaxSessionKeys(),
                  getParentForChildren(),
                  isClean());
          maxSessionKeys_ = null;
        }
        return maxSessionKeysBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.auth.UpstreamTlsContext)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.auth.UpstreamTlsContext)
    private static final envoy.api.v2.auth.Cert.UpstreamTlsContext DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new envoy.api.v2.auth.Cert.UpstreamTlsContext();
    }

    public static envoy.api.v2.auth.Cert.UpstreamTlsContext getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<UpstreamTlsContext>
        PARSER = new com.google.protobuf.AbstractParser<UpstreamTlsContext>() {
      public UpstreamTlsContext parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new UpstreamTlsContext(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<UpstreamTlsContext> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<UpstreamTlsContext> getParserForType() {
      return PARSER;
    }

    public envoy.api.v2.auth.Cert.UpstreamTlsContext getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DownstreamTlsContextOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.auth.DownstreamTlsContext)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Common TLS context settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
     */
    boolean hasCommonTlsContext();
    /**
     * <pre>
     * Common TLS context settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
     */
    envoy.api.v2.auth.Cert.CommonTlsContext getCommonTlsContext();
    /**
     * <pre>
     * Common TLS context settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
     */
    envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder getCommonTlsContextOrBuilder();

    /**
     * <pre>
     * If specified, Envoy will reject connections without a valid client
     * certificate.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
     */
    boolean hasRequireClientCertificate();
    /**
     * <pre>
     * If specified, Envoy will reject connections without a valid client
     * certificate.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
     */
    com.google.protobuf.BoolValue getRequireClientCertificate();
    /**
     * <pre>
     * If specified, Envoy will reject connections without a valid client
     * certificate.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
     */
    com.google.protobuf.BoolValueOrBuilder getRequireClientCertificateOrBuilder();

    /**
     * <pre>
     * If specified, Envoy will reject connections without a valid and matching SNI.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_sni = 3;</code>
     */
    boolean hasRequireSni();
    /**
     * <pre>
     * If specified, Envoy will reject connections without a valid and matching SNI.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_sni = 3;</code>
     */
    com.google.protobuf.BoolValue getRequireSni();
    /**
     * <pre>
     * If specified, Envoy will reject connections without a valid and matching SNI.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_sni = 3;</code>
     */
    com.google.protobuf.BoolValueOrBuilder getRequireSniOrBuilder();

    /**
     * <pre>
     * TLS session ticket key settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
     */
    boolean hasSessionTicketKeys();
    /**
     * <pre>
     * TLS session ticket key settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
     */
    envoy.api.v2.auth.Cert.TlsSessionTicketKeys getSessionTicketKeys();
    /**
     * <pre>
     * TLS session ticket key settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
     */
    envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder getSessionTicketKeysOrBuilder();

    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
     */
    boolean hasSessionTicketKeysSdsSecretConfig();
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
     */
    envoy.api.v2.auth.Cert.SdsSecretConfig getSessionTicketKeysSdsSecretConfig();
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
     */
    envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder getSessionTicketKeysSdsSecretConfigOrBuilder();

    public envoy.api.v2.auth.Cert.DownstreamTlsContext.SessionTicketKeysTypeCase getSessionTicketKeysTypeCase();
  }
  /**
   * Protobuf type {@code envoy.api.v2.auth.DownstreamTlsContext}
   */
  public  static final class DownstreamTlsContext extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.auth.DownstreamTlsContext)
      DownstreamTlsContextOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DownstreamTlsContext.newBuilder() to construct.
    private DownstreamTlsContext(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DownstreamTlsContext() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DownstreamTlsContext(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              envoy.api.v2.auth.Cert.CommonTlsContext.Builder subBuilder = null;
              if (commonTlsContext_ != null) {
                subBuilder = commonTlsContext_.toBuilder();
              }
              commonTlsContext_ = input.readMessage(envoy.api.v2.auth.Cert.CommonTlsContext.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(commonTlsContext_);
                commonTlsContext_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {
              com.google.protobuf.BoolValue.Builder subBuilder = null;
              if (requireClientCertificate_ != null) {
                subBuilder = requireClientCertificate_.toBuilder();
              }
              requireClientCertificate_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(requireClientCertificate_);
                requireClientCertificate_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              com.google.protobuf.BoolValue.Builder subBuilder = null;
              if (requireSni_ != null) {
                subBuilder = requireSni_.toBuilder();
              }
              requireSni_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(requireSni_);
                requireSni_ = subBuilder.buildPartial();
              }

              break;
            }
            case 34: {
              envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder subBuilder = null;
              if (sessionTicketKeysTypeCase_ == 4) {
                subBuilder = ((envoy.api.v2.auth.Cert.TlsSessionTicketKeys) sessionTicketKeysType_).toBuilder();
              }
              sessionTicketKeysType_ =
                  input.readMessage(envoy.api.v2.auth.Cert.TlsSessionTicketKeys.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((envoy.api.v2.auth.Cert.TlsSessionTicketKeys) sessionTicketKeysType_);
                sessionTicketKeysType_ = subBuilder.buildPartial();
              }
              sessionTicketKeysTypeCase_ = 4;
              break;
            }
            case 42: {
              envoy.api.v2.auth.Cert.SdsSecretConfig.Builder subBuilder = null;
              if (sessionTicketKeysTypeCase_ == 5) {
                subBuilder = ((envoy.api.v2.auth.Cert.SdsSecretConfig) sessionTicketKeysType_).toBuilder();
              }
              sessionTicketKeysType_ =
                  input.readMessage(envoy.api.v2.auth.Cert.SdsSecretConfig.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((envoy.api.v2.auth.Cert.SdsSecretConfig) sessionTicketKeysType_);
                sessionTicketKeysType_ = subBuilder.buildPartial();
              }
              sessionTicketKeysTypeCase_ = 5;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_DownstreamTlsContext_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_DownstreamTlsContext_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              envoy.api.v2.auth.Cert.DownstreamTlsContext.class, envoy.api.v2.auth.Cert.DownstreamTlsContext.Builder.class);
    }

    private int sessionTicketKeysTypeCase_ = 0;
    private java.lang.Object sessionTicketKeysType_;
    public enum SessionTicketKeysTypeCase
        implements com.google.protobuf.Internal.EnumLite {
      SESSION_TICKET_KEYS(4),
      SESSION_TICKET_KEYS_SDS_SECRET_CONFIG(5),
      SESSIONTICKETKEYSTYPE_NOT_SET(0);
      private final int value;
      private SessionTicketKeysTypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SessionTicketKeysTypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static SessionTicketKeysTypeCase forNumber(int value) {
        switch (value) {
          case 4: return SESSION_TICKET_KEYS;
          case 5: return SESSION_TICKET_KEYS_SDS_SECRET_CONFIG;
          case 0: return SESSIONTICKETKEYSTYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public SessionTicketKeysTypeCase
    getSessionTicketKeysTypeCase() {
      return SessionTicketKeysTypeCase.forNumber(
          sessionTicketKeysTypeCase_);
    }

    public static final int COMMON_TLS_CONTEXT_FIELD_NUMBER = 1;
    private envoy.api.v2.auth.Cert.CommonTlsContext commonTlsContext_;
    /**
     * <pre>
     * Common TLS context settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
     */
    public boolean hasCommonTlsContext() {
      return commonTlsContext_ != null;
    }
    /**
     * <pre>
     * Common TLS context settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
     */
    public envoy.api.v2.auth.Cert.CommonTlsContext getCommonTlsContext() {
      return commonTlsContext_ == null ? envoy.api.v2.auth.Cert.CommonTlsContext.getDefaultInstance() : commonTlsContext_;
    }
    /**
     * <pre>
     * Common TLS context settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
     */
    public envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder getCommonTlsContextOrBuilder() {
      return getCommonTlsContext();
    }

    public static final int REQUIRE_CLIENT_CERTIFICATE_FIELD_NUMBER = 2;
    private com.google.protobuf.BoolValue requireClientCertificate_;
    /**
     * <pre>
     * If specified, Envoy will reject connections without a valid client
     * certificate.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
     */
    public boolean hasRequireClientCertificate() {
      return requireClientCertificate_ != null;
    }
    /**
     * <pre>
     * If specified, Envoy will reject connections without a valid client
     * certificate.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
     */
    public com.google.protobuf.BoolValue getRequireClientCertificate() {
      return requireClientCertificate_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : requireClientCertificate_;
    }
    /**
     * <pre>
     * If specified, Envoy will reject connections without a valid client
     * certificate.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getRequireClientCertificateOrBuilder() {
      return getRequireClientCertificate();
    }

    public static final int REQUIRE_SNI_FIELD_NUMBER = 3;
    private com.google.protobuf.BoolValue requireSni_;
    /**
     * <pre>
     * If specified, Envoy will reject connections without a valid and matching SNI.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_sni = 3;</code>
     */
    public boolean hasRequireSni() {
      return requireSni_ != null;
    }
    /**
     * <pre>
     * If specified, Envoy will reject connections without a valid and matching SNI.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_sni = 3;</code>
     */
    public com.google.protobuf.BoolValue getRequireSni() {
      return requireSni_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : requireSni_;
    }
    /**
     * <pre>
     * If specified, Envoy will reject connections without a valid and matching SNI.
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.google.protobuf.BoolValue require_sni = 3;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getRequireSniOrBuilder() {
      return getRequireSni();
    }

    public static final int SESSION_TICKET_KEYS_FIELD_NUMBER = 4;
    /**
     * <pre>
     * TLS session ticket key settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
     */
    public boolean hasSessionTicketKeys() {
      return sessionTicketKeysTypeCase_ == 4;
    }
    /**
     * <pre>
     * TLS session ticket key settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
     */
    public envoy.api.v2.auth.Cert.TlsSessionTicketKeys getSessionTicketKeys() {
      if (sessionTicketKeysTypeCase_ == 4) {
         return (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) sessionTicketKeysType_;
      }
      return envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
    }
    /**
     * <pre>
     * TLS session ticket key settings.
     * </pre>
     *
     * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
     */
    public envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder getSessionTicketKeysOrBuilder() {
      if (sessionTicketKeysTypeCase_ == 4) {
         return (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) sessionTicketKeysType_;
      }
      return envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
    }

    public static final int SESSION_TICKET_KEYS_SDS_SECRET_CONFIG_FIELD_NUMBER = 5;
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
     */
    public boolean hasSessionTicketKeysSdsSecretConfig() {
      return sessionTicketKeysTypeCase_ == 5;
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
     */
    public envoy.api.v2.auth.Cert.SdsSecretConfig getSessionTicketKeysSdsSecretConfig() {
      if (sessionTicketKeysTypeCase_ == 5) {
         return (envoy.api.v2.auth.Cert.SdsSecretConfig) sessionTicketKeysType_;
      }
      return envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
    }
    /**
     * <pre>
     * [#not-implemented-hide:]
     * </pre>
     *
     * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
     */
    public envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder getSessionTicketKeysSdsSecretConfigOrBuilder() {
      if (sessionTicketKeysTypeCase_ == 5) {
         return (envoy.api.v2.auth.Cert.SdsSecretConfig) sessionTicketKeysType_;
      }
      return envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (commonTlsContext_ != null) {
        output.writeMessage(1, getCommonTlsContext());
      }
      if (requireClientCertificate_ != null) {
        output.writeMessage(2, getRequireClientCertificate());
      }
      if (requireSni_ != null) {
        output.writeMessage(3, getRequireSni());
      }
      if (sessionTicketKeysTypeCase_ == 4) {
        output.writeMessage(4, (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) sessionTicketKeysType_);
      }
      if (sessionTicketKeysTypeCase_ == 5) {
        output.writeMessage(5, (envoy.api.v2.auth.Cert.SdsSecretConfig) sessionTicketKeysType_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (commonTlsContext_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getCommonTlsContext());
      }
      if (requireClientCertificate_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getRequireClientCertificate());
      }
      if (requireSni_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getRequireSni());
      }
      if (sessionTicketKeysTypeCase_ == 4) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) sessionTicketKeysType_);
      }
      if (sessionTicketKeysTypeCase_ == 5) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, (envoy.api.v2.auth.Cert.SdsSecretConfig) sessionTicketKeysType_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof envoy.api.v2.auth.Cert.DownstreamTlsContext)) {
        return super.equals(obj);
      }
      envoy.api.v2.auth.Cert.DownstreamTlsContext other = (envoy.api.v2.auth.Cert.DownstreamTlsContext) obj;

      boolean result = true;
      result = result && (hasCommonTlsContext() == other.hasCommonTlsContext());
      if (hasCommonTlsContext()) {
        result = result && getCommonTlsContext()
            .equals(other.getCommonTlsContext());
      }
      result = result && (hasRequireClientCertificate() == other.hasRequireClientCertificate());
      if (hasRequireClientCertificate()) {
        result = result && getRequireClientCertificate()
            .equals(other.getRequireClientCertificate());
      }
      result = result && (hasRequireSni() == other.hasRequireSni());
      if (hasRequireSni()) {
        result = result && getRequireSni()
            .equals(other.getRequireSni());
      }
      result = result && getSessionTicketKeysTypeCase().equals(
          other.getSessionTicketKeysTypeCase());
      if (!result) return false;
      switch (sessionTicketKeysTypeCase_) {
        case 4:
          result = result && getSessionTicketKeys()
              .equals(other.getSessionTicketKeys());
          break;
        case 5:
          result = result && getSessionTicketKeysSdsSecretConfig()
              .equals(other.getSessionTicketKeysSdsSecretConfig());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCommonTlsContext()) {
        hash = (37 * hash) + COMMON_TLS_CONTEXT_FIELD_NUMBER;
        hash = (53 * hash) + getCommonTlsContext().hashCode();
      }
      if (hasRequireClientCertificate()) {
        hash = (37 * hash) + REQUIRE_CLIENT_CERTIFICATE_FIELD_NUMBER;
        hash = (53 * hash) + getRequireClientCertificate().hashCode();
      }
      if (hasRequireSni()) {
        hash = (37 * hash) + REQUIRE_SNI_FIELD_NUMBER;
        hash = (53 * hash) + getRequireSni().hashCode();
      }
      switch (sessionTicketKeysTypeCase_) {
        case 4:
          hash = (37 * hash) + SESSION_TICKET_KEYS_FIELD_NUMBER;
          hash = (53 * hash) + getSessionTicketKeys().hashCode();
          break;
        case 5:
          hash = (37 * hash) + SESSION_TICKET_KEYS_SDS_SECRET_CONFIG_FIELD_NUMBER;
          hash = (53 * hash) + getSessionTicketKeysSdsSecretConfig().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static envoy.api.v2.auth.Cert.DownstreamTlsContext parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.DownstreamTlsContext parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.DownstreamTlsContext parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.DownstreamTlsContext parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.DownstreamTlsContext parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.DownstreamTlsContext parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.DownstreamTlsContext parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.DownstreamTlsContext parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.DownstreamTlsContext parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.DownstreamTlsContext parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.DownstreamTlsContext parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.DownstreamTlsContext parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(envoy.api.v2.auth.Cert.DownstreamTlsContext prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code envoy.api.v2.auth.DownstreamTlsContext}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.auth.DownstreamTlsContext)
        envoy.api.v2.auth.Cert.DownstreamTlsContextOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_DownstreamTlsContext_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_DownstreamTlsContext_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                envoy.api.v2.auth.Cert.DownstreamTlsContext.class, envoy.api.v2.auth.Cert.DownstreamTlsContext.Builder.class);
      }

      // Construct using envoy.api.v2.auth.Cert.DownstreamTlsContext.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        if (commonTlsContextBuilder_ == null) {
          commonTlsContext_ = null;
        } else {
          commonTlsContext_ = null;
          commonTlsContextBuilder_ = null;
        }
        if (requireClientCertificateBuilder_ == null) {
          requireClientCertificate_ = null;
        } else {
          requireClientCertificate_ = null;
          requireClientCertificateBuilder_ = null;
        }
        if (requireSniBuilder_ == null) {
          requireSni_ = null;
        } else {
          requireSni_ = null;
          requireSniBuilder_ = null;
        }
        sessionTicketKeysTypeCase_ = 0;
        sessionTicketKeysType_ = null;
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_DownstreamTlsContext_descriptor;
      }

      public envoy.api.v2.auth.Cert.DownstreamTlsContext getDefaultInstanceForType() {
        return envoy.api.v2.auth.Cert.DownstreamTlsContext.getDefaultInstance();
      }

      public envoy.api.v2.auth.Cert.DownstreamTlsContext build() {
        envoy.api.v2.auth.Cert.DownstreamTlsContext result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public envoy.api.v2.auth.Cert.DownstreamTlsContext buildPartial() {
        envoy.api.v2.auth.Cert.DownstreamTlsContext result = new envoy.api.v2.auth.Cert.DownstreamTlsContext(this);
        if (commonTlsContextBuilder_ == null) {
          result.commonTlsContext_ = commonTlsContext_;
        } else {
          result.commonTlsContext_ = commonTlsContextBuilder_.build();
        }
        if (requireClientCertificateBuilder_ == null) {
          result.requireClientCertificate_ = requireClientCertificate_;
        } else {
          result.requireClientCertificate_ = requireClientCertificateBuilder_.build();
        }
        if (requireSniBuilder_ == null) {
          result.requireSni_ = requireSni_;
        } else {
          result.requireSni_ = requireSniBuilder_.build();
        }
        if (sessionTicketKeysTypeCase_ == 4) {
          if (sessionTicketKeysBuilder_ == null) {
            result.sessionTicketKeysType_ = sessionTicketKeysType_;
          } else {
            result.sessionTicketKeysType_ = sessionTicketKeysBuilder_.build();
          }
        }
        if (sessionTicketKeysTypeCase_ == 5) {
          if (sessionTicketKeysSdsSecretConfigBuilder_ == null) {
            result.sessionTicketKeysType_ = sessionTicketKeysType_;
          } else {
            result.sessionTicketKeysType_ = sessionTicketKeysSdsSecretConfigBuilder_.build();
          }
        }
        result.sessionTicketKeysTypeCase_ = sessionTicketKeysTypeCase_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof envoy.api.v2.auth.Cert.DownstreamTlsContext) {
          return mergeFrom((envoy.api.v2.auth.Cert.DownstreamTlsContext)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(envoy.api.v2.auth.Cert.DownstreamTlsContext other) {
        if (other == envoy.api.v2.auth.Cert.DownstreamTlsContext.getDefaultInstance()) return this;
        if (other.hasCommonTlsContext()) {
          mergeCommonTlsContext(other.getCommonTlsContext());
        }
        if (other.hasRequireClientCertificate()) {
          mergeRequireClientCertificate(other.getRequireClientCertificate());
        }
        if (other.hasRequireSni()) {
          mergeRequireSni(other.getRequireSni());
        }
        switch (other.getSessionTicketKeysTypeCase()) {
          case SESSION_TICKET_KEYS: {
            mergeSessionTicketKeys(other.getSessionTicketKeys());
            break;
          }
          case SESSION_TICKET_KEYS_SDS_SECRET_CONFIG: {
            mergeSessionTicketKeysSdsSecretConfig(other.getSessionTicketKeysSdsSecretConfig());
            break;
          }
          case SESSIONTICKETKEYSTYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        envoy.api.v2.auth.Cert.DownstreamTlsContext parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (envoy.api.v2.auth.Cert.DownstreamTlsContext) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int sessionTicketKeysTypeCase_ = 0;
      private java.lang.Object sessionTicketKeysType_;
      public SessionTicketKeysTypeCase
          getSessionTicketKeysTypeCase() {
        return SessionTicketKeysTypeCase.forNumber(
            sessionTicketKeysTypeCase_);
      }

      public Builder clearSessionTicketKeysType() {
        sessionTicketKeysTypeCase_ = 0;
        sessionTicketKeysType_ = null;
        onChanged();
        return this;
      }


      private envoy.api.v2.auth.Cert.CommonTlsContext commonTlsContext_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.CommonTlsContext, envoy.api.v2.auth.Cert.CommonTlsContext.Builder, envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder> commonTlsContextBuilder_;
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public boolean hasCommonTlsContext() {
        return commonTlsContextBuilder_ != null || commonTlsContext_ != null;
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public envoy.api.v2.auth.Cert.CommonTlsContext getCommonTlsContext() {
        if (commonTlsContextBuilder_ == null) {
          return commonTlsContext_ == null ? envoy.api.v2.auth.Cert.CommonTlsContext.getDefaultInstance() : commonTlsContext_;
        } else {
          return commonTlsContextBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public Builder setCommonTlsContext(envoy.api.v2.auth.Cert.CommonTlsContext value) {
        if (commonTlsContextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          commonTlsContext_ = value;
          onChanged();
        } else {
          commonTlsContextBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public Builder setCommonTlsContext(
          envoy.api.v2.auth.Cert.CommonTlsContext.Builder builderForValue) {
        if (commonTlsContextBuilder_ == null) {
          commonTlsContext_ = builderForValue.build();
          onChanged();
        } else {
          commonTlsContextBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public Builder mergeCommonTlsContext(envoy.api.v2.auth.Cert.CommonTlsContext value) {
        if (commonTlsContextBuilder_ == null) {
          if (commonTlsContext_ != null) {
            commonTlsContext_ =
              envoy.api.v2.auth.Cert.CommonTlsContext.newBuilder(commonTlsContext_).mergeFrom(value).buildPartial();
          } else {
            commonTlsContext_ = value;
          }
          onChanged();
        } else {
          commonTlsContextBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public Builder clearCommonTlsContext() {
        if (commonTlsContextBuilder_ == null) {
          commonTlsContext_ = null;
          onChanged();
        } else {
          commonTlsContext_ = null;
          commonTlsContextBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public envoy.api.v2.auth.Cert.CommonTlsContext.Builder getCommonTlsContextBuilder() {
        
        onChanged();
        return getCommonTlsContextFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      public envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder getCommonTlsContextOrBuilder() {
        if (commonTlsContextBuilder_ != null) {
          return commonTlsContextBuilder_.getMessageOrBuilder();
        } else {
          return commonTlsContext_ == null ?
              envoy.api.v2.auth.Cert.CommonTlsContext.getDefaultInstance() : commonTlsContext_;
        }
      }
      /**
       * <pre>
       * Common TLS context settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.CommonTlsContext common_tls_context = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.CommonTlsContext, envoy.api.v2.auth.Cert.CommonTlsContext.Builder, envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder> 
          getCommonTlsContextFieldBuilder() {
        if (commonTlsContextBuilder_ == null) {
          commonTlsContextBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.auth.Cert.CommonTlsContext, envoy.api.v2.auth.Cert.CommonTlsContext.Builder, envoy.api.v2.auth.Cert.CommonTlsContextOrBuilder>(
                  getCommonTlsContext(),
                  getParentForChildren(),
                  isClean());
          commonTlsContext_ = null;
        }
        return commonTlsContextBuilder_;
      }

      private com.google.protobuf.BoolValue requireClientCertificate_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> requireClientCertificateBuilder_;
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid client
       * certificate.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
       */
      public boolean hasRequireClientCertificate() {
        return requireClientCertificateBuilder_ != null || requireClientCertificate_ != null;
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid client
       * certificate.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
       */
      public com.google.protobuf.BoolValue getRequireClientCertificate() {
        if (requireClientCertificateBuilder_ == null) {
          return requireClientCertificate_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : requireClientCertificate_;
        } else {
          return requireClientCertificateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid client
       * certificate.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
       */
      public Builder setRequireClientCertificate(com.google.protobuf.BoolValue value) {
        if (requireClientCertificateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          requireClientCertificate_ = value;
          onChanged();
        } else {
          requireClientCertificateBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid client
       * certificate.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
       */
      public Builder setRequireClientCertificate(
          com.google.protobuf.BoolValue.Builder builderForValue) {
        if (requireClientCertificateBuilder_ == null) {
          requireClientCertificate_ = builderForValue.build();
          onChanged();
        } else {
          requireClientCertificateBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid client
       * certificate.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
       */
      public Builder mergeRequireClientCertificate(com.google.protobuf.BoolValue value) {
        if (requireClientCertificateBuilder_ == null) {
          if (requireClientCertificate_ != null) {
            requireClientCertificate_ =
              com.google.protobuf.BoolValue.newBuilder(requireClientCertificate_).mergeFrom(value).buildPartial();
          } else {
            requireClientCertificate_ = value;
          }
          onChanged();
        } else {
          requireClientCertificateBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid client
       * certificate.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
       */
      public Builder clearRequireClientCertificate() {
        if (requireClientCertificateBuilder_ == null) {
          requireClientCertificate_ = null;
          onChanged();
        } else {
          requireClientCertificate_ = null;
          requireClientCertificateBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid client
       * certificate.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
       */
      public com.google.protobuf.BoolValue.Builder getRequireClientCertificateBuilder() {
        
        onChanged();
        return getRequireClientCertificateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid client
       * certificate.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
       */
      public com.google.protobuf.BoolValueOrBuilder getRequireClientCertificateOrBuilder() {
        if (requireClientCertificateBuilder_ != null) {
          return requireClientCertificateBuilder_.getMessageOrBuilder();
        } else {
          return requireClientCertificate_ == null ?
              com.google.protobuf.BoolValue.getDefaultInstance() : requireClientCertificate_;
        }
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid client
       * certificate.
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_client_certificate = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
          getRequireClientCertificateFieldBuilder() {
        if (requireClientCertificateBuilder_ == null) {
          requireClientCertificateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                  getRequireClientCertificate(),
                  getParentForChildren(),
                  isClean());
          requireClientCertificate_ = null;
        }
        return requireClientCertificateBuilder_;
      }

      private com.google.protobuf.BoolValue requireSni_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> requireSniBuilder_;
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid and matching SNI.
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_sni = 3;</code>
       */
      public boolean hasRequireSni() {
        return requireSniBuilder_ != null || requireSni_ != null;
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid and matching SNI.
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_sni = 3;</code>
       */
      public com.google.protobuf.BoolValue getRequireSni() {
        if (requireSniBuilder_ == null) {
          return requireSni_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : requireSni_;
        } else {
          return requireSniBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid and matching SNI.
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_sni = 3;</code>
       */
      public Builder setRequireSni(com.google.protobuf.BoolValue value) {
        if (requireSniBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          requireSni_ = value;
          onChanged();
        } else {
          requireSniBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid and matching SNI.
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_sni = 3;</code>
       */
      public Builder setRequireSni(
          com.google.protobuf.BoolValue.Builder builderForValue) {
        if (requireSniBuilder_ == null) {
          requireSni_ = builderForValue.build();
          onChanged();
        } else {
          requireSniBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid and matching SNI.
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_sni = 3;</code>
       */
      public Builder mergeRequireSni(com.google.protobuf.BoolValue value) {
        if (requireSniBuilder_ == null) {
          if (requireSni_ != null) {
            requireSni_ =
              com.google.protobuf.BoolValue.newBuilder(requireSni_).mergeFrom(value).buildPartial();
          } else {
            requireSni_ = value;
          }
          onChanged();
        } else {
          requireSniBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid and matching SNI.
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_sni = 3;</code>
       */
      public Builder clearRequireSni() {
        if (requireSniBuilder_ == null) {
          requireSni_ = null;
          onChanged();
        } else {
          requireSni_ = null;
          requireSniBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid and matching SNI.
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_sni = 3;</code>
       */
      public com.google.protobuf.BoolValue.Builder getRequireSniBuilder() {
        
        onChanged();
        return getRequireSniFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid and matching SNI.
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_sni = 3;</code>
       */
      public com.google.protobuf.BoolValueOrBuilder getRequireSniOrBuilder() {
        if (requireSniBuilder_ != null) {
          return requireSniBuilder_.getMessageOrBuilder();
        } else {
          return requireSni_ == null ?
              com.google.protobuf.BoolValue.getDefaultInstance() : requireSni_;
        }
      }
      /**
       * <pre>
       * If specified, Envoy will reject connections without a valid and matching SNI.
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.google.protobuf.BoolValue require_sni = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
          getRequireSniFieldBuilder() {
        if (requireSniBuilder_ == null) {
          requireSniBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                  getRequireSni(),
                  getParentForChildren(),
                  isClean());
          requireSni_ = null;
        }
        return requireSniBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.TlsSessionTicketKeys, envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder, envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder> sessionTicketKeysBuilder_;
      /**
       * <pre>
       * TLS session ticket key settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
       */
      public boolean hasSessionTicketKeys() {
        return sessionTicketKeysTypeCase_ == 4;
      }
      /**
       * <pre>
       * TLS session ticket key settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
       */
      public envoy.api.v2.auth.Cert.TlsSessionTicketKeys getSessionTicketKeys() {
        if (sessionTicketKeysBuilder_ == null) {
          if (sessionTicketKeysTypeCase_ == 4) {
            return (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) sessionTicketKeysType_;
          }
          return envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
        } else {
          if (sessionTicketKeysTypeCase_ == 4) {
            return sessionTicketKeysBuilder_.getMessage();
          }
          return envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * TLS session ticket key settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
       */
      public Builder setSessionTicketKeys(envoy.api.v2.auth.Cert.TlsSessionTicketKeys value) {
        if (sessionTicketKeysBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          sessionTicketKeysType_ = value;
          onChanged();
        } else {
          sessionTicketKeysBuilder_.setMessage(value);
        }
        sessionTicketKeysTypeCase_ = 4;
        return this;
      }
      /**
       * <pre>
       * TLS session ticket key settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
       */
      public Builder setSessionTicketKeys(
          envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder builderForValue) {
        if (sessionTicketKeysBuilder_ == null) {
          sessionTicketKeysType_ = builderForValue.build();
          onChanged();
        } else {
          sessionTicketKeysBuilder_.setMessage(builderForValue.build());
        }
        sessionTicketKeysTypeCase_ = 4;
        return this;
      }
      /**
       * <pre>
       * TLS session ticket key settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
       */
      public Builder mergeSessionTicketKeys(envoy.api.v2.auth.Cert.TlsSessionTicketKeys value) {
        if (sessionTicketKeysBuilder_ == null) {
          if (sessionTicketKeysTypeCase_ == 4 &&
              sessionTicketKeysType_ != envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance()) {
            sessionTicketKeysType_ = envoy.api.v2.auth.Cert.TlsSessionTicketKeys.newBuilder((envoy.api.v2.auth.Cert.TlsSessionTicketKeys) sessionTicketKeysType_)
                .mergeFrom(value).buildPartial();
          } else {
            sessionTicketKeysType_ = value;
          }
          onChanged();
        } else {
          if (sessionTicketKeysTypeCase_ == 4) {
            sessionTicketKeysBuilder_.mergeFrom(value);
          }
          sessionTicketKeysBuilder_.setMessage(value);
        }
        sessionTicketKeysTypeCase_ = 4;
        return this;
      }
      /**
       * <pre>
       * TLS session ticket key settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
       */
      public Builder clearSessionTicketKeys() {
        if (sessionTicketKeysBuilder_ == null) {
          if (sessionTicketKeysTypeCase_ == 4) {
            sessionTicketKeysTypeCase_ = 0;
            sessionTicketKeysType_ = null;
            onChanged();
          }
        } else {
          if (sessionTicketKeysTypeCase_ == 4) {
            sessionTicketKeysTypeCase_ = 0;
            sessionTicketKeysType_ = null;
          }
          sessionTicketKeysBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * TLS session ticket key settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
       */
      public envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder getSessionTicketKeysBuilder() {
        return getSessionTicketKeysFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * TLS session ticket key settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
       */
      public envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder getSessionTicketKeysOrBuilder() {
        if ((sessionTicketKeysTypeCase_ == 4) && (sessionTicketKeysBuilder_ != null)) {
          return sessionTicketKeysBuilder_.getMessageOrBuilder();
        } else {
          if (sessionTicketKeysTypeCase_ == 4) {
            return (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) sessionTicketKeysType_;
          }
          return envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * TLS session ticket key settings.
       * </pre>
       *
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.TlsSessionTicketKeys, envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder, envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder> 
          getSessionTicketKeysFieldBuilder() {
        if (sessionTicketKeysBuilder_ == null) {
          if (!(sessionTicketKeysTypeCase_ == 4)) {
            sessionTicketKeysType_ = envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
          }
          sessionTicketKeysBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.auth.Cert.TlsSessionTicketKeys, envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder, envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder>(
                  (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) sessionTicketKeysType_,
                  getParentForChildren(),
                  isClean());
          sessionTicketKeysType_ = null;
        }
        sessionTicketKeysTypeCase_ = 4;
        onChanged();;
        return sessionTicketKeysBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.SdsSecretConfig, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder, envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder> sessionTicketKeysSdsSecretConfigBuilder_;
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
       */
      public boolean hasSessionTicketKeysSdsSecretConfig() {
        return sessionTicketKeysTypeCase_ == 5;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfig getSessionTicketKeysSdsSecretConfig() {
        if (sessionTicketKeysSdsSecretConfigBuilder_ == null) {
          if (sessionTicketKeysTypeCase_ == 5) {
            return (envoy.api.v2.auth.Cert.SdsSecretConfig) sessionTicketKeysType_;
          }
          return envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
        } else {
          if (sessionTicketKeysTypeCase_ == 5) {
            return sessionTicketKeysSdsSecretConfigBuilder_.getMessage();
          }
          return envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
       */
      public Builder setSessionTicketKeysSdsSecretConfig(envoy.api.v2.auth.Cert.SdsSecretConfig value) {
        if (sessionTicketKeysSdsSecretConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          sessionTicketKeysType_ = value;
          onChanged();
        } else {
          sessionTicketKeysSdsSecretConfigBuilder_.setMessage(value);
        }
        sessionTicketKeysTypeCase_ = 5;
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
       */
      public Builder setSessionTicketKeysSdsSecretConfig(
          envoy.api.v2.auth.Cert.SdsSecretConfig.Builder builderForValue) {
        if (sessionTicketKeysSdsSecretConfigBuilder_ == null) {
          sessionTicketKeysType_ = builderForValue.build();
          onChanged();
        } else {
          sessionTicketKeysSdsSecretConfigBuilder_.setMessage(builderForValue.build());
        }
        sessionTicketKeysTypeCase_ = 5;
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
       */
      public Builder mergeSessionTicketKeysSdsSecretConfig(envoy.api.v2.auth.Cert.SdsSecretConfig value) {
        if (sessionTicketKeysSdsSecretConfigBuilder_ == null) {
          if (sessionTicketKeysTypeCase_ == 5 &&
              sessionTicketKeysType_ != envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance()) {
            sessionTicketKeysType_ = envoy.api.v2.auth.Cert.SdsSecretConfig.newBuilder((envoy.api.v2.auth.Cert.SdsSecretConfig) sessionTicketKeysType_)
                .mergeFrom(value).buildPartial();
          } else {
            sessionTicketKeysType_ = value;
          }
          onChanged();
        } else {
          if (sessionTicketKeysTypeCase_ == 5) {
            sessionTicketKeysSdsSecretConfigBuilder_.mergeFrom(value);
          }
          sessionTicketKeysSdsSecretConfigBuilder_.setMessage(value);
        }
        sessionTicketKeysTypeCase_ = 5;
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
       */
      public Builder clearSessionTicketKeysSdsSecretConfig() {
        if (sessionTicketKeysSdsSecretConfigBuilder_ == null) {
          if (sessionTicketKeysTypeCase_ == 5) {
            sessionTicketKeysTypeCase_ = 0;
            sessionTicketKeysType_ = null;
            onChanged();
          }
        } else {
          if (sessionTicketKeysTypeCase_ == 5) {
            sessionTicketKeysTypeCase_ = 0;
            sessionTicketKeysType_ = null;
          }
          sessionTicketKeysSdsSecretConfigBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfig.Builder getSessionTicketKeysSdsSecretConfigBuilder() {
        return getSessionTicketKeysSdsSecretConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
       */
      public envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder getSessionTicketKeysSdsSecretConfigOrBuilder() {
        if ((sessionTicketKeysTypeCase_ == 5) && (sessionTicketKeysSdsSecretConfigBuilder_ != null)) {
          return sessionTicketKeysSdsSecretConfigBuilder_.getMessageOrBuilder();
        } else {
          if (sessionTicketKeysTypeCase_ == 5) {
            return (envoy.api.v2.auth.Cert.SdsSecretConfig) sessionTicketKeysType_;
          }
          return envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * [#not-implemented-hide:]
       * </pre>
       *
       * <code>.envoy.api.v2.auth.SdsSecretConfig session_ticket_keys_sds_secret_config = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.SdsSecretConfig, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder, envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder> 
          getSessionTicketKeysSdsSecretConfigFieldBuilder() {
        if (sessionTicketKeysSdsSecretConfigBuilder_ == null) {
          if (!(sessionTicketKeysTypeCase_ == 5)) {
            sessionTicketKeysType_ = envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
          }
          sessionTicketKeysSdsSecretConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.auth.Cert.SdsSecretConfig, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder, envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder>(
                  (envoy.api.v2.auth.Cert.SdsSecretConfig) sessionTicketKeysType_,
                  getParentForChildren(),
                  isClean());
          sessionTicketKeysType_ = null;
        }
        sessionTicketKeysTypeCase_ = 5;
        onChanged();;
        return sessionTicketKeysSdsSecretConfigBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.auth.DownstreamTlsContext)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.auth.DownstreamTlsContext)
    private static final envoy.api.v2.auth.Cert.DownstreamTlsContext DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new envoy.api.v2.auth.Cert.DownstreamTlsContext();
    }

    public static envoy.api.v2.auth.Cert.DownstreamTlsContext getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DownstreamTlsContext>
        PARSER = new com.google.protobuf.AbstractParser<DownstreamTlsContext>() {
      public DownstreamTlsContext parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DownstreamTlsContext(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DownstreamTlsContext> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DownstreamTlsContext> getParserForType() {
      return PARSER;
    }

    public envoy.api.v2.auth.Cert.DownstreamTlsContext getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SdsSecretConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.auth.SdsSecretConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
     * When both name and config are specified, then secret can be fetched and/or reloaded via SDS.
     * When only name is specified, then secret will be loaded from static resources [V2-API-DIFF].
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
     * When both name and config are specified, then secret can be fetched and/or reloaded via SDS.
     * When only name is specified, then secret will be loaded from static resources [V2-API-DIFF].
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
     */
    boolean hasSdsConfig();
    /**
     * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
     */
    envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource getSdsConfig();
    /**
     * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
     */
    envoy.api.v2.core.ConfigSourceOuterClass.ConfigSourceOrBuilder getSdsConfigOrBuilder();
  }
  /**
   * <pre>
   * [#proto-status: experimental]
   * </pre>
   *
   * Protobuf type {@code envoy.api.v2.auth.SdsSecretConfig}
   */
  public  static final class SdsSecretConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.auth.SdsSecretConfig)
      SdsSecretConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SdsSecretConfig.newBuilder() to construct.
    private SdsSecretConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SdsSecretConfig() {
      name_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private SdsSecretConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource.Builder subBuilder = null;
              if (sdsConfig_ != null) {
                subBuilder = sdsConfig_.toBuilder();
              }
              sdsConfig_ = input.readMessage(envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(sdsConfig_);
                sdsConfig_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_SdsSecretConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_SdsSecretConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              envoy.api.v2.auth.Cert.SdsSecretConfig.class, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder.class);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
     * When both name and config are specified, then secret can be fetched and/or reloaded via SDS.
     * When only name is specified, then secret will be loaded from static resources [V2-API-DIFF].
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
     * When both name and config are specified, then secret can be fetched and/or reloaded via SDS.
     * When only name is specified, then secret will be loaded from static resources [V2-API-DIFF].
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SDS_CONFIG_FIELD_NUMBER = 2;
    private envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource sdsConfig_;
    /**
     * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
     */
    public boolean hasSdsConfig() {
      return sdsConfig_ != null;
    }
    /**
     * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
     */
    public envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource getSdsConfig() {
      return sdsConfig_ == null ? envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource.getDefaultInstance() : sdsConfig_;
    }
    /**
     * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
     */
    public envoy.api.v2.core.ConfigSourceOuterClass.ConfigSourceOrBuilder getSdsConfigOrBuilder() {
      return getSdsConfig();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (sdsConfig_ != null) {
        output.writeMessage(2, getSdsConfig());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (sdsConfig_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSdsConfig());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof envoy.api.v2.auth.Cert.SdsSecretConfig)) {
        return super.equals(obj);
      }
      envoy.api.v2.auth.Cert.SdsSecretConfig other = (envoy.api.v2.auth.Cert.SdsSecretConfig) obj;

      boolean result = true;
      result = result && getName()
          .equals(other.getName());
      result = result && (hasSdsConfig() == other.hasSdsConfig());
      if (hasSdsConfig()) {
        result = result && getSdsConfig()
            .equals(other.getSdsConfig());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (hasSdsConfig()) {
        hash = (37 * hash) + SDS_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getSdsConfig().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static envoy.api.v2.auth.Cert.SdsSecretConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.SdsSecretConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.SdsSecretConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.SdsSecretConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.SdsSecretConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.SdsSecretConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.SdsSecretConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.SdsSecretConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.SdsSecretConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.SdsSecretConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.SdsSecretConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.SdsSecretConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(envoy.api.v2.auth.Cert.SdsSecretConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * [#proto-status: experimental]
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.auth.SdsSecretConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.auth.SdsSecretConfig)
        envoy.api.v2.auth.Cert.SdsSecretConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_SdsSecretConfig_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_SdsSecretConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                envoy.api.v2.auth.Cert.SdsSecretConfig.class, envoy.api.v2.auth.Cert.SdsSecretConfig.Builder.class);
      }

      // Construct using envoy.api.v2.auth.Cert.SdsSecretConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        name_ = "";

        if (sdsConfigBuilder_ == null) {
          sdsConfig_ = null;
        } else {
          sdsConfig_ = null;
          sdsConfigBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_SdsSecretConfig_descriptor;
      }

      public envoy.api.v2.auth.Cert.SdsSecretConfig getDefaultInstanceForType() {
        return envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance();
      }

      public envoy.api.v2.auth.Cert.SdsSecretConfig build() {
        envoy.api.v2.auth.Cert.SdsSecretConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public envoy.api.v2.auth.Cert.SdsSecretConfig buildPartial() {
        envoy.api.v2.auth.Cert.SdsSecretConfig result = new envoy.api.v2.auth.Cert.SdsSecretConfig(this);
        result.name_ = name_;
        if (sdsConfigBuilder_ == null) {
          result.sdsConfig_ = sdsConfig_;
        } else {
          result.sdsConfig_ = sdsConfigBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof envoy.api.v2.auth.Cert.SdsSecretConfig) {
          return mergeFrom((envoy.api.v2.auth.Cert.SdsSecretConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(envoy.api.v2.auth.Cert.SdsSecretConfig other) {
        if (other == envoy.api.v2.auth.Cert.SdsSecretConfig.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (other.hasSdsConfig()) {
          mergeSdsConfig(other.getSdsConfig());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        envoy.api.v2.auth.Cert.SdsSecretConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (envoy.api.v2.auth.Cert.SdsSecretConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
       * When both name and config are specified, then secret can be fetched and/or reloaded via SDS.
       * When only name is specified, then secret will be loaded from static resources [V2-API-DIFF].
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
       * When both name and config are specified, then secret can be fetched and/or reloaded via SDS.
       * When only name is specified, then secret will be loaded from static resources [V2-API-DIFF].
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
       * When both name and config are specified, then secret can be fetched and/or reloaded via SDS.
       * When only name is specified, then secret will be loaded from static resources [V2-API-DIFF].
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
       * When both name and config are specified, then secret can be fetched and/or reloaded via SDS.
       * When only name is specified, then secret will be loaded from static resources [V2-API-DIFF].
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
       * When both name and config are specified, then secret can be fetched and/or reloaded via SDS.
       * When only name is specified, then secret will be loaded from static resources [V2-API-DIFF].
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource sdsConfig_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource, envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource.Builder, envoy.api.v2.core.ConfigSourceOuterClass.ConfigSourceOrBuilder> sdsConfigBuilder_;
      /**
       * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
       */
      public boolean hasSdsConfig() {
        return sdsConfigBuilder_ != null || sdsConfig_ != null;
      }
      /**
       * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
       */
      public envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource getSdsConfig() {
        if (sdsConfigBuilder_ == null) {
          return sdsConfig_ == null ? envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource.getDefaultInstance() : sdsConfig_;
        } else {
          return sdsConfigBuilder_.getMessage();
        }
      }
      /**
       * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
       */
      public Builder setSdsConfig(envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource value) {
        if (sdsConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          sdsConfig_ = value;
          onChanged();
        } else {
          sdsConfigBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
       */
      public Builder setSdsConfig(
          envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource.Builder builderForValue) {
        if (sdsConfigBuilder_ == null) {
          sdsConfig_ = builderForValue.build();
          onChanged();
        } else {
          sdsConfigBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
       */
      public Builder mergeSdsConfig(envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource value) {
        if (sdsConfigBuilder_ == null) {
          if (sdsConfig_ != null) {
            sdsConfig_ =
              envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource.newBuilder(sdsConfig_).mergeFrom(value).buildPartial();
          } else {
            sdsConfig_ = value;
          }
          onChanged();
        } else {
          sdsConfigBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
       */
      public Builder clearSdsConfig() {
        if (sdsConfigBuilder_ == null) {
          sdsConfig_ = null;
          onChanged();
        } else {
          sdsConfig_ = null;
          sdsConfigBuilder_ = null;
        }

        return this;
      }
      /**
       * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
       */
      public envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource.Builder getSdsConfigBuilder() {
        
        onChanged();
        return getSdsConfigFieldBuilder().getBuilder();
      }
      /**
       * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
       */
      public envoy.api.v2.core.ConfigSourceOuterClass.ConfigSourceOrBuilder getSdsConfigOrBuilder() {
        if (sdsConfigBuilder_ != null) {
          return sdsConfigBuilder_.getMessageOrBuilder();
        } else {
          return sdsConfig_ == null ?
              envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource.getDefaultInstance() : sdsConfig_;
        }
      }
      /**
       * <code>.envoy.api.v2.core.ConfigSource sds_config = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource, envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource.Builder, envoy.api.v2.core.ConfigSourceOuterClass.ConfigSourceOrBuilder> 
          getSdsConfigFieldBuilder() {
        if (sdsConfigBuilder_ == null) {
          sdsConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource, envoy.api.v2.core.ConfigSourceOuterClass.ConfigSource.Builder, envoy.api.v2.core.ConfigSourceOuterClass.ConfigSourceOrBuilder>(
                  getSdsConfig(),
                  getParentForChildren(),
                  isClean());
          sdsConfig_ = null;
        }
        return sdsConfigBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.auth.SdsSecretConfig)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.auth.SdsSecretConfig)
    private static final envoy.api.v2.auth.Cert.SdsSecretConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new envoy.api.v2.auth.Cert.SdsSecretConfig();
    }

    public static envoy.api.v2.auth.Cert.SdsSecretConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SdsSecretConfig>
        PARSER = new com.google.protobuf.AbstractParser<SdsSecretConfig>() {
      public SdsSecretConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new SdsSecretConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<SdsSecretConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SdsSecretConfig> getParserForType() {
      return PARSER;
    }

    public envoy.api.v2.auth.Cert.SdsSecretConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SecretOrBuilder extends
      // @@protoc_insertion_point(interface_extends:envoy.api.v2.auth.Secret)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
     */
    boolean hasTlsCertificate();
    /**
     * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
     */
    envoy.api.v2.auth.Cert.TlsCertificate getTlsCertificate();
    /**
     * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
     */
    envoy.api.v2.auth.Cert.TlsCertificateOrBuilder getTlsCertificateOrBuilder();

    /**
     * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
     */
    boolean hasSessionTicketKeys();
    /**
     * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
     */
    envoy.api.v2.auth.Cert.TlsSessionTicketKeys getSessionTicketKeys();
    /**
     * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
     */
    envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder getSessionTicketKeysOrBuilder();

    /**
     * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
     */
    boolean hasValidationContext();
    /**
     * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
     */
    envoy.api.v2.auth.Cert.CertificateValidationContext getValidationContext();
    /**
     * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
     */
    envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder getValidationContextOrBuilder();

    public envoy.api.v2.auth.Cert.Secret.TypeCase getTypeCase();
  }
  /**
   * <pre>
   * [#proto-status: experimental]
   * </pre>
   *
   * Protobuf type {@code envoy.api.v2.auth.Secret}
   */
  public  static final class Secret extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:envoy.api.v2.auth.Secret)
      SecretOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Secret.newBuilder() to construct.
    private Secret(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Secret() {
      name_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Secret(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              envoy.api.v2.auth.Cert.TlsCertificate.Builder subBuilder = null;
              if (typeCase_ == 2) {
                subBuilder = ((envoy.api.v2.auth.Cert.TlsCertificate) type_).toBuilder();
              }
              type_ =
                  input.readMessage(envoy.api.v2.auth.Cert.TlsCertificate.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((envoy.api.v2.auth.Cert.TlsCertificate) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 2;
              break;
            }
            case 26: {
              envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder subBuilder = null;
              if (typeCase_ == 3) {
                subBuilder = ((envoy.api.v2.auth.Cert.TlsSessionTicketKeys) type_).toBuilder();
              }
              type_ =
                  input.readMessage(envoy.api.v2.auth.Cert.TlsSessionTicketKeys.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((envoy.api.v2.auth.Cert.TlsSessionTicketKeys) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 3;
              break;
            }
            case 34: {
              envoy.api.v2.auth.Cert.CertificateValidationContext.Builder subBuilder = null;
              if (typeCase_ == 4) {
                subBuilder = ((envoy.api.v2.auth.Cert.CertificateValidationContext) type_).toBuilder();
              }
              type_ =
                  input.readMessage(envoy.api.v2.auth.Cert.CertificateValidationContext.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((envoy.api.v2.auth.Cert.CertificateValidationContext) type_);
                type_ = subBuilder.buildPartial();
              }
              typeCase_ = 4;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_Secret_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_Secret_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              envoy.api.v2.auth.Cert.Secret.class, envoy.api.v2.auth.Cert.Secret.Builder.class);
    }

    private int typeCase_ = 0;
    private java.lang.Object type_;
    public enum TypeCase
        implements com.google.protobuf.Internal.EnumLite {
      TLS_CERTIFICATE(2),
      SESSION_TICKET_KEYS(3),
      VALIDATION_CONTEXT(4),
      TYPE_NOT_SET(0);
      private final int value;
      private TypeCase(int value) {
        this.value = value;
      }
      /**
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TypeCase valueOf(int value) {
        return forNumber(value);
      }

      public static TypeCase forNumber(int value) {
        switch (value) {
          case 2: return TLS_CERTIFICATE;
          case 3: return SESSION_TICKET_KEYS;
          case 4: return VALIDATION_CONTEXT;
          case 0: return TYPE_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public TypeCase
    getTypeCase() {
      return TypeCase.forNumber(
          typeCase_);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
     * </pre>
     *
     * <code>string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TLS_CERTIFICATE_FIELD_NUMBER = 2;
    /**
     * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
     */
    public boolean hasTlsCertificate() {
      return typeCase_ == 2;
    }
    /**
     * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
     */
    public envoy.api.v2.auth.Cert.TlsCertificate getTlsCertificate() {
      if (typeCase_ == 2) {
         return (envoy.api.v2.auth.Cert.TlsCertificate) type_;
      }
      return envoy.api.v2.auth.Cert.TlsCertificate.getDefaultInstance();
    }
    /**
     * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
     */
    public envoy.api.v2.auth.Cert.TlsCertificateOrBuilder getTlsCertificateOrBuilder() {
      if (typeCase_ == 2) {
         return (envoy.api.v2.auth.Cert.TlsCertificate) type_;
      }
      return envoy.api.v2.auth.Cert.TlsCertificate.getDefaultInstance();
    }

    public static final int SESSION_TICKET_KEYS_FIELD_NUMBER = 3;
    /**
     * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
     */
    public boolean hasSessionTicketKeys() {
      return typeCase_ == 3;
    }
    /**
     * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
     */
    public envoy.api.v2.auth.Cert.TlsSessionTicketKeys getSessionTicketKeys() {
      if (typeCase_ == 3) {
         return (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) type_;
      }
      return envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
    }
    /**
     * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
     */
    public envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder getSessionTicketKeysOrBuilder() {
      if (typeCase_ == 3) {
         return (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) type_;
      }
      return envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
    }

    public static final int VALIDATION_CONTEXT_FIELD_NUMBER = 4;
    /**
     * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
     */
    public boolean hasValidationContext() {
      return typeCase_ == 4;
    }
    /**
     * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
     */
    public envoy.api.v2.auth.Cert.CertificateValidationContext getValidationContext() {
      if (typeCase_ == 4) {
         return (envoy.api.v2.auth.Cert.CertificateValidationContext) type_;
      }
      return envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
    }
    /**
     * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
     */
    public envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder getValidationContextOrBuilder() {
      if (typeCase_ == 4) {
         return (envoy.api.v2.auth.Cert.CertificateValidationContext) type_;
      }
      return envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (typeCase_ == 2) {
        output.writeMessage(2, (envoy.api.v2.auth.Cert.TlsCertificate) type_);
      }
      if (typeCase_ == 3) {
        output.writeMessage(3, (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) type_);
      }
      if (typeCase_ == 4) {
        output.writeMessage(4, (envoy.api.v2.auth.Cert.CertificateValidationContext) type_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (typeCase_ == 2) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, (envoy.api.v2.auth.Cert.TlsCertificate) type_);
      }
      if (typeCase_ == 3) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) type_);
      }
      if (typeCase_ == 4) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, (envoy.api.v2.auth.Cert.CertificateValidationContext) type_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof envoy.api.v2.auth.Cert.Secret)) {
        return super.equals(obj);
      }
      envoy.api.v2.auth.Cert.Secret other = (envoy.api.v2.auth.Cert.Secret) obj;

      boolean result = true;
      result = result && getName()
          .equals(other.getName());
      result = result && getTypeCase().equals(
          other.getTypeCase());
      if (!result) return false;
      switch (typeCase_) {
        case 2:
          result = result && getTlsCertificate()
              .equals(other.getTlsCertificate());
          break;
        case 3:
          result = result && getSessionTicketKeys()
              .equals(other.getSessionTicketKeys());
          break;
        case 4:
          result = result && getValidationContext()
              .equals(other.getValidationContext());
          break;
        case 0:
        default:
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      switch (typeCase_) {
        case 2:
          hash = (37 * hash) + TLS_CERTIFICATE_FIELD_NUMBER;
          hash = (53 * hash) + getTlsCertificate().hashCode();
          break;
        case 3:
          hash = (37 * hash) + SESSION_TICKET_KEYS_FIELD_NUMBER;
          hash = (53 * hash) + getSessionTicketKeys().hashCode();
          break;
        case 4:
          hash = (37 * hash) + VALIDATION_CONTEXT_FIELD_NUMBER;
          hash = (53 * hash) + getValidationContext().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static envoy.api.v2.auth.Cert.Secret parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.Secret parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.Secret parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.Secret parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.Secret parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static envoy.api.v2.auth.Cert.Secret parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.Secret parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.Secret parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.Secret parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.Secret parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static envoy.api.v2.auth.Cert.Secret parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static envoy.api.v2.auth.Cert.Secret parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(envoy.api.v2.auth.Cert.Secret prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * [#proto-status: experimental]
     * </pre>
     *
     * Protobuf type {@code envoy.api.v2.auth.Secret}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:envoy.api.v2.auth.Secret)
        envoy.api.v2.auth.Cert.SecretOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_Secret_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_Secret_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                envoy.api.v2.auth.Cert.Secret.class, envoy.api.v2.auth.Cert.Secret.Builder.class);
      }

      // Construct using envoy.api.v2.auth.Cert.Secret.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        name_ = "";

        typeCase_ = 0;
        type_ = null;
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return envoy.api.v2.auth.Cert.internal_static_envoy_api_v2_auth_Secret_descriptor;
      }

      public envoy.api.v2.auth.Cert.Secret getDefaultInstanceForType() {
        return envoy.api.v2.auth.Cert.Secret.getDefaultInstance();
      }

      public envoy.api.v2.auth.Cert.Secret build() {
        envoy.api.v2.auth.Cert.Secret result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public envoy.api.v2.auth.Cert.Secret buildPartial() {
        envoy.api.v2.auth.Cert.Secret result = new envoy.api.v2.auth.Cert.Secret(this);
        result.name_ = name_;
        if (typeCase_ == 2) {
          if (tlsCertificateBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = tlsCertificateBuilder_.build();
          }
        }
        if (typeCase_ == 3) {
          if (sessionTicketKeysBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = sessionTicketKeysBuilder_.build();
          }
        }
        if (typeCase_ == 4) {
          if (validationContextBuilder_ == null) {
            result.type_ = type_;
          } else {
            result.type_ = validationContextBuilder_.build();
          }
        }
        result.typeCase_ = typeCase_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof envoy.api.v2.auth.Cert.Secret) {
          return mergeFrom((envoy.api.v2.auth.Cert.Secret)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(envoy.api.v2.auth.Cert.Secret other) {
        if (other == envoy.api.v2.auth.Cert.Secret.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        switch (other.getTypeCase()) {
          case TLS_CERTIFICATE: {
            mergeTlsCertificate(other.getTlsCertificate());
            break;
          }
          case SESSION_TICKET_KEYS: {
            mergeSessionTicketKeys(other.getSessionTicketKeys());
            break;
          }
          case VALIDATION_CONTEXT: {
            mergeValidationContext(other.getValidationContext());
            break;
          }
          case TYPE_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        envoy.api.v2.auth.Cert.Secret parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (envoy.api.v2.auth.Cert.Secret) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int typeCase_ = 0;
      private java.lang.Object type_;
      public TypeCase
          getTypeCase() {
        return TypeCase.forNumber(
            typeCase_);
      }

      public Builder clearType() {
        typeCase_ = 0;
        type_ = null;
        onChanged();
        return this;
      }


      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to.
       * </pre>
       *
       * <code>string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.TlsCertificate, envoy.api.v2.auth.Cert.TlsCertificate.Builder, envoy.api.v2.auth.Cert.TlsCertificateOrBuilder> tlsCertificateBuilder_;
      /**
       * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
       */
      public boolean hasTlsCertificate() {
        return typeCase_ == 2;
      }
      /**
       * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
       */
      public envoy.api.v2.auth.Cert.TlsCertificate getTlsCertificate() {
        if (tlsCertificateBuilder_ == null) {
          if (typeCase_ == 2) {
            return (envoy.api.v2.auth.Cert.TlsCertificate) type_;
          }
          return envoy.api.v2.auth.Cert.TlsCertificate.getDefaultInstance();
        } else {
          if (typeCase_ == 2) {
            return tlsCertificateBuilder_.getMessage();
          }
          return envoy.api.v2.auth.Cert.TlsCertificate.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
       */
      public Builder setTlsCertificate(envoy.api.v2.auth.Cert.TlsCertificate value) {
        if (tlsCertificateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          tlsCertificateBuilder_.setMessage(value);
        }
        typeCase_ = 2;
        return this;
      }
      /**
       * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
       */
      public Builder setTlsCertificate(
          envoy.api.v2.auth.Cert.TlsCertificate.Builder builderForValue) {
        if (tlsCertificateBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          tlsCertificateBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 2;
        return this;
      }
      /**
       * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
       */
      public Builder mergeTlsCertificate(envoy.api.v2.auth.Cert.TlsCertificate value) {
        if (tlsCertificateBuilder_ == null) {
          if (typeCase_ == 2 &&
              type_ != envoy.api.v2.auth.Cert.TlsCertificate.getDefaultInstance()) {
            type_ = envoy.api.v2.auth.Cert.TlsCertificate.newBuilder((envoy.api.v2.auth.Cert.TlsCertificate) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 2) {
            tlsCertificateBuilder_.mergeFrom(value);
          }
          tlsCertificateBuilder_.setMessage(value);
        }
        typeCase_ = 2;
        return this;
      }
      /**
       * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
       */
      public Builder clearTlsCertificate() {
        if (tlsCertificateBuilder_ == null) {
          if (typeCase_ == 2) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 2) {
            typeCase_ = 0;
            type_ = null;
          }
          tlsCertificateBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
       */
      public envoy.api.v2.auth.Cert.TlsCertificate.Builder getTlsCertificateBuilder() {
        return getTlsCertificateFieldBuilder().getBuilder();
      }
      /**
       * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
       */
      public envoy.api.v2.auth.Cert.TlsCertificateOrBuilder getTlsCertificateOrBuilder() {
        if ((typeCase_ == 2) && (tlsCertificateBuilder_ != null)) {
          return tlsCertificateBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 2) {
            return (envoy.api.v2.auth.Cert.TlsCertificate) type_;
          }
          return envoy.api.v2.auth.Cert.TlsCertificate.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.api.v2.auth.TlsCertificate tls_certificate = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.TlsCertificate, envoy.api.v2.auth.Cert.TlsCertificate.Builder, envoy.api.v2.auth.Cert.TlsCertificateOrBuilder> 
          getTlsCertificateFieldBuilder() {
        if (tlsCertificateBuilder_ == null) {
          if (!(typeCase_ == 2)) {
            type_ = envoy.api.v2.auth.Cert.TlsCertificate.getDefaultInstance();
          }
          tlsCertificateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.auth.Cert.TlsCertificate, envoy.api.v2.auth.Cert.TlsCertificate.Builder, envoy.api.v2.auth.Cert.TlsCertificateOrBuilder>(
                  (envoy.api.v2.auth.Cert.TlsCertificate) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 2;
        onChanged();;
        return tlsCertificateBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.TlsSessionTicketKeys, envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder, envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder> sessionTicketKeysBuilder_;
      /**
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
       */
      public boolean hasSessionTicketKeys() {
        return typeCase_ == 3;
      }
      /**
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
       */
      public envoy.api.v2.auth.Cert.TlsSessionTicketKeys getSessionTicketKeys() {
        if (sessionTicketKeysBuilder_ == null) {
          if (typeCase_ == 3) {
            return (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) type_;
          }
          return envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
        } else {
          if (typeCase_ == 3) {
            return sessionTicketKeysBuilder_.getMessage();
          }
          return envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
       */
      public Builder setSessionTicketKeys(envoy.api.v2.auth.Cert.TlsSessionTicketKeys value) {
        if (sessionTicketKeysBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          sessionTicketKeysBuilder_.setMessage(value);
        }
        typeCase_ = 3;
        return this;
      }
      /**
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
       */
      public Builder setSessionTicketKeys(
          envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder builderForValue) {
        if (sessionTicketKeysBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          sessionTicketKeysBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 3;
        return this;
      }
      /**
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
       */
      public Builder mergeSessionTicketKeys(envoy.api.v2.auth.Cert.TlsSessionTicketKeys value) {
        if (sessionTicketKeysBuilder_ == null) {
          if (typeCase_ == 3 &&
              type_ != envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance()) {
            type_ = envoy.api.v2.auth.Cert.TlsSessionTicketKeys.newBuilder((envoy.api.v2.auth.Cert.TlsSessionTicketKeys) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 3) {
            sessionTicketKeysBuilder_.mergeFrom(value);
          }
          sessionTicketKeysBuilder_.setMessage(value);
        }
        typeCase_ = 3;
        return this;
      }
      /**
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
       */
      public Builder clearSessionTicketKeys() {
        if (sessionTicketKeysBuilder_ == null) {
          if (typeCase_ == 3) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 3) {
            typeCase_ = 0;
            type_ = null;
          }
          sessionTicketKeysBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
       */
      public envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder getSessionTicketKeysBuilder() {
        return getSessionTicketKeysFieldBuilder().getBuilder();
      }
      /**
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
       */
      public envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder getSessionTicketKeysOrBuilder() {
        if ((typeCase_ == 3) && (sessionTicketKeysBuilder_ != null)) {
          return sessionTicketKeysBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 3) {
            return (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) type_;
          }
          return envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.api.v2.auth.TlsSessionTicketKeys session_ticket_keys = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.TlsSessionTicketKeys, envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder, envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder> 
          getSessionTicketKeysFieldBuilder() {
        if (sessionTicketKeysBuilder_ == null) {
          if (!(typeCase_ == 3)) {
            type_ = envoy.api.v2.auth.Cert.TlsSessionTicketKeys.getDefaultInstance();
          }
          sessionTicketKeysBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.auth.Cert.TlsSessionTicketKeys, envoy.api.v2.auth.Cert.TlsSessionTicketKeys.Builder, envoy.api.v2.auth.Cert.TlsSessionTicketKeysOrBuilder>(
                  (envoy.api.v2.auth.Cert.TlsSessionTicketKeys) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 3;
        onChanged();;
        return sessionTicketKeysBuilder_;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.CertificateValidationContext, envoy.api.v2.auth.Cert.CertificateValidationContext.Builder, envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder> validationContextBuilder_;
      /**
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
       */
      public boolean hasValidationContext() {
        return typeCase_ == 4;
      }
      /**
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
       */
      public envoy.api.v2.auth.Cert.CertificateValidationContext getValidationContext() {
        if (validationContextBuilder_ == null) {
          if (typeCase_ == 4) {
            return (envoy.api.v2.auth.Cert.CertificateValidationContext) type_;
          }
          return envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
        } else {
          if (typeCase_ == 4) {
            return validationContextBuilder_.getMessage();
          }
          return envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
       */
      public Builder setValidationContext(envoy.api.v2.auth.Cert.CertificateValidationContext value) {
        if (validationContextBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          type_ = value;
          onChanged();
        } else {
          validationContextBuilder_.setMessage(value);
        }
        typeCase_ = 4;
        return this;
      }
      /**
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
       */
      public Builder setValidationContext(
          envoy.api.v2.auth.Cert.CertificateValidationContext.Builder builderForValue) {
        if (validationContextBuilder_ == null) {
          type_ = builderForValue.build();
          onChanged();
        } else {
          validationContextBuilder_.setMessage(builderForValue.build());
        }
        typeCase_ = 4;
        return this;
      }
      /**
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
       */
      public Builder mergeValidationContext(envoy.api.v2.auth.Cert.CertificateValidationContext value) {
        if (validationContextBuilder_ == null) {
          if (typeCase_ == 4 &&
              type_ != envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance()) {
            type_ = envoy.api.v2.auth.Cert.CertificateValidationContext.newBuilder((envoy.api.v2.auth.Cert.CertificateValidationContext) type_)
                .mergeFrom(value).buildPartial();
          } else {
            type_ = value;
          }
          onChanged();
        } else {
          if (typeCase_ == 4) {
            validationContextBuilder_.mergeFrom(value);
          }
          validationContextBuilder_.setMessage(value);
        }
        typeCase_ = 4;
        return this;
      }
      /**
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
       */
      public Builder clearValidationContext() {
        if (validationContextBuilder_ == null) {
          if (typeCase_ == 4) {
            typeCase_ = 0;
            type_ = null;
            onChanged();
          }
        } else {
          if (typeCase_ == 4) {
            typeCase_ = 0;
            type_ = null;
          }
          validationContextBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
       */
      public envoy.api.v2.auth.Cert.CertificateValidationContext.Builder getValidationContextBuilder() {
        return getValidationContextFieldBuilder().getBuilder();
      }
      /**
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
       */
      public envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder getValidationContextOrBuilder() {
        if ((typeCase_ == 4) && (validationContextBuilder_ != null)) {
          return validationContextBuilder_.getMessageOrBuilder();
        } else {
          if (typeCase_ == 4) {
            return (envoy.api.v2.auth.Cert.CertificateValidationContext) type_;
          }
          return envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
        }
      }
      /**
       * <code>.envoy.api.v2.auth.CertificateValidationContext validation_context = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          envoy.api.v2.auth.Cert.CertificateValidationContext, envoy.api.v2.auth.Cert.CertificateValidationContext.Builder, envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder> 
          getValidationContextFieldBuilder() {
        if (validationContextBuilder_ == null) {
          if (!(typeCase_ == 4)) {
            type_ = envoy.api.v2.auth.Cert.CertificateValidationContext.getDefaultInstance();
          }
          validationContextBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              envoy.api.v2.auth.Cert.CertificateValidationContext, envoy.api.v2.auth.Cert.CertificateValidationContext.Builder, envoy.api.v2.auth.Cert.CertificateValidationContextOrBuilder>(
                  (envoy.api.v2.auth.Cert.CertificateValidationContext) type_,
                  getParentForChildren(),
                  isClean());
          type_ = null;
        }
        typeCase_ = 4;
        onChanged();;
        return validationContextBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:envoy.api.v2.auth.Secret)
    }

    // @@protoc_insertion_point(class_scope:envoy.api.v2.auth.Secret)
    private static final envoy.api.v2.auth.Cert.Secret DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new envoy.api.v2.auth.Cert.Secret();
    }

    public static envoy.api.v2.auth.Cert.Secret getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Secret>
        PARSER = new com.google.protobuf.AbstractParser<Secret>() {
      public Secret parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Secret(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Secret> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Secret> getParserForType() {
      return PARSER;
    }

    public envoy.api.v2.auth.Cert.Secret getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_envoy_api_v2_auth_TlsParameters_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_envoy_api_v2_auth_TlsParameters_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_envoy_api_v2_auth_TlsCertificate_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_envoy_api_v2_auth_TlsCertificate_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_envoy_api_v2_auth_TlsSessionTicketKeys_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_envoy_api_v2_auth_TlsSessionTicketKeys_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_envoy_api_v2_auth_CertificateValidationContext_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_envoy_api_v2_auth_CertificateValidationContext_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_envoy_api_v2_auth_CommonTlsContext_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_envoy_api_v2_auth_CommonTlsContext_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_envoy_api_v2_auth_CommonTlsContext_CombinedCertificateValidationContext_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_envoy_api_v2_auth_CommonTlsContext_CombinedCertificateValidationContext_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_envoy_api_v2_auth_UpstreamTlsContext_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_envoy_api_v2_auth_UpstreamTlsContext_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_envoy_api_v2_auth_DownstreamTlsContext_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_envoy_api_v2_auth_DownstreamTlsContext_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_envoy_api_v2_auth_SdsSecretConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_envoy_api_v2_auth_SdsSecretConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_envoy_api_v2_auth_Secret_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_envoy_api_v2_auth_Secret_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\034envoy/api/v2/auth/cert.proto\022\021envoy.ap" +
      "i.v2.auth\032\034envoy/api/v2/core/base.proto\032" +
      "%envoy/api/v2/core/config_source.proto\032\036" +
      "google/protobuf/wrappers.proto\032\027validate" +
      "/validate.proto\"\314\002\n\rTlsParameters\022^\n\034tls" +
      "_minimum_protocol_version\030\001 \001(\0162,.envoy." +
      "api.v2.auth.TlsParameters.TlsProtocolB\n\272" +
      "\351\300\003\005\202\001\002\020\001\022^\n\034tls_maximum_protocol_versio" +
      "n\030\002 \001(\0162,.envoy.api.v2.auth.TlsParameter" +
      "s.TlsProtocolB\n\272\351\300\003\005\202\001\002\020\001\022\025\n\rcipher_suit" +
      "es\030\003 \003(\t\022\023\n\013ecdh_curves\030\004 \003(\t\"O\n\013TlsProt" +
      "ocol\022\014\n\010TLS_AUTO\020\000\022\013\n\007TLSv1_0\020\001\022\013\n\007TLSv1" +
      "_1\020\002\022\013\n\007TLSv1_2\020\003\022\013\n\007TLSv1_3\020\004\"\250\002\n\016TlsCe" +
      "rtificate\0228\n\021certificate_chain\030\001 \001(\0132\035.e" +
      "nvoy.api.v2.core.DataSource\0222\n\013private_k" +
      "ey\030\002 \001(\0132\035.envoy.api.v2.core.DataSource\022" +
      "/\n\010password\030\003 \001(\0132\035.envoy.api.v2.core.Da" +
      "taSource\0222\n\013ocsp_staple\030\004 \001(\0132\035.envoy.ap" +
      "i.v2.core.DataSource\022C\n\034signed_certifica" +
      "te_timestamp\030\005 \003(\0132\035.envoy.api.v2.core.D" +
      "ataSource\"O\n\024TlsSessionTicketKeys\0227\n\004key" +
      "s\030\001 \003(\0132\035.envoy.api.v2.core.DataSourceB\n" +
      "\272\351\300\003\005\222\001\002\010\001\"\252\003\n\034CertificateValidationCont" +
      "ext\0221\n\ntrusted_ca\030\001 \001(\0132\035.envoy.api.v2.c" +
      "ore.DataSource\0221\n\027verify_certificate_spk" +
      "i\030\003 \003(\tB\020\272\351\300\003\013\222\001\010\"\006r\004 ,(,\0221\n\027verify_cert" +
      "ificate_hash\030\002 \003(\tB\020\272\351\300\003\013\222\001\010\"\006r\004 @(_\022\037\n\027" +
      "verify_subject_alt_name\030\004 \003(\t\0227\n\023require" +
      "_ocsp_staple\030\005 \001(\0132\032.google.protobuf.Boo" +
      "lValue\022H\n$require_signed_certificate_tim" +
      "estamp\030\006 \001(\0132\032.google.protobuf.BoolValue" +
      "\022*\n\003crl\030\007 \001(\0132\035.envoy.api.v2.core.DataSo" +
      "urce\022!\n\031allow_expired_certificate\030\010 \001(\010\"" +
      "\212\006\n\020CommonTlsContext\0224\n\ntls_params\030\001 \001(\013" +
      "2 .envoy.api.v2.auth.TlsParameters\022;\n\020tl" +
      "s_certificates\030\002 \003(\0132!.envoy.api.v2.auth" +
      ".TlsCertificate\022N\n\"tls_certificate_sds_s" +
      "ecret_configs\030\006 \003(\0132\".envoy.api.v2.auth." +
      "SdsSecretConfig\022M\n\022validation_context\030\003 " +
      "\001(\0132/.envoy.api.v2.auth.CertificateValid" +
      "ationContextH\000\022R\n$validation_context_sds" +
      "_secret_config\030\007 \001(\0132\".envoy.api.v2.auth" +
      ".SdsSecretConfigH\000\022o\n\033combined_validatio" +
      "n_context\030\010 \001(\0132H.envoy.api.v2.auth.Comm" +
      "onTlsContext.CombinedCertificateValidati" +
      "onContextH\000\022\026\n\016alpn_protocols\030\004 \003(\t\032\345\001\n$" +
      "CombinedCertificateValidationContext\022_\n\032" +
      "default_validation_context\030\001 \001(\0132/.envoy" +
      ".api.v2.auth.CertificateValidationContex" +
      "tB\n\272\351\300\003\005\212\001\002\020\001\022\\\n$validation_context_sds_" +
      "secret_config\030\002 \001(\0132\".envoy.api.v2.auth." +
      "SdsSecretConfigB\n\272\351\300\003\005\212\001\002\020\001B\031\n\027validatio" +
      "n_context_typeJ\004\010\005\020\006\"\303\001\n\022UpstreamTlsCont" +
      "ext\022?\n\022common_tls_context\030\001 \001(\0132#.envoy." +
      "api.v2.auth.CommonTlsContext\022\027\n\003sni\030\002 \001(" +
      "\tB\n\272\351\300\003\005r\003(\377\001\022\033\n\023allow_renegotiation\030\003 \001" +
      "(\010\0226\n\020max_session_keys\030\004 \001(\0132\034.google.pr" +
      "otobuf.UInt32Value\"\201\003\n\024DownstreamTlsCont" +
      "ext\022?\n\022common_tls_context\030\001 \001(\0132#.envoy." +
      "api.v2.auth.CommonTlsContext\022>\n\032require_" +
      "client_certificate\030\002 \001(\0132\032.google.protob" +
      "uf.BoolValue\022/\n\013require_sni\030\003 \001(\0132\032.goog" +
      "le.protobuf.BoolValue\022F\n\023session_ticket_" +
      "keys\030\004 \001(\0132\'.envoy.api.v2.auth.TlsSessio" +
      "nTicketKeysH\000\022S\n%session_ticket_keys_sds" +
      "_secret_config\030\005 \001(\0132\".envoy.api.v2.auth" +
      ".SdsSecretConfigH\000B\032\n\030session_ticket_key" +
      "s_type\"T\n\017SdsSecretConfig\022\014\n\004name\030\001 \001(\t\022" +
      "3\n\nsds_config\030\002 \001(\0132\037.envoy.api.v2.core." +
      "ConfigSource\"\363\001\n\006Secret\022\014\n\004name\030\001 \001(\t\022<\n" +
      "\017tls_certificate\030\002 \001(\0132!.envoy.api.v2.au" +
      "th.TlsCertificateH\000\022F\n\023session_ticket_ke" +
      "ys\030\003 \001(\0132\'.envoy.api.v2.auth.TlsSessionT" +
      "icketKeysH\000\022M\n\022validation_context\030\004 \001(\0132" +
      "/.envoy.api.v2.auth.CertificateValidatio" +
      "nContextH\000B\006\n\004typeB\006Z\004authb\006proto3"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          envoy.api.v2.core.Base.getDescriptor(),
          envoy.api.v2.core.ConfigSourceOuterClass.getDescriptor(),
          com.google.protobuf.WrappersProto.getDescriptor(),
          validate.Validate.getDescriptor(),
        }, assigner);
    internal_static_envoy_api_v2_auth_TlsParameters_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_envoy_api_v2_auth_TlsParameters_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_envoy_api_v2_auth_TlsParameters_descriptor,
        new java.lang.String[] { "TlsMinimumProtocolVersion", "TlsMaximumProtocolVersion", "CipherSuites", "EcdhCurves", });
    internal_static_envoy_api_v2_auth_TlsCertificate_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_envoy_api_v2_auth_TlsCertificate_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_envoy_api_v2_auth_TlsCertificate_descriptor,
        new java.lang.String[] { "CertificateChain", "PrivateKey", "Password", "OcspStaple", "SignedCertificateTimestamp", });
    internal_static_envoy_api_v2_auth_TlsSessionTicketKeys_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_envoy_api_v2_auth_TlsSessionTicketKeys_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_envoy_api_v2_auth_TlsSessionTicketKeys_descriptor,
        new java.lang.String[] { "Keys", });
    internal_static_envoy_api_v2_auth_CertificateValidationContext_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_envoy_api_v2_auth_CertificateValidationContext_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_envoy_api_v2_auth_CertificateValidationContext_descriptor,
        new java.lang.String[] { "TrustedCa", "VerifyCertificateSpki", "VerifyCertificateHash", "VerifySubjectAltName", "RequireOcspStaple", "RequireSignedCertificateTimestamp", "Crl", "AllowExpiredCertificate", });
    internal_static_envoy_api_v2_auth_CommonTlsContext_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_envoy_api_v2_auth_CommonTlsContext_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_envoy_api_v2_auth_CommonTlsContext_descriptor,
        new java.lang.String[] { "TlsParams", "TlsCertificates", "TlsCertificateSdsSecretConfigs", "ValidationContext", "ValidationContextSdsSecretConfig", "CombinedValidationContext", "AlpnProtocols", "ValidationContextType", });
    internal_static_envoy_api_v2_auth_CommonTlsContext_CombinedCertificateValidationContext_descriptor =
      internal_static_envoy_api_v2_auth_CommonTlsContext_descriptor.getNestedTypes().get(0);
    internal_static_envoy_api_v2_auth_CommonTlsContext_CombinedCertificateValidationContext_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_envoy_api_v2_auth_CommonTlsContext_CombinedCertificateValidationContext_descriptor,
        new java.lang.String[] { "DefaultValidationContext", "ValidationContextSdsSecretConfig", });
    internal_static_envoy_api_v2_auth_UpstreamTlsContext_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_envoy_api_v2_auth_UpstreamTlsContext_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_envoy_api_v2_auth_UpstreamTlsContext_descriptor,
        new java.lang.String[] { "CommonTlsContext", "Sni", "AllowRenegotiation", "MaxSessionKeys", });
    internal_static_envoy_api_v2_auth_DownstreamTlsContext_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_envoy_api_v2_auth_DownstreamTlsContext_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_envoy_api_v2_auth_DownstreamTlsContext_descriptor,
        new java.lang.String[] { "CommonTlsContext", "RequireClientCertificate", "RequireSni", "SessionTicketKeys", "SessionTicketKeysSdsSecretConfig", "SessionTicketKeysType", });
    internal_static_envoy_api_v2_auth_SdsSecretConfig_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_envoy_api_v2_auth_SdsSecretConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_envoy_api_v2_auth_SdsSecretConfig_descriptor,
        new java.lang.String[] { "Name", "SdsConfig", });
    internal_static_envoy_api_v2_auth_Secret_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_envoy_api_v2_auth_Secret_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_envoy_api_v2_auth_Secret_descriptor,
        new java.lang.String[] { "Name", "TlsCertificate", "SessionTicketKeys", "ValidationContext", "Type", });
    com.google.protobuf.ExtensionRegistry registry =
        com.google.protobuf.ExtensionRegistry.newInstance();
    registry.add(validate.Validate.rules);
    com.google.protobuf.Descriptors.FileDescriptor
        .internalUpdateFileDescriptor(descriptor, registry);
    envoy.api.v2.core.Base.getDescriptor();
    envoy.api.v2.core.ConfigSourceOuterClass.getDescriptor();
    com.google.protobuf.WrappersProto.getDescriptor();
    validate.Validate.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
