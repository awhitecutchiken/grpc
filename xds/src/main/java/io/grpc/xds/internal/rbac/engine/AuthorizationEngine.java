/*
 * Copyright 2020 The gRPC Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.grpc.xds.internal.rbac.engine;

import com.google.api.expr.v1alpha1.Expr;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.protobuf.Descriptors.Descriptor;
import io.envoyproxy.envoy.config.rbac.v2.Policy;
import io.envoyproxy.envoy.config.rbac.v2.RBAC;
import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;
import io.grpc.xds.internal.rbac.engine.cel.Activation;
import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;
import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;
import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;
import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;
import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;
import io.grpc.xds.internal.rbac.engine.cel.Interpretable;
import io.grpc.xds.internal.rbac.engine.cel.Interpreter;
import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;
import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * CEL Evaluation Engine is part of the authorization framework in gRPC.
 * CEL Evaluation Engine takes one or two Envoy RBAC policies as input
 * and uses CEL library to evaluate the condition field 
 * inside each RBAC policy based on the provided Envoy Attributes. 
 * CEL Evaluation Engine will generate an authorization decision which
 * could be ALLOW, DENY or UNKNOWN.
 * 
 * <p>Use as in:
 * 
 * <pre>
 *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);
 *  AuthorizationDecision result = engine.evaluate();
 * </pre>
 */
public class AuthorizationEngine<ReqT, RespT> {
  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());
  
  /**
   * RbacEngine is an inner class that holds RBAC action 
   * and conditions of RBAC policy.
   */
  @SuppressWarnings("ClassCanBeStatic")
  private class RbacEngine {
    private final Action action;
    private final ImmutableMap<String, Expr> conditions;

    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {
      this.action = action;
      this.conditions = conditions;
    }
  }

  private final List<RbacEngine> rbacEngines;

  /**
   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.
   * The constructor can take either one or two Envoy RBACs.
   * When it takes two RBACs, the order has to be a RBAC with DENY action
   * followed by a RBAC with ALLOW action.
   * @param rbacPolicies input Envoy RBAC list.
   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.
   */
  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {
    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {
      throw new IllegalArgumentException(
        "Invalid RBAC list size, must provide either one RBAC or two RBACs. ");
    } 
    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY 
        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {
      throw new IllegalArgumentException( "Invalid RBAC list, " 
          + "must provide a RBAC with DENY action followed by a RBAC with ALLOW action. ");
    }
    this.rbacEngines = new ArrayList<>();
    for (RBAC rbac : rbacPolicies) {
      Map<String, Expr> conditions = new HashMap<>();
      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {
        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());
      }
      this.rbacEngines.add(new RbacEngine(
          Preconditions.checkNotNull(rbac.getAction()), 
          Preconditions.checkNotNull(ImmutableMap.copyOf(conditions))));
    }
  }

  /**
   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.
   * Determines whether a gRPC call is allowed, denied, or unable to decide.
   * @param args evaluate argument that is used to evaluate the RBAC conditions.
   * @return an AuthorizationDecision generated by CEL Evaluation Engine.
   * @throws InterpreterException if something goes wrong in CEL library.
   */
  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) 
      throws IllegalArgumentException {
    if (this.rbacEngines.size() < 1 || this.rbacEngines.size() > 2) {
      throw new IllegalArgumentException(
        "Invalid RBAC list size, must provide either one RBAC or two RBACs. ");
    } 
    if (this.rbacEngines.size() == 2 && (this.rbacEngines.get(0).action != Action.DENY 
        || this.rbacEngines.get(1).action != Action.ALLOW)) {
      throw new IllegalArgumentException( "Invalid RBAC list, " 
          + "must provide a RBAC with DENY action followed by a RBAC with ALLOW action. ");
    }
    AuthorizationDecision.Decision authorizationDecision = null;
    List<String> matchingPolicyNames = new ArrayList<>();
    List<String> unknownPolicyNames = new ArrayList<>();
    // Set up activation used in CEL library's eval function.
    Activation activation = Activation.copyOf(extractFields(args));
    // Go through each RBAC in the Envoy RBAC list.
    for (RbacEngine rbacEngine : rbacEngines) {
      // Go through each condition in the RBAC policy.
      for (Map.Entry<String, Expr> condition : rbacEngine.conditions.entrySet()) {
        try {
          if (matches(condition.getValue(), activation)) {
            authorizationDecision = rbacEngine.action == Action.ALLOW 
                ? AuthorizationDecision.Decision.ALLOW : AuthorizationDecision.Decision.DENY;
            matchingPolicyNames.add(condition.getKey());
          }
        } catch (InterpreterException e) {
          unknownPolicyNames.add(condition.getKey());
        }
      }
      if (matchingPolicyNames.size() > 0) {
        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);
      }
      if (unknownPolicyNames.size() > 0) {
        return new AuthorizationDecision(
            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);
      }
    }
    // No RBAC conditions matched and didn't find unknown conditions.
    if (this.rbacEngines.size() == 1 && this.rbacEngines.get(0).action == Action.DENY) {
      return new AuthorizationDecision(
          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());
    }
    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());
  }

  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */
  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {
    // Set up interpreter used in CEL library's eval function.
    List<Descriptor> descriptors = new ArrayList<>();
    RuntimeTypeProvider messageProvider = DescriptorMessageProvider.dynamicMessages(descriptors);
    Dispatcher dispatcher = DefaultDispatcher.create();
    Interpreter interpreter = new DefaultInterpreter(messageProvider, dispatcher);
    Interpretable interpretable = interpreter.createInterpretable(condition);
    // Parse the generated result object to a boolean variable.
    try {
      Object result = interpretable.eval(activation);
      if (result instanceof Boolean) {
        return Boolean.valueOf(result.toString());
      }
      // Throw an InterpreterException if there are missing Envoy Attributes.
      if (result instanceof IncompleteData) {
        throw new InterpreterException.Builder("Incomplete Envoy Attributes to be evaluated.")
            .build(); 
      }
    } catch (InterpreterException e) {
      // If any InterpreterExceptions are catched, throw it and log the error.
      log.log(Level.WARNING, e.toString(), e);
      throw e;
    }
    return false;
  }

  /** Extract Envoy Attributes from EvaluateArgs. */
  protected ImmutableMap<String, Object> extractFields(EvaluateArgs<ReqT, RespT> args) {
    ImmutableMap<String, Object> attributes = ImmutableMap.<String, Object>builder()
        .put("request.url_path", args.getRequestUrlPath())
        .put("request.host", args.getRequestHost())
        .put("request.method", args.getRequestMethod())
        .put("request.headers", args.getRequestHeaders())
        .put("source.address", args.getSourceAddress())
        .put("source.port", args.getSourcePort())
        .put("destination.address", args.getDestinationAddress())
        .put("destination.port", args.getDestinationPort())
        .put("connection.uri_san_peer_certificate", 
            args.getConnectionUriSanPeerCertificate())
        .build();
    return attributes;
  }
}
