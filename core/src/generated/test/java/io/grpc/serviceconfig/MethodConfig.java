// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: grpc/service_config.proto

package io.grpc.serviceconfig;

/**
 * <pre>
 * Configuration for a method.
 * </pre>
 *
 * Protobuf type {@code grpc.MethodConfig}
 */
public  final class MethodConfig extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:grpc.MethodConfig)
    MethodConfigOrBuilder {
private static final long serialVersionUID = 0L;
  // Use MethodConfig.newBuilder() to construct.
  private MethodConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private MethodConfig() {
    name_ = java.util.Collections.emptyList();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private MethodConfig(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          default: {
            if (!parseUnknownFieldProto3(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
          case 10: {
            if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
              name_ = new java.util.ArrayList<io.grpc.serviceconfig.MethodConfig.Name>();
              mutable_bitField0_ |= 0x00000001;
            }
            name_.add(
                input.readMessage(io.grpc.serviceconfig.MethodConfig.Name.parser(), extensionRegistry));
            break;
          }
          case 18: {
            com.google.protobuf.BoolValue.Builder subBuilder = null;
            if (waitForReady_ != null) {
              subBuilder = waitForReady_.toBuilder();
            }
            waitForReady_ = input.readMessage(com.google.protobuf.BoolValue.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(waitForReady_);
              waitForReady_ = subBuilder.buildPartial();
            }

            break;
          }
          case 26: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (timeout_ != null) {
              subBuilder = timeout_.toBuilder();
            }
            timeout_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(timeout_);
              timeout_ = subBuilder.buildPartial();
            }

            break;
          }
          case 34: {
            com.google.protobuf.UInt32Value.Builder subBuilder = null;
            if (maxRequestMessageBytes_ != null) {
              subBuilder = maxRequestMessageBytes_.toBuilder();
            }
            maxRequestMessageBytes_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(maxRequestMessageBytes_);
              maxRequestMessageBytes_ = subBuilder.buildPartial();
            }

            break;
          }
          case 42: {
            com.google.protobuf.UInt32Value.Builder subBuilder = null;
            if (maxResponseMessageBytes_ != null) {
              subBuilder = maxResponseMessageBytes_.toBuilder();
            }
            maxResponseMessageBytes_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(maxResponseMessageBytes_);
              maxResponseMessageBytes_ = subBuilder.buildPartial();
            }

            break;
          }
          case 50: {
            io.grpc.serviceconfig.MethodConfig.RetryPolicy.Builder subBuilder = null;
            if (retryOrHedgingPolicyCase_ == 6) {
              subBuilder = ((io.grpc.serviceconfig.MethodConfig.RetryPolicy) retryOrHedgingPolicy_).toBuilder();
            }
            retryOrHedgingPolicy_ =
                input.readMessage(io.grpc.serviceconfig.MethodConfig.RetryPolicy.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.grpc.serviceconfig.MethodConfig.RetryPolicy) retryOrHedgingPolicy_);
              retryOrHedgingPolicy_ = subBuilder.buildPartial();
            }
            retryOrHedgingPolicyCase_ = 6;
            break;
          }
          case 58: {
            io.grpc.serviceconfig.MethodConfig.HedgingPolicy.Builder subBuilder = null;
            if (retryOrHedgingPolicyCase_ == 7) {
              subBuilder = ((io.grpc.serviceconfig.MethodConfig.HedgingPolicy) retryOrHedgingPolicy_).toBuilder();
            }
            retryOrHedgingPolicy_ =
                input.readMessage(io.grpc.serviceconfig.MethodConfig.HedgingPolicy.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom((io.grpc.serviceconfig.MethodConfig.HedgingPolicy) retryOrHedgingPolicy_);
              retryOrHedgingPolicy_ = subBuilder.buildPartial();
            }
            retryOrHedgingPolicyCase_ = 7;
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
        name_ = java.util.Collections.unmodifiableList(name_);
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_descriptor;
  }

  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.grpc.serviceconfig.MethodConfig.class, io.grpc.serviceconfig.MethodConfig.Builder.class);
  }

  public interface NameOrBuilder extends
      // @@protoc_insertion_point(interface_extends:grpc.MethodConfig.Name)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Required. Includes proto package name.
     * </pre>
     *
     * <code>string service = 1;</code>
     */
    java.lang.String getService();
    /**
     * <pre>
     * Required. Includes proto package name.
     * </pre>
     *
     * <code>string service = 1;</code>
     */
    com.google.protobuf.ByteString
        getServiceBytes();

    /**
     * <code>string method = 2;</code>
     */
    java.lang.String getMethod();
    /**
     * <code>string method = 2;</code>
     */
    com.google.protobuf.ByteString
        getMethodBytes();
  }
  /**
   * <pre>
   * The names of the methods to which this configuration applies. There must
   * be at least one name. Each name entry must be unique across the entire
   * ClientConfig. If the 'method' field is empty, then this MethodConfig
   * specifies the defaults for all methods for the specified service.
   * For example, let's say that the service config contains the following
   * MethodConfig entries:
   * method_config { name { service: "MyService" } ... }
   * method_config { name { service: "MyService" method: "Foo" } ... }
   * For a request for MyService/Foo, we will use the second entry, because it
   * exactly matches the service and method name.
   * For a request for MyService/Bar, we will use the first entry, because it
   * provides the default for all methods of MyService.
   * </pre>
   *
   * Protobuf type {@code grpc.MethodConfig.Name}
   */
  public  static final class Name extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:grpc.MethodConfig.Name)
      NameOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Name.newBuilder() to construct.
    private Name(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Name() {
      service_ = "";
      method_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Name(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              service_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              method_ = s;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_Name_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_Name_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.serviceconfig.MethodConfig.Name.class, io.grpc.serviceconfig.MethodConfig.Name.Builder.class);
    }

    public static final int SERVICE_FIELD_NUMBER = 1;
    private volatile java.lang.Object service_;
    /**
     * <pre>
     * Required. Includes proto package name.
     * </pre>
     *
     * <code>string service = 1;</code>
     */
    public java.lang.String getService() {
      java.lang.Object ref = service_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        service_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Required. Includes proto package name.
     * </pre>
     *
     * <code>string service = 1;</code>
     */
    public com.google.protobuf.ByteString
        getServiceBytes() {
      java.lang.Object ref = service_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        service_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int METHOD_FIELD_NUMBER = 2;
    private volatile java.lang.Object method_;
    /**
     * <code>string method = 2;</code>
     */
    public java.lang.String getMethod() {
      java.lang.Object ref = method_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        method_ = s;
        return s;
      }
    }
    /**
     * <code>string method = 2;</code>
     */
    public com.google.protobuf.ByteString
        getMethodBytes() {
      java.lang.Object ref = method_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        method_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getServiceBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, service_);
      }
      if (!getMethodBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, method_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getServiceBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, service_);
      }
      if (!getMethodBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, method_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.grpc.serviceconfig.MethodConfig.Name)) {
        return super.equals(obj);
      }
      io.grpc.serviceconfig.MethodConfig.Name other = (io.grpc.serviceconfig.MethodConfig.Name) obj;

      boolean result = true;
      result = result && getService()
          .equals(other.getService());
      result = result && getMethod()
          .equals(other.getMethod());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SERVICE_FIELD_NUMBER;
      hash = (53 * hash) + getService().hashCode();
      hash = (37 * hash) + METHOD_FIELD_NUMBER;
      hash = (53 * hash) + getMethod().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.grpc.serviceconfig.MethodConfig.Name parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.serviceconfig.MethodConfig.Name parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.Name parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.serviceconfig.MethodConfig.Name parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.Name parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.serviceconfig.MethodConfig.Name parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.Name parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.serviceconfig.MethodConfig.Name parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.Name parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.grpc.serviceconfig.MethodConfig.Name parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.Name parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.serviceconfig.MethodConfig.Name parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.grpc.serviceconfig.MethodConfig.Name prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The names of the methods to which this configuration applies. There must
     * be at least one name. Each name entry must be unique across the entire
     * ClientConfig. If the 'method' field is empty, then this MethodConfig
     * specifies the defaults for all methods for the specified service.
     * For example, let's say that the service config contains the following
     * MethodConfig entries:
     * method_config { name { service: "MyService" } ... }
     * method_config { name { service: "MyService" method: "Foo" } ... }
     * For a request for MyService/Foo, we will use the second entry, because it
     * exactly matches the service and method name.
     * For a request for MyService/Bar, we will use the first entry, because it
     * provides the default for all methods of MyService.
     * </pre>
     *
     * Protobuf type {@code grpc.MethodConfig.Name}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:grpc.MethodConfig.Name)
        io.grpc.serviceconfig.MethodConfig.NameOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_Name_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_Name_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.serviceconfig.MethodConfig.Name.class, io.grpc.serviceconfig.MethodConfig.Name.Builder.class);
      }

      // Construct using io.grpc.serviceconfig.MethodConfig.Name.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        service_ = "";

        method_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_Name_descriptor;
      }

      public io.grpc.serviceconfig.MethodConfig.Name getDefaultInstanceForType() {
        return io.grpc.serviceconfig.MethodConfig.Name.getDefaultInstance();
      }

      public io.grpc.serviceconfig.MethodConfig.Name build() {
        io.grpc.serviceconfig.MethodConfig.Name result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.grpc.serviceconfig.MethodConfig.Name buildPartial() {
        io.grpc.serviceconfig.MethodConfig.Name result = new io.grpc.serviceconfig.MethodConfig.Name(this);
        result.service_ = service_;
        result.method_ = method_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.grpc.serviceconfig.MethodConfig.Name) {
          return mergeFrom((io.grpc.serviceconfig.MethodConfig.Name)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.grpc.serviceconfig.MethodConfig.Name other) {
        if (other == io.grpc.serviceconfig.MethodConfig.Name.getDefaultInstance()) return this;
        if (!other.getService().isEmpty()) {
          service_ = other.service_;
          onChanged();
        }
        if (!other.getMethod().isEmpty()) {
          method_ = other.method_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.grpc.serviceconfig.MethodConfig.Name parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.grpc.serviceconfig.MethodConfig.Name) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object service_ = "";
      /**
       * <pre>
       * Required. Includes proto package name.
       * </pre>
       *
       * <code>string service = 1;</code>
       */
      public java.lang.String getService() {
        java.lang.Object ref = service_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          service_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Required. Includes proto package name.
       * </pre>
       *
       * <code>string service = 1;</code>
       */
      public com.google.protobuf.ByteString
          getServiceBytes() {
        java.lang.Object ref = service_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          service_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Required. Includes proto package name.
       * </pre>
       *
       * <code>string service = 1;</code>
       */
      public Builder setService(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        service_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Required. Includes proto package name.
       * </pre>
       *
       * <code>string service = 1;</code>
       */
      public Builder clearService() {
        
        service_ = getDefaultInstance().getService();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Required. Includes proto package name.
       * </pre>
       *
       * <code>string service = 1;</code>
       */
      public Builder setServiceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        service_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object method_ = "";
      /**
       * <code>string method = 2;</code>
       */
      public java.lang.String getMethod() {
        java.lang.Object ref = method_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          method_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string method = 2;</code>
       */
      public com.google.protobuf.ByteString
          getMethodBytes() {
        java.lang.Object ref = method_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          method_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string method = 2;</code>
       */
      public Builder setMethod(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        method_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string method = 2;</code>
       */
      public Builder clearMethod() {
        
        method_ = getDefaultInstance().getMethod();
        onChanged();
        return this;
      }
      /**
       * <code>string method = 2;</code>
       */
      public Builder setMethodBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        method_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:grpc.MethodConfig.Name)
    }

    // @@protoc_insertion_point(class_scope:grpc.MethodConfig.Name)
    private static final io.grpc.serviceconfig.MethodConfig.Name DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.grpc.serviceconfig.MethodConfig.Name();
    }

    public static io.grpc.serviceconfig.MethodConfig.Name getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Name>
        PARSER = new com.google.protobuf.AbstractParser<Name>() {
      public Name parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Name(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Name> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Name> getParserForType() {
      return PARSER;
    }

    public io.grpc.serviceconfig.MethodConfig.Name getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RetryPolicyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:grpc.MethodConfig.RetryPolicy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The maximum number of retry attempts, exclusive of the original RPC.
     * This field is required and must be greater than zero.
     * </pre>
     *
     * <code>uint32 max_attempts = 1;</code>
     */
    int getMaxAttempts();

    /**
     * <pre>
     * Exponential backoff parameters. The initial retry attempt will occur at
     * random(0, initial_backoff). In general, the nth attempt will occur at
     * random(0,
     *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_backoff = 2;</code>
     */
    boolean hasInitialBackoff();
    /**
     * <pre>
     * Exponential backoff parameters. The initial retry attempt will occur at
     * random(0, initial_backoff). In general, the nth attempt will occur at
     * random(0,
     *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_backoff = 2;</code>
     */
    com.google.protobuf.Duration getInitialBackoff();
    /**
     * <pre>
     * Exponential backoff parameters. The initial retry attempt will occur at
     * random(0, initial_backoff). In general, the nth attempt will occur at
     * random(0,
     *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_backoff = 2;</code>
     */
    com.google.protobuf.DurationOrBuilder getInitialBackoffOrBuilder();

    /**
     * <pre>
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_backoff = 3;</code>
     */
    boolean hasMaxBackoff();
    /**
     * <pre>
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_backoff = 3;</code>
     */
    com.google.protobuf.Duration getMaxBackoff();
    /**
     * <pre>
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_backoff = 3;</code>
     */
    com.google.protobuf.DurationOrBuilder getMaxBackoffOrBuilder();

    /**
     * <pre>
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>float backoff_multiplier = 4;</code>
     */
    float getBackoffMultiplier();

    /**
     * <pre>
     * The set of status codes which may be retried.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
     */
    java.util.List<com.google.rpc.Code> getRetryableStatusCodesList();
    /**
     * <pre>
     * The set of status codes which may be retried.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
     */
    int getRetryableStatusCodesCount();
    /**
     * <pre>
     * The set of status codes which may be retried.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
     */
    com.google.rpc.Code getRetryableStatusCodes(int index);
    /**
     * <pre>
     * The set of status codes which may be retried.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
     */
    java.util.List<java.lang.Integer>
    getRetryableStatusCodesValueList();
    /**
     * <pre>
     * The set of status codes which may be retried.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
     */
    int getRetryableStatusCodesValue(int index);
  }
  /**
   * <pre>
   * The retry policy for outgoing RPCs.
   * </pre>
   *
   * Protobuf type {@code grpc.MethodConfig.RetryPolicy}
   */
  public  static final class RetryPolicy extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:grpc.MethodConfig.RetryPolicy)
      RetryPolicyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RetryPolicy.newBuilder() to construct.
    private RetryPolicy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RetryPolicy() {
      maxAttempts_ = 0;
      backoffMultiplier_ = 0F;
      retryableStatusCodes_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private RetryPolicy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              maxAttempts_ = input.readUInt32();
              break;
            }
            case 18: {
              com.google.protobuf.Duration.Builder subBuilder = null;
              if (initialBackoff_ != null) {
                subBuilder = initialBackoff_.toBuilder();
              }
              initialBackoff_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(initialBackoff_);
                initialBackoff_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              com.google.protobuf.Duration.Builder subBuilder = null;
              if (maxBackoff_ != null) {
                subBuilder = maxBackoff_.toBuilder();
              }
              maxBackoff_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(maxBackoff_);
                maxBackoff_ = subBuilder.buildPartial();
              }

              break;
            }
            case 37: {

              backoffMultiplier_ = input.readFloat();
              break;
            }
            case 40: {
              int rawValue = input.readEnum();
              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                retryableStatusCodes_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000010;
              }
              retryableStatusCodes_.add(rawValue);
              break;
            }
            case 42: {
              int length = input.readRawVarint32();
              int oldLimit = input.pushLimit(length);
              while(input.getBytesUntilLimit() > 0) {
                int rawValue = input.readEnum();
                if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
                  retryableStatusCodes_ = new java.util.ArrayList<java.lang.Integer>();
                  mutable_bitField0_ |= 0x00000010;
                }
                retryableStatusCodes_.add(rawValue);
              }
              input.popLimit(oldLimit);
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000010) == 0x00000010)) {
          retryableStatusCodes_ = java.util.Collections.unmodifiableList(retryableStatusCodes_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_RetryPolicy_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_RetryPolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.serviceconfig.MethodConfig.RetryPolicy.class, io.grpc.serviceconfig.MethodConfig.RetryPolicy.Builder.class);
    }

    private int bitField0_;
    public static final int MAX_ATTEMPTS_FIELD_NUMBER = 1;
    private int maxAttempts_;
    /**
     * <pre>
     * The maximum number of retry attempts, exclusive of the original RPC.
     * This field is required and must be greater than zero.
     * </pre>
     *
     * <code>uint32 max_attempts = 1;</code>
     */
    public int getMaxAttempts() {
      return maxAttempts_;
    }

    public static final int INITIAL_BACKOFF_FIELD_NUMBER = 2;
    private com.google.protobuf.Duration initialBackoff_;
    /**
     * <pre>
     * Exponential backoff parameters. The initial retry attempt will occur at
     * random(0, initial_backoff). In general, the nth attempt will occur at
     * random(0,
     *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_backoff = 2;</code>
     */
    public boolean hasInitialBackoff() {
      return initialBackoff_ != null;
    }
    /**
     * <pre>
     * Exponential backoff parameters. The initial retry attempt will occur at
     * random(0, initial_backoff). In general, the nth attempt will occur at
     * random(0,
     *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_backoff = 2;</code>
     */
    public com.google.protobuf.Duration getInitialBackoff() {
      return initialBackoff_ == null ? com.google.protobuf.Duration.getDefaultInstance() : initialBackoff_;
    }
    /**
     * <pre>
     * Exponential backoff parameters. The initial retry attempt will occur at
     * random(0, initial_backoff). In general, the nth attempt will occur at
     * random(0,
     *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>.google.protobuf.Duration initial_backoff = 2;</code>
     */
    public com.google.protobuf.DurationOrBuilder getInitialBackoffOrBuilder() {
      return getInitialBackoff();
    }

    public static final int MAX_BACKOFF_FIELD_NUMBER = 3;
    private com.google.protobuf.Duration maxBackoff_;
    /**
     * <pre>
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_backoff = 3;</code>
     */
    public boolean hasMaxBackoff() {
      return maxBackoff_ != null;
    }
    /**
     * <pre>
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_backoff = 3;</code>
     */
    public com.google.protobuf.Duration getMaxBackoff() {
      return maxBackoff_ == null ? com.google.protobuf.Duration.getDefaultInstance() : maxBackoff_;
    }
    /**
     * <pre>
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>.google.protobuf.Duration max_backoff = 3;</code>
     */
    public com.google.protobuf.DurationOrBuilder getMaxBackoffOrBuilder() {
      return getMaxBackoff();
    }

    public static final int BACKOFF_MULTIPLIER_FIELD_NUMBER = 4;
    private float backoffMultiplier_;
    /**
     * <pre>
     * Required. Must be greater than zero.
     * </pre>
     *
     * <code>float backoff_multiplier = 4;</code>
     */
    public float getBackoffMultiplier() {
      return backoffMultiplier_;
    }

    public static final int RETRYABLE_STATUS_CODES_FIELD_NUMBER = 5;
    private java.util.List<java.lang.Integer> retryableStatusCodes_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, com.google.rpc.Code> retryableStatusCodes_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, com.google.rpc.Code>() {
              public com.google.rpc.Code convert(java.lang.Integer from) {
                com.google.rpc.Code result = com.google.rpc.Code.valueOf(from);
                return result == null ? com.google.rpc.Code.UNRECOGNIZED : result;
              }
            };
    /**
     * <pre>
     * The set of status codes which may be retried.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
     */
    public java.util.List<com.google.rpc.Code> getRetryableStatusCodesList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, com.google.rpc.Code>(retryableStatusCodes_, retryableStatusCodes_converter_);
    }
    /**
     * <pre>
     * The set of status codes which may be retried.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
     */
    public int getRetryableStatusCodesCount() {
      return retryableStatusCodes_.size();
    }
    /**
     * <pre>
     * The set of status codes which may be retried.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
     */
    public com.google.rpc.Code getRetryableStatusCodes(int index) {
      return retryableStatusCodes_converter_.convert(retryableStatusCodes_.get(index));
    }
    /**
     * <pre>
     * The set of status codes which may be retried.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
     */
    public java.util.List<java.lang.Integer>
    getRetryableStatusCodesValueList() {
      return retryableStatusCodes_;
    }
    /**
     * <pre>
     * The set of status codes which may be retried.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
     */
    public int getRetryableStatusCodesValue(int index) {
      return retryableStatusCodes_.get(index);
    }
    private int retryableStatusCodesMemoizedSerializedSize;

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (maxAttempts_ != 0) {
        output.writeUInt32(1, maxAttempts_);
      }
      if (initialBackoff_ != null) {
        output.writeMessage(2, getInitialBackoff());
      }
      if (maxBackoff_ != null) {
        output.writeMessage(3, getMaxBackoff());
      }
      if (backoffMultiplier_ != 0F) {
        output.writeFloat(4, backoffMultiplier_);
      }
      if (getRetryableStatusCodesList().size() > 0) {
        output.writeUInt32NoTag(42);
        output.writeUInt32NoTag(retryableStatusCodesMemoizedSerializedSize);
      }
      for (int i = 0; i < retryableStatusCodes_.size(); i++) {
        output.writeEnumNoTag(retryableStatusCodes_.get(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (maxAttempts_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, maxAttempts_);
      }
      if (initialBackoff_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getInitialBackoff());
      }
      if (maxBackoff_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getMaxBackoff());
      }
      if (backoffMultiplier_ != 0F) {
        size += com.google.protobuf.CodedOutputStream
          .computeFloatSize(4, backoffMultiplier_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < retryableStatusCodes_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(retryableStatusCodes_.get(i));
        }
        size += dataSize;
        if (!getRetryableStatusCodesList().isEmpty()) {  size += 1;
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32SizeNoTag(dataSize);
        }retryableStatusCodesMemoizedSerializedSize = dataSize;
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.grpc.serviceconfig.MethodConfig.RetryPolicy)) {
        return super.equals(obj);
      }
      io.grpc.serviceconfig.MethodConfig.RetryPolicy other = (io.grpc.serviceconfig.MethodConfig.RetryPolicy) obj;

      boolean result = true;
      result = result && (getMaxAttempts()
          == other.getMaxAttempts());
      result = result && (hasInitialBackoff() == other.hasInitialBackoff());
      if (hasInitialBackoff()) {
        result = result && getInitialBackoff()
            .equals(other.getInitialBackoff());
      }
      result = result && (hasMaxBackoff() == other.hasMaxBackoff());
      if (hasMaxBackoff()) {
        result = result && getMaxBackoff()
            .equals(other.getMaxBackoff());
      }
      result = result && (
          java.lang.Float.floatToIntBits(getBackoffMultiplier())
          == java.lang.Float.floatToIntBits(
              other.getBackoffMultiplier()));
      result = result && retryableStatusCodes_.equals(other.retryableStatusCodes_);
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MAX_ATTEMPTS_FIELD_NUMBER;
      hash = (53 * hash) + getMaxAttempts();
      if (hasInitialBackoff()) {
        hash = (37 * hash) + INITIAL_BACKOFF_FIELD_NUMBER;
        hash = (53 * hash) + getInitialBackoff().hashCode();
      }
      if (hasMaxBackoff()) {
        hash = (37 * hash) + MAX_BACKOFF_FIELD_NUMBER;
        hash = (53 * hash) + getMaxBackoff().hashCode();
      }
      hash = (37 * hash) + BACKOFF_MULTIPLIER_FIELD_NUMBER;
      hash = (53 * hash) + java.lang.Float.floatToIntBits(
          getBackoffMultiplier());
      if (getRetryableStatusCodesCount() > 0) {
        hash = (37 * hash) + RETRYABLE_STATUS_CODES_FIELD_NUMBER;
        hash = (53 * hash) + retryableStatusCodes_.hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.grpc.serviceconfig.MethodConfig.RetryPolicy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The retry policy for outgoing RPCs.
     * </pre>
     *
     * Protobuf type {@code grpc.MethodConfig.RetryPolicy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:grpc.MethodConfig.RetryPolicy)
        io.grpc.serviceconfig.MethodConfig.RetryPolicyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_RetryPolicy_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_RetryPolicy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.serviceconfig.MethodConfig.RetryPolicy.class, io.grpc.serviceconfig.MethodConfig.RetryPolicy.Builder.class);
      }

      // Construct using io.grpc.serviceconfig.MethodConfig.RetryPolicy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        maxAttempts_ = 0;

        if (initialBackoffBuilder_ == null) {
          initialBackoff_ = null;
        } else {
          initialBackoff_ = null;
          initialBackoffBuilder_ = null;
        }
        if (maxBackoffBuilder_ == null) {
          maxBackoff_ = null;
        } else {
          maxBackoff_ = null;
          maxBackoffBuilder_ = null;
        }
        backoffMultiplier_ = 0F;

        retryableStatusCodes_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_RetryPolicy_descriptor;
      }

      public io.grpc.serviceconfig.MethodConfig.RetryPolicy getDefaultInstanceForType() {
        return io.grpc.serviceconfig.MethodConfig.RetryPolicy.getDefaultInstance();
      }

      public io.grpc.serviceconfig.MethodConfig.RetryPolicy build() {
        io.grpc.serviceconfig.MethodConfig.RetryPolicy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.grpc.serviceconfig.MethodConfig.RetryPolicy buildPartial() {
        io.grpc.serviceconfig.MethodConfig.RetryPolicy result = new io.grpc.serviceconfig.MethodConfig.RetryPolicy(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.maxAttempts_ = maxAttempts_;
        if (initialBackoffBuilder_ == null) {
          result.initialBackoff_ = initialBackoff_;
        } else {
          result.initialBackoff_ = initialBackoffBuilder_.build();
        }
        if (maxBackoffBuilder_ == null) {
          result.maxBackoff_ = maxBackoff_;
        } else {
          result.maxBackoff_ = maxBackoffBuilder_.build();
        }
        result.backoffMultiplier_ = backoffMultiplier_;
        if (((bitField0_ & 0x00000010) == 0x00000010)) {
          retryableStatusCodes_ = java.util.Collections.unmodifiableList(retryableStatusCodes_);
          bitField0_ = (bitField0_ & ~0x00000010);
        }
        result.retryableStatusCodes_ = retryableStatusCodes_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.grpc.serviceconfig.MethodConfig.RetryPolicy) {
          return mergeFrom((io.grpc.serviceconfig.MethodConfig.RetryPolicy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.grpc.serviceconfig.MethodConfig.RetryPolicy other) {
        if (other == io.grpc.serviceconfig.MethodConfig.RetryPolicy.getDefaultInstance()) return this;
        if (other.getMaxAttempts() != 0) {
          setMaxAttempts(other.getMaxAttempts());
        }
        if (other.hasInitialBackoff()) {
          mergeInitialBackoff(other.getInitialBackoff());
        }
        if (other.hasMaxBackoff()) {
          mergeMaxBackoff(other.getMaxBackoff());
        }
        if (other.getBackoffMultiplier() != 0F) {
          setBackoffMultiplier(other.getBackoffMultiplier());
        }
        if (!other.retryableStatusCodes_.isEmpty()) {
          if (retryableStatusCodes_.isEmpty()) {
            retryableStatusCodes_ = other.retryableStatusCodes_;
            bitField0_ = (bitField0_ & ~0x00000010);
          } else {
            ensureRetryableStatusCodesIsMutable();
            retryableStatusCodes_.addAll(other.retryableStatusCodes_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.grpc.serviceconfig.MethodConfig.RetryPolicy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.grpc.serviceconfig.MethodConfig.RetryPolicy) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int maxAttempts_ ;
      /**
       * <pre>
       * The maximum number of retry attempts, exclusive of the original RPC.
       * This field is required and must be greater than zero.
       * </pre>
       *
       * <code>uint32 max_attempts = 1;</code>
       */
      public int getMaxAttempts() {
        return maxAttempts_;
      }
      /**
       * <pre>
       * The maximum number of retry attempts, exclusive of the original RPC.
       * This field is required and must be greater than zero.
       * </pre>
       *
       * <code>uint32 max_attempts = 1;</code>
       */
      public Builder setMaxAttempts(int value) {
        
        maxAttempts_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of retry attempts, exclusive of the original RPC.
       * This field is required and must be greater than zero.
       * </pre>
       *
       * <code>uint32 max_attempts = 1;</code>
       */
      public Builder clearMaxAttempts() {
        
        maxAttempts_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.Duration initialBackoff_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> initialBackoffBuilder_;
      /**
       * <pre>
       * Exponential backoff parameters. The initial retry attempt will occur at
       * random(0, initial_backoff). In general, the nth attempt will occur at
       * random(0,
       *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration initial_backoff = 2;</code>
       */
      public boolean hasInitialBackoff() {
        return initialBackoffBuilder_ != null || initialBackoff_ != null;
      }
      /**
       * <pre>
       * Exponential backoff parameters. The initial retry attempt will occur at
       * random(0, initial_backoff). In general, the nth attempt will occur at
       * random(0,
       *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration initial_backoff = 2;</code>
       */
      public com.google.protobuf.Duration getInitialBackoff() {
        if (initialBackoffBuilder_ == null) {
          return initialBackoff_ == null ? com.google.protobuf.Duration.getDefaultInstance() : initialBackoff_;
        } else {
          return initialBackoffBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Exponential backoff parameters. The initial retry attempt will occur at
       * random(0, initial_backoff). In general, the nth attempt will occur at
       * random(0,
       *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration initial_backoff = 2;</code>
       */
      public Builder setInitialBackoff(com.google.protobuf.Duration value) {
        if (initialBackoffBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          initialBackoff_ = value;
          onChanged();
        } else {
          initialBackoffBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Exponential backoff parameters. The initial retry attempt will occur at
       * random(0, initial_backoff). In general, the nth attempt will occur at
       * random(0,
       *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration initial_backoff = 2;</code>
       */
      public Builder setInitialBackoff(
          com.google.protobuf.Duration.Builder builderForValue) {
        if (initialBackoffBuilder_ == null) {
          initialBackoff_ = builderForValue.build();
          onChanged();
        } else {
          initialBackoffBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Exponential backoff parameters. The initial retry attempt will occur at
       * random(0, initial_backoff). In general, the nth attempt will occur at
       * random(0,
       *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration initial_backoff = 2;</code>
       */
      public Builder mergeInitialBackoff(com.google.protobuf.Duration value) {
        if (initialBackoffBuilder_ == null) {
          if (initialBackoff_ != null) {
            initialBackoff_ =
              com.google.protobuf.Duration.newBuilder(initialBackoff_).mergeFrom(value).buildPartial();
          } else {
            initialBackoff_ = value;
          }
          onChanged();
        } else {
          initialBackoffBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Exponential backoff parameters. The initial retry attempt will occur at
       * random(0, initial_backoff). In general, the nth attempt will occur at
       * random(0,
       *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration initial_backoff = 2;</code>
       */
      public Builder clearInitialBackoff() {
        if (initialBackoffBuilder_ == null) {
          initialBackoff_ = null;
          onChanged();
        } else {
          initialBackoff_ = null;
          initialBackoffBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Exponential backoff parameters. The initial retry attempt will occur at
       * random(0, initial_backoff). In general, the nth attempt will occur at
       * random(0,
       *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration initial_backoff = 2;</code>
       */
      public com.google.protobuf.Duration.Builder getInitialBackoffBuilder() {
        
        onChanged();
        return getInitialBackoffFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Exponential backoff parameters. The initial retry attempt will occur at
       * random(0, initial_backoff). In general, the nth attempt will occur at
       * random(0,
       *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration initial_backoff = 2;</code>
       */
      public com.google.protobuf.DurationOrBuilder getInitialBackoffOrBuilder() {
        if (initialBackoffBuilder_ != null) {
          return initialBackoffBuilder_.getMessageOrBuilder();
        } else {
          return initialBackoff_ == null ?
              com.google.protobuf.Duration.getDefaultInstance() : initialBackoff_;
        }
      }
      /**
       * <pre>
       * Exponential backoff parameters. The initial retry attempt will occur at
       * random(0, initial_backoff). In general, the nth attempt will occur at
       * random(0,
       *   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration initial_backoff = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
          getInitialBackoffFieldBuilder() {
        if (initialBackoffBuilder_ == null) {
          initialBackoffBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                  getInitialBackoff(),
                  getParentForChildren(),
                  isClean());
          initialBackoff_ = null;
        }
        return initialBackoffBuilder_;
      }

      private com.google.protobuf.Duration maxBackoff_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> maxBackoffBuilder_;
      /**
       * <pre>
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_backoff = 3;</code>
       */
      public boolean hasMaxBackoff() {
        return maxBackoffBuilder_ != null || maxBackoff_ != null;
      }
      /**
       * <pre>
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_backoff = 3;</code>
       */
      public com.google.protobuf.Duration getMaxBackoff() {
        if (maxBackoffBuilder_ == null) {
          return maxBackoff_ == null ? com.google.protobuf.Duration.getDefaultInstance() : maxBackoff_;
        } else {
          return maxBackoffBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_backoff = 3;</code>
       */
      public Builder setMaxBackoff(com.google.protobuf.Duration value) {
        if (maxBackoffBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxBackoff_ = value;
          onChanged();
        } else {
          maxBackoffBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_backoff = 3;</code>
       */
      public Builder setMaxBackoff(
          com.google.protobuf.Duration.Builder builderForValue) {
        if (maxBackoffBuilder_ == null) {
          maxBackoff_ = builderForValue.build();
          onChanged();
        } else {
          maxBackoffBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_backoff = 3;</code>
       */
      public Builder mergeMaxBackoff(com.google.protobuf.Duration value) {
        if (maxBackoffBuilder_ == null) {
          if (maxBackoff_ != null) {
            maxBackoff_ =
              com.google.protobuf.Duration.newBuilder(maxBackoff_).mergeFrom(value).buildPartial();
          } else {
            maxBackoff_ = value;
          }
          onChanged();
        } else {
          maxBackoffBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_backoff = 3;</code>
       */
      public Builder clearMaxBackoff() {
        if (maxBackoffBuilder_ == null) {
          maxBackoff_ = null;
          onChanged();
        } else {
          maxBackoff_ = null;
          maxBackoffBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_backoff = 3;</code>
       */
      public com.google.protobuf.Duration.Builder getMaxBackoffBuilder() {
        
        onChanged();
        return getMaxBackoffFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_backoff = 3;</code>
       */
      public com.google.protobuf.DurationOrBuilder getMaxBackoffOrBuilder() {
        if (maxBackoffBuilder_ != null) {
          return maxBackoffBuilder_.getMessageOrBuilder();
        } else {
          return maxBackoff_ == null ?
              com.google.protobuf.Duration.getDefaultInstance() : maxBackoff_;
        }
      }
      /**
       * <pre>
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>.google.protobuf.Duration max_backoff = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
          getMaxBackoffFieldBuilder() {
        if (maxBackoffBuilder_ == null) {
          maxBackoffBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                  getMaxBackoff(),
                  getParentForChildren(),
                  isClean());
          maxBackoff_ = null;
        }
        return maxBackoffBuilder_;
      }

      private float backoffMultiplier_ ;
      /**
       * <pre>
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>float backoff_multiplier = 4;</code>
       */
      public float getBackoffMultiplier() {
        return backoffMultiplier_;
      }
      /**
       * <pre>
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>float backoff_multiplier = 4;</code>
       */
      public Builder setBackoffMultiplier(float value) {
        
        backoffMultiplier_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Required. Must be greater than zero.
       * </pre>
       *
       * <code>float backoff_multiplier = 4;</code>
       */
      public Builder clearBackoffMultiplier() {
        
        backoffMultiplier_ = 0F;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> retryableStatusCodes_ =
        java.util.Collections.emptyList();
      private void ensureRetryableStatusCodesIsMutable() {
        if (!((bitField0_ & 0x00000010) == 0x00000010)) {
          retryableStatusCodes_ = new java.util.ArrayList<java.lang.Integer>(retryableStatusCodes_);
          bitField0_ |= 0x00000010;
        }
      }
      /**
       * <pre>
       * The set of status codes which may be retried.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
       */
      public java.util.List<com.google.rpc.Code> getRetryableStatusCodesList() {
        return new com.google.protobuf.Internal.ListAdapter<
            java.lang.Integer, com.google.rpc.Code>(retryableStatusCodes_, retryableStatusCodes_converter_);
      }
      /**
       * <pre>
       * The set of status codes which may be retried.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
       */
      public int getRetryableStatusCodesCount() {
        return retryableStatusCodes_.size();
      }
      /**
       * <pre>
       * The set of status codes which may be retried.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
       */
      public com.google.rpc.Code getRetryableStatusCodes(int index) {
        return retryableStatusCodes_converter_.convert(retryableStatusCodes_.get(index));
      }
      /**
       * <pre>
       * The set of status codes which may be retried.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
       */
      public Builder setRetryableStatusCodes(
          int index, com.google.rpc.Code value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRetryableStatusCodesIsMutable();
        retryableStatusCodes_.set(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The set of status codes which may be retried.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
       */
      public Builder addRetryableStatusCodes(com.google.rpc.Code value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureRetryableStatusCodesIsMutable();
        retryableStatusCodes_.add(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The set of status codes which may be retried.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
       */
      public Builder addAllRetryableStatusCodes(
          java.lang.Iterable<? extends com.google.rpc.Code> values) {
        ensureRetryableStatusCodesIsMutable();
        for (com.google.rpc.Code value : values) {
          retryableStatusCodes_.add(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The set of status codes which may be retried.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
       */
      public Builder clearRetryableStatusCodes() {
        retryableStatusCodes_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The set of status codes which may be retried.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
       */
      public java.util.List<java.lang.Integer>
      getRetryableStatusCodesValueList() {
        return java.util.Collections.unmodifiableList(retryableStatusCodes_);
      }
      /**
       * <pre>
       * The set of status codes which may be retried.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
       */
      public int getRetryableStatusCodesValue(int index) {
        return retryableStatusCodes_.get(index);
      }
      /**
       * <pre>
       * The set of status codes which may be retried.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
       */
      public Builder setRetryableStatusCodesValue(
          int index, int value) {
        ensureRetryableStatusCodesIsMutable();
        retryableStatusCodes_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The set of status codes which may be retried.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
       */
      public Builder addRetryableStatusCodesValue(int value) {
        ensureRetryableStatusCodesIsMutable();
        retryableStatusCodes_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The set of status codes which may be retried.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code retryable_status_codes = 5;</code>
       */
      public Builder addAllRetryableStatusCodesValue(
          java.lang.Iterable<java.lang.Integer> values) {
        ensureRetryableStatusCodesIsMutable();
        for (int value : values) {
          retryableStatusCodes_.add(value);
        }
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:grpc.MethodConfig.RetryPolicy)
    }

    // @@protoc_insertion_point(class_scope:grpc.MethodConfig.RetryPolicy)
    private static final io.grpc.serviceconfig.MethodConfig.RetryPolicy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.grpc.serviceconfig.MethodConfig.RetryPolicy();
    }

    public static io.grpc.serviceconfig.MethodConfig.RetryPolicy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RetryPolicy>
        PARSER = new com.google.protobuf.AbstractParser<RetryPolicy>() {
      public RetryPolicy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new RetryPolicy(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<RetryPolicy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RetryPolicy> getParserForType() {
      return PARSER;
    }

    public io.grpc.serviceconfig.MethodConfig.RetryPolicy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface HedgingPolicyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:grpc.MethodConfig.HedgingPolicy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The hedging policy will send up to max_requests copies of the hedged
     * RPC. This number is inclusive of all requests, including the original
     * RPC.
     * This field is required and must be greater than 1.
     * </pre>
     *
     * <code>uint32 max_attempts = 1;</code>
     */
    int getMaxAttempts();

    /**
     * <pre>
     * The first RPC will be sent immediately, but the max_requests-1 subsequent
     * hedged RPCs will be sent at intervals of every hedging_delay. Set this
     * to 0 to immediately send all max_requests RPCs.
     * </pre>
     *
     * <code>.google.protobuf.Duration hedging_delay = 2;</code>
     */
    boolean hasHedgingDelay();
    /**
     * <pre>
     * The first RPC will be sent immediately, but the max_requests-1 subsequent
     * hedged RPCs will be sent at intervals of every hedging_delay. Set this
     * to 0 to immediately send all max_requests RPCs.
     * </pre>
     *
     * <code>.google.protobuf.Duration hedging_delay = 2;</code>
     */
    com.google.protobuf.Duration getHedgingDelay();
    /**
     * <pre>
     * The first RPC will be sent immediately, but the max_requests-1 subsequent
     * hedged RPCs will be sent at intervals of every hedging_delay. Set this
     * to 0 to immediately send all max_requests RPCs.
     * </pre>
     *
     * <code>.google.protobuf.Duration hedging_delay = 2;</code>
     */
    com.google.protobuf.DurationOrBuilder getHedgingDelayOrBuilder();

    /**
     * <pre>
     * The set of status codes which indicate other hedged RPCs may still
     * succeed. If a non-fatal status code is returned by the server, hedged
     * RPCs will continue. Otherwise, outstanding requests will be canceled and
     * the error returned to the client application layer.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
     */
    java.util.List<com.google.rpc.Code> getNonFatalStatusCodesList();
    /**
     * <pre>
     * The set of status codes which indicate other hedged RPCs may still
     * succeed. If a non-fatal status code is returned by the server, hedged
     * RPCs will continue. Otherwise, outstanding requests will be canceled and
     * the error returned to the client application layer.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
     */
    int getNonFatalStatusCodesCount();
    /**
     * <pre>
     * The set of status codes which indicate other hedged RPCs may still
     * succeed. If a non-fatal status code is returned by the server, hedged
     * RPCs will continue. Otherwise, outstanding requests will be canceled and
     * the error returned to the client application layer.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
     */
    com.google.rpc.Code getNonFatalStatusCodes(int index);
    /**
     * <pre>
     * The set of status codes which indicate other hedged RPCs may still
     * succeed. If a non-fatal status code is returned by the server, hedged
     * RPCs will continue. Otherwise, outstanding requests will be canceled and
     * the error returned to the client application layer.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
     */
    java.util.List<java.lang.Integer>
    getNonFatalStatusCodesValueList();
    /**
     * <pre>
     * The set of status codes which indicate other hedged RPCs may still
     * succeed. If a non-fatal status code is returned by the server, hedged
     * RPCs will continue. Otherwise, outstanding requests will be canceled and
     * the error returned to the client application layer.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
     */
    int getNonFatalStatusCodesValue(int index);
  }
  /**
   * <pre>
   * The hedging policy for outgoing RPCs. Hedged RPCs may execute more than
   * once on the server, so only idempotent methods should specify a hedging
   * policy.
   * </pre>
   *
   * Protobuf type {@code grpc.MethodConfig.HedgingPolicy}
   */
  public  static final class HedgingPolicy extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:grpc.MethodConfig.HedgingPolicy)
      HedgingPolicyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use HedgingPolicy.newBuilder() to construct.
    private HedgingPolicy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private HedgingPolicy() {
      maxAttempts_ = 0;
      nonFatalStatusCodes_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private HedgingPolicy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              maxAttempts_ = input.readUInt32();
              break;
            }
            case 18: {
              com.google.protobuf.Duration.Builder subBuilder = null;
              if (hedgingDelay_ != null) {
                subBuilder = hedgingDelay_.toBuilder();
              }
              hedgingDelay_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(hedgingDelay_);
                hedgingDelay_ = subBuilder.buildPartial();
              }

              break;
            }
            case 24: {
              int rawValue = input.readEnum();
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                nonFatalStatusCodes_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000004;
              }
              nonFatalStatusCodes_.add(rawValue);
              break;
            }
            case 26: {
              int length = input.readRawVarint32();
              int oldLimit = input.pushLimit(length);
              while(input.getBytesUntilLimit() > 0) {
                int rawValue = input.readEnum();
                if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                  nonFatalStatusCodes_ = new java.util.ArrayList<java.lang.Integer>();
                  mutable_bitField0_ |= 0x00000004;
                }
                nonFatalStatusCodes_.add(rawValue);
              }
              input.popLimit(oldLimit);
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          nonFatalStatusCodes_ = java.util.Collections.unmodifiableList(nonFatalStatusCodes_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_HedgingPolicy_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_HedgingPolicy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.serviceconfig.MethodConfig.HedgingPolicy.class, io.grpc.serviceconfig.MethodConfig.HedgingPolicy.Builder.class);
    }

    private int bitField0_;
    public static final int MAX_ATTEMPTS_FIELD_NUMBER = 1;
    private int maxAttempts_;
    /**
     * <pre>
     * The hedging policy will send up to max_requests copies of the hedged
     * RPC. This number is inclusive of all requests, including the original
     * RPC.
     * This field is required and must be greater than 1.
     * </pre>
     *
     * <code>uint32 max_attempts = 1;</code>
     */
    public int getMaxAttempts() {
      return maxAttempts_;
    }

    public static final int HEDGING_DELAY_FIELD_NUMBER = 2;
    private com.google.protobuf.Duration hedgingDelay_;
    /**
     * <pre>
     * The first RPC will be sent immediately, but the max_requests-1 subsequent
     * hedged RPCs will be sent at intervals of every hedging_delay. Set this
     * to 0 to immediately send all max_requests RPCs.
     * </pre>
     *
     * <code>.google.protobuf.Duration hedging_delay = 2;</code>
     */
    public boolean hasHedgingDelay() {
      return hedgingDelay_ != null;
    }
    /**
     * <pre>
     * The first RPC will be sent immediately, but the max_requests-1 subsequent
     * hedged RPCs will be sent at intervals of every hedging_delay. Set this
     * to 0 to immediately send all max_requests RPCs.
     * </pre>
     *
     * <code>.google.protobuf.Duration hedging_delay = 2;</code>
     */
    public com.google.protobuf.Duration getHedgingDelay() {
      return hedgingDelay_ == null ? com.google.protobuf.Duration.getDefaultInstance() : hedgingDelay_;
    }
    /**
     * <pre>
     * The first RPC will be sent immediately, but the max_requests-1 subsequent
     * hedged RPCs will be sent at intervals of every hedging_delay. Set this
     * to 0 to immediately send all max_requests RPCs.
     * </pre>
     *
     * <code>.google.protobuf.Duration hedging_delay = 2;</code>
     */
    public com.google.protobuf.DurationOrBuilder getHedgingDelayOrBuilder() {
      return getHedgingDelay();
    }

    public static final int NON_FATAL_STATUS_CODES_FIELD_NUMBER = 3;
    private java.util.List<java.lang.Integer> nonFatalStatusCodes_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, com.google.rpc.Code> nonFatalStatusCodes_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, com.google.rpc.Code>() {
              public com.google.rpc.Code convert(java.lang.Integer from) {
                com.google.rpc.Code result = com.google.rpc.Code.valueOf(from);
                return result == null ? com.google.rpc.Code.UNRECOGNIZED : result;
              }
            };
    /**
     * <pre>
     * The set of status codes which indicate other hedged RPCs may still
     * succeed. If a non-fatal status code is returned by the server, hedged
     * RPCs will continue. Otherwise, outstanding requests will be canceled and
     * the error returned to the client application layer.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
     */
    public java.util.List<com.google.rpc.Code> getNonFatalStatusCodesList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, com.google.rpc.Code>(nonFatalStatusCodes_, nonFatalStatusCodes_converter_);
    }
    /**
     * <pre>
     * The set of status codes which indicate other hedged RPCs may still
     * succeed. If a non-fatal status code is returned by the server, hedged
     * RPCs will continue. Otherwise, outstanding requests will be canceled and
     * the error returned to the client application layer.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
     */
    public int getNonFatalStatusCodesCount() {
      return nonFatalStatusCodes_.size();
    }
    /**
     * <pre>
     * The set of status codes which indicate other hedged RPCs may still
     * succeed. If a non-fatal status code is returned by the server, hedged
     * RPCs will continue. Otherwise, outstanding requests will be canceled and
     * the error returned to the client application layer.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
     */
    public com.google.rpc.Code getNonFatalStatusCodes(int index) {
      return nonFatalStatusCodes_converter_.convert(nonFatalStatusCodes_.get(index));
    }
    /**
     * <pre>
     * The set of status codes which indicate other hedged RPCs may still
     * succeed. If a non-fatal status code is returned by the server, hedged
     * RPCs will continue. Otherwise, outstanding requests will be canceled and
     * the error returned to the client application layer.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
     */
    public java.util.List<java.lang.Integer>
    getNonFatalStatusCodesValueList() {
      return nonFatalStatusCodes_;
    }
    /**
     * <pre>
     * The set of status codes which indicate other hedged RPCs may still
     * succeed. If a non-fatal status code is returned by the server, hedged
     * RPCs will continue. Otherwise, outstanding requests will be canceled and
     * the error returned to the client application layer.
     * This field is required and must be non-empty.
     * </pre>
     *
     * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
     */
    public int getNonFatalStatusCodesValue(int index) {
      return nonFatalStatusCodes_.get(index);
    }
    private int nonFatalStatusCodesMemoizedSerializedSize;

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (maxAttempts_ != 0) {
        output.writeUInt32(1, maxAttempts_);
      }
      if (hedgingDelay_ != null) {
        output.writeMessage(2, getHedgingDelay());
      }
      if (getNonFatalStatusCodesList().size() > 0) {
        output.writeUInt32NoTag(26);
        output.writeUInt32NoTag(nonFatalStatusCodesMemoizedSerializedSize);
      }
      for (int i = 0; i < nonFatalStatusCodes_.size(); i++) {
        output.writeEnumNoTag(nonFatalStatusCodes_.get(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (maxAttempts_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, maxAttempts_);
      }
      if (hedgingDelay_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getHedgingDelay());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < nonFatalStatusCodes_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(nonFatalStatusCodes_.get(i));
        }
        size += dataSize;
        if (!getNonFatalStatusCodesList().isEmpty()) {  size += 1;
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32SizeNoTag(dataSize);
        }nonFatalStatusCodesMemoizedSerializedSize = dataSize;
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.grpc.serviceconfig.MethodConfig.HedgingPolicy)) {
        return super.equals(obj);
      }
      io.grpc.serviceconfig.MethodConfig.HedgingPolicy other = (io.grpc.serviceconfig.MethodConfig.HedgingPolicy) obj;

      boolean result = true;
      result = result && (getMaxAttempts()
          == other.getMaxAttempts());
      result = result && (hasHedgingDelay() == other.hasHedgingDelay());
      if (hasHedgingDelay()) {
        result = result && getHedgingDelay()
            .equals(other.getHedgingDelay());
      }
      result = result && nonFatalStatusCodes_.equals(other.nonFatalStatusCodes_);
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MAX_ATTEMPTS_FIELD_NUMBER;
      hash = (53 * hash) + getMaxAttempts();
      if (hasHedgingDelay()) {
        hash = (37 * hash) + HEDGING_DELAY_FIELD_NUMBER;
        hash = (53 * hash) + getHedgingDelay().hashCode();
      }
      if (getNonFatalStatusCodesCount() > 0) {
        hash = (37 * hash) + NON_FATAL_STATUS_CODES_FIELD_NUMBER;
        hash = (53 * hash) + nonFatalStatusCodes_.hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.grpc.serviceconfig.MethodConfig.HedgingPolicy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The hedging policy for outgoing RPCs. Hedged RPCs may execute more than
     * once on the server, so only idempotent methods should specify a hedging
     * policy.
     * </pre>
     *
     * Protobuf type {@code grpc.MethodConfig.HedgingPolicy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:grpc.MethodConfig.HedgingPolicy)
        io.grpc.serviceconfig.MethodConfig.HedgingPolicyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_HedgingPolicy_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_HedgingPolicy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.grpc.serviceconfig.MethodConfig.HedgingPolicy.class, io.grpc.serviceconfig.MethodConfig.HedgingPolicy.Builder.class);
      }

      // Construct using io.grpc.serviceconfig.MethodConfig.HedgingPolicy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        maxAttempts_ = 0;

        if (hedgingDelayBuilder_ == null) {
          hedgingDelay_ = null;
        } else {
          hedgingDelay_ = null;
          hedgingDelayBuilder_ = null;
        }
        nonFatalStatusCodes_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_HedgingPolicy_descriptor;
      }

      public io.grpc.serviceconfig.MethodConfig.HedgingPolicy getDefaultInstanceForType() {
        return io.grpc.serviceconfig.MethodConfig.HedgingPolicy.getDefaultInstance();
      }

      public io.grpc.serviceconfig.MethodConfig.HedgingPolicy build() {
        io.grpc.serviceconfig.MethodConfig.HedgingPolicy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.grpc.serviceconfig.MethodConfig.HedgingPolicy buildPartial() {
        io.grpc.serviceconfig.MethodConfig.HedgingPolicy result = new io.grpc.serviceconfig.MethodConfig.HedgingPolicy(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.maxAttempts_ = maxAttempts_;
        if (hedgingDelayBuilder_ == null) {
          result.hedgingDelay_ = hedgingDelay_;
        } else {
          result.hedgingDelay_ = hedgingDelayBuilder_.build();
        }
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          nonFatalStatusCodes_ = java.util.Collections.unmodifiableList(nonFatalStatusCodes_);
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.nonFatalStatusCodes_ = nonFatalStatusCodes_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.grpc.serviceconfig.MethodConfig.HedgingPolicy) {
          return mergeFrom((io.grpc.serviceconfig.MethodConfig.HedgingPolicy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.grpc.serviceconfig.MethodConfig.HedgingPolicy other) {
        if (other == io.grpc.serviceconfig.MethodConfig.HedgingPolicy.getDefaultInstance()) return this;
        if (other.getMaxAttempts() != 0) {
          setMaxAttempts(other.getMaxAttempts());
        }
        if (other.hasHedgingDelay()) {
          mergeHedgingDelay(other.getHedgingDelay());
        }
        if (!other.nonFatalStatusCodes_.isEmpty()) {
          if (nonFatalStatusCodes_.isEmpty()) {
            nonFatalStatusCodes_ = other.nonFatalStatusCodes_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureNonFatalStatusCodesIsMutable();
            nonFatalStatusCodes_.addAll(other.nonFatalStatusCodes_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.grpc.serviceconfig.MethodConfig.HedgingPolicy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.grpc.serviceconfig.MethodConfig.HedgingPolicy) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int maxAttempts_ ;
      /**
       * <pre>
       * The hedging policy will send up to max_requests copies of the hedged
       * RPC. This number is inclusive of all requests, including the original
       * RPC.
       * This field is required and must be greater than 1.
       * </pre>
       *
       * <code>uint32 max_attempts = 1;</code>
       */
      public int getMaxAttempts() {
        return maxAttempts_;
      }
      /**
       * <pre>
       * The hedging policy will send up to max_requests copies of the hedged
       * RPC. This number is inclusive of all requests, including the original
       * RPC.
       * This field is required and must be greater than 1.
       * </pre>
       *
       * <code>uint32 max_attempts = 1;</code>
       */
      public Builder setMaxAttempts(int value) {
        
        maxAttempts_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hedging policy will send up to max_requests copies of the hedged
       * RPC. This number is inclusive of all requests, including the original
       * RPC.
       * This field is required and must be greater than 1.
       * </pre>
       *
       * <code>uint32 max_attempts = 1;</code>
       */
      public Builder clearMaxAttempts() {
        
        maxAttempts_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.Duration hedgingDelay_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> hedgingDelayBuilder_;
      /**
       * <pre>
       * The first RPC will be sent immediately, but the max_requests-1 subsequent
       * hedged RPCs will be sent at intervals of every hedging_delay. Set this
       * to 0 to immediately send all max_requests RPCs.
       * </pre>
       *
       * <code>.google.protobuf.Duration hedging_delay = 2;</code>
       */
      public boolean hasHedgingDelay() {
        return hedgingDelayBuilder_ != null || hedgingDelay_ != null;
      }
      /**
       * <pre>
       * The first RPC will be sent immediately, but the max_requests-1 subsequent
       * hedged RPCs will be sent at intervals of every hedging_delay. Set this
       * to 0 to immediately send all max_requests RPCs.
       * </pre>
       *
       * <code>.google.protobuf.Duration hedging_delay = 2;</code>
       */
      public com.google.protobuf.Duration getHedgingDelay() {
        if (hedgingDelayBuilder_ == null) {
          return hedgingDelay_ == null ? com.google.protobuf.Duration.getDefaultInstance() : hedgingDelay_;
        } else {
          return hedgingDelayBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The first RPC will be sent immediately, but the max_requests-1 subsequent
       * hedged RPCs will be sent at intervals of every hedging_delay. Set this
       * to 0 to immediately send all max_requests RPCs.
       * </pre>
       *
       * <code>.google.protobuf.Duration hedging_delay = 2;</code>
       */
      public Builder setHedgingDelay(com.google.protobuf.Duration value) {
        if (hedgingDelayBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          hedgingDelay_ = value;
          onChanged();
        } else {
          hedgingDelayBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The first RPC will be sent immediately, but the max_requests-1 subsequent
       * hedged RPCs will be sent at intervals of every hedging_delay. Set this
       * to 0 to immediately send all max_requests RPCs.
       * </pre>
       *
       * <code>.google.protobuf.Duration hedging_delay = 2;</code>
       */
      public Builder setHedgingDelay(
          com.google.protobuf.Duration.Builder builderForValue) {
        if (hedgingDelayBuilder_ == null) {
          hedgingDelay_ = builderForValue.build();
          onChanged();
        } else {
          hedgingDelayBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The first RPC will be sent immediately, but the max_requests-1 subsequent
       * hedged RPCs will be sent at intervals of every hedging_delay. Set this
       * to 0 to immediately send all max_requests RPCs.
       * </pre>
       *
       * <code>.google.protobuf.Duration hedging_delay = 2;</code>
       */
      public Builder mergeHedgingDelay(com.google.protobuf.Duration value) {
        if (hedgingDelayBuilder_ == null) {
          if (hedgingDelay_ != null) {
            hedgingDelay_ =
              com.google.protobuf.Duration.newBuilder(hedgingDelay_).mergeFrom(value).buildPartial();
          } else {
            hedgingDelay_ = value;
          }
          onChanged();
        } else {
          hedgingDelayBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The first RPC will be sent immediately, but the max_requests-1 subsequent
       * hedged RPCs will be sent at intervals of every hedging_delay. Set this
       * to 0 to immediately send all max_requests RPCs.
       * </pre>
       *
       * <code>.google.protobuf.Duration hedging_delay = 2;</code>
       */
      public Builder clearHedgingDelay() {
        if (hedgingDelayBuilder_ == null) {
          hedgingDelay_ = null;
          onChanged();
        } else {
          hedgingDelay_ = null;
          hedgingDelayBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The first RPC will be sent immediately, but the max_requests-1 subsequent
       * hedged RPCs will be sent at intervals of every hedging_delay. Set this
       * to 0 to immediately send all max_requests RPCs.
       * </pre>
       *
       * <code>.google.protobuf.Duration hedging_delay = 2;</code>
       */
      public com.google.protobuf.Duration.Builder getHedgingDelayBuilder() {
        
        onChanged();
        return getHedgingDelayFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The first RPC will be sent immediately, but the max_requests-1 subsequent
       * hedged RPCs will be sent at intervals of every hedging_delay. Set this
       * to 0 to immediately send all max_requests RPCs.
       * </pre>
       *
       * <code>.google.protobuf.Duration hedging_delay = 2;</code>
       */
      public com.google.protobuf.DurationOrBuilder getHedgingDelayOrBuilder() {
        if (hedgingDelayBuilder_ != null) {
          return hedgingDelayBuilder_.getMessageOrBuilder();
        } else {
          return hedgingDelay_ == null ?
              com.google.protobuf.Duration.getDefaultInstance() : hedgingDelay_;
        }
      }
      /**
       * <pre>
       * The first RPC will be sent immediately, but the max_requests-1 subsequent
       * hedged RPCs will be sent at intervals of every hedging_delay. Set this
       * to 0 to immediately send all max_requests RPCs.
       * </pre>
       *
       * <code>.google.protobuf.Duration hedging_delay = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
          getHedgingDelayFieldBuilder() {
        if (hedgingDelayBuilder_ == null) {
          hedgingDelayBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                  getHedgingDelay(),
                  getParentForChildren(),
                  isClean());
          hedgingDelay_ = null;
        }
        return hedgingDelayBuilder_;
      }

      private java.util.List<java.lang.Integer> nonFatalStatusCodes_ =
        java.util.Collections.emptyList();
      private void ensureNonFatalStatusCodesIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          nonFatalStatusCodes_ = new java.util.ArrayList<java.lang.Integer>(nonFatalStatusCodes_);
          bitField0_ |= 0x00000004;
        }
      }
      /**
       * <pre>
       * The set of status codes which indicate other hedged RPCs may still
       * succeed. If a non-fatal status code is returned by the server, hedged
       * RPCs will continue. Otherwise, outstanding requests will be canceled and
       * the error returned to the client application layer.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
       */
      public java.util.List<com.google.rpc.Code> getNonFatalStatusCodesList() {
        return new com.google.protobuf.Internal.ListAdapter<
            java.lang.Integer, com.google.rpc.Code>(nonFatalStatusCodes_, nonFatalStatusCodes_converter_);
      }
      /**
       * <pre>
       * The set of status codes which indicate other hedged RPCs may still
       * succeed. If a non-fatal status code is returned by the server, hedged
       * RPCs will continue. Otherwise, outstanding requests will be canceled and
       * the error returned to the client application layer.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
       */
      public int getNonFatalStatusCodesCount() {
        return nonFatalStatusCodes_.size();
      }
      /**
       * <pre>
       * The set of status codes which indicate other hedged RPCs may still
       * succeed. If a non-fatal status code is returned by the server, hedged
       * RPCs will continue. Otherwise, outstanding requests will be canceled and
       * the error returned to the client application layer.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
       */
      public com.google.rpc.Code getNonFatalStatusCodes(int index) {
        return nonFatalStatusCodes_converter_.convert(nonFatalStatusCodes_.get(index));
      }
      /**
       * <pre>
       * The set of status codes which indicate other hedged RPCs may still
       * succeed. If a non-fatal status code is returned by the server, hedged
       * RPCs will continue. Otherwise, outstanding requests will be canceled and
       * the error returned to the client application layer.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
       */
      public Builder setNonFatalStatusCodes(
          int index, com.google.rpc.Code value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureNonFatalStatusCodesIsMutable();
        nonFatalStatusCodes_.set(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The set of status codes which indicate other hedged RPCs may still
       * succeed. If a non-fatal status code is returned by the server, hedged
       * RPCs will continue. Otherwise, outstanding requests will be canceled and
       * the error returned to the client application layer.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
       */
      public Builder addNonFatalStatusCodes(com.google.rpc.Code value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureNonFatalStatusCodesIsMutable();
        nonFatalStatusCodes_.add(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The set of status codes which indicate other hedged RPCs may still
       * succeed. If a non-fatal status code is returned by the server, hedged
       * RPCs will continue. Otherwise, outstanding requests will be canceled and
       * the error returned to the client application layer.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
       */
      public Builder addAllNonFatalStatusCodes(
          java.lang.Iterable<? extends com.google.rpc.Code> values) {
        ensureNonFatalStatusCodesIsMutable();
        for (com.google.rpc.Code value : values) {
          nonFatalStatusCodes_.add(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The set of status codes which indicate other hedged RPCs may still
       * succeed. If a non-fatal status code is returned by the server, hedged
       * RPCs will continue. Otherwise, outstanding requests will be canceled and
       * the error returned to the client application layer.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
       */
      public Builder clearNonFatalStatusCodes() {
        nonFatalStatusCodes_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The set of status codes which indicate other hedged RPCs may still
       * succeed. If a non-fatal status code is returned by the server, hedged
       * RPCs will continue. Otherwise, outstanding requests will be canceled and
       * the error returned to the client application layer.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
       */
      public java.util.List<java.lang.Integer>
      getNonFatalStatusCodesValueList() {
        return java.util.Collections.unmodifiableList(nonFatalStatusCodes_);
      }
      /**
       * <pre>
       * The set of status codes which indicate other hedged RPCs may still
       * succeed. If a non-fatal status code is returned by the server, hedged
       * RPCs will continue. Otherwise, outstanding requests will be canceled and
       * the error returned to the client application layer.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
       */
      public int getNonFatalStatusCodesValue(int index) {
        return nonFatalStatusCodes_.get(index);
      }
      /**
       * <pre>
       * The set of status codes which indicate other hedged RPCs may still
       * succeed. If a non-fatal status code is returned by the server, hedged
       * RPCs will continue. Otherwise, outstanding requests will be canceled and
       * the error returned to the client application layer.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
       */
      public Builder setNonFatalStatusCodesValue(
          int index, int value) {
        ensureNonFatalStatusCodesIsMutable();
        nonFatalStatusCodes_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The set of status codes which indicate other hedged RPCs may still
       * succeed. If a non-fatal status code is returned by the server, hedged
       * RPCs will continue. Otherwise, outstanding requests will be canceled and
       * the error returned to the client application layer.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
       */
      public Builder addNonFatalStatusCodesValue(int value) {
        ensureNonFatalStatusCodesIsMutable();
        nonFatalStatusCodes_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The set of status codes which indicate other hedged RPCs may still
       * succeed. If a non-fatal status code is returned by the server, hedged
       * RPCs will continue. Otherwise, outstanding requests will be canceled and
       * the error returned to the client application layer.
       * This field is required and must be non-empty.
       * </pre>
       *
       * <code>repeated .google.rpc.Code non_fatal_status_codes = 3;</code>
       */
      public Builder addAllNonFatalStatusCodesValue(
          java.lang.Iterable<java.lang.Integer> values) {
        ensureNonFatalStatusCodesIsMutable();
        for (int value : values) {
          nonFatalStatusCodes_.add(value);
        }
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:grpc.MethodConfig.HedgingPolicy)
    }

    // @@protoc_insertion_point(class_scope:grpc.MethodConfig.HedgingPolicy)
    private static final io.grpc.serviceconfig.MethodConfig.HedgingPolicy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.grpc.serviceconfig.MethodConfig.HedgingPolicy();
    }

    public static io.grpc.serviceconfig.MethodConfig.HedgingPolicy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<HedgingPolicy>
        PARSER = new com.google.protobuf.AbstractParser<HedgingPolicy>() {
      public HedgingPolicy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new HedgingPolicy(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<HedgingPolicy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<HedgingPolicy> getParserForType() {
      return PARSER;
    }

    public io.grpc.serviceconfig.MethodConfig.HedgingPolicy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private int bitField0_;
  private int retryOrHedgingPolicyCase_ = 0;
  private java.lang.Object retryOrHedgingPolicy_;
  public enum RetryOrHedgingPolicyCase
      implements com.google.protobuf.Internal.EnumLite {
    RETRY_POLICY(6),
    HEDGING_POLICY(7),
    RETRYORHEDGINGPOLICY_NOT_SET(0);
    private final int value;
    private RetryOrHedgingPolicyCase(int value) {
      this.value = value;
    }
    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static RetryOrHedgingPolicyCase valueOf(int value) {
      return forNumber(value);
    }

    public static RetryOrHedgingPolicyCase forNumber(int value) {
      switch (value) {
        case 6: return RETRY_POLICY;
        case 7: return HEDGING_POLICY;
        case 0: return RETRYORHEDGINGPOLICY_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  public RetryOrHedgingPolicyCase
  getRetryOrHedgingPolicyCase() {
    return RetryOrHedgingPolicyCase.forNumber(
        retryOrHedgingPolicyCase_);
  }

  public static final int NAME_FIELD_NUMBER = 1;
  private java.util.List<io.grpc.serviceconfig.MethodConfig.Name> name_;
  /**
   * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
   */
  public java.util.List<io.grpc.serviceconfig.MethodConfig.Name> getNameList() {
    return name_;
  }
  /**
   * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
   */
  public java.util.List<? extends io.grpc.serviceconfig.MethodConfig.NameOrBuilder> 
      getNameOrBuilderList() {
    return name_;
  }
  /**
   * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
   */
  public int getNameCount() {
    return name_.size();
  }
  /**
   * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
   */
  public io.grpc.serviceconfig.MethodConfig.Name getName(int index) {
    return name_.get(index);
  }
  /**
   * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
   */
  public io.grpc.serviceconfig.MethodConfig.NameOrBuilder getNameOrBuilder(
      int index) {
    return name_.get(index);
  }

  public static final int WAIT_FOR_READY_FIELD_NUMBER = 2;
  private com.google.protobuf.BoolValue waitForReady_;
  /**
   * <pre>
   * Whether RPCs sent to this method should wait until the connection is
   * ready by default. If false, the RPC will abort immediately if there is
   * a transient failure connecting to the server. Otherwise, gRPC will
   * attempt to connect until the deadline is exceeded.
   * The value specified via the gRPC client API will override the value
   * set here. However, note that setting the value in the client API will
   * also affect transient errors encountered during name resolution, which
   * cannot be caught by the value here, since the service config is
   * obtained by the gRPC client via name resolution.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
   */
  public boolean hasWaitForReady() {
    return waitForReady_ != null;
  }
  /**
   * <pre>
   * Whether RPCs sent to this method should wait until the connection is
   * ready by default. If false, the RPC will abort immediately if there is
   * a transient failure connecting to the server. Otherwise, gRPC will
   * attempt to connect until the deadline is exceeded.
   * The value specified via the gRPC client API will override the value
   * set here. However, note that setting the value in the client API will
   * also affect transient errors encountered during name resolution, which
   * cannot be caught by the value here, since the service config is
   * obtained by the gRPC client via name resolution.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
   */
  public com.google.protobuf.BoolValue getWaitForReady() {
    return waitForReady_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : waitForReady_;
  }
  /**
   * <pre>
   * Whether RPCs sent to this method should wait until the connection is
   * ready by default. If false, the RPC will abort immediately if there is
   * a transient failure connecting to the server. Otherwise, gRPC will
   * attempt to connect until the deadline is exceeded.
   * The value specified via the gRPC client API will override the value
   * set here. However, note that setting the value in the client API will
   * also affect transient errors encountered during name resolution, which
   * cannot be caught by the value here, since the service config is
   * obtained by the gRPC client via name resolution.
   * </pre>
   *
   * <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
   */
  public com.google.protobuf.BoolValueOrBuilder getWaitForReadyOrBuilder() {
    return getWaitForReady();
  }

  public static final int TIMEOUT_FIELD_NUMBER = 3;
  private com.google.protobuf.Duration timeout_;
  /**
   * <pre>
   * The default timeout in seconds for RPCs sent to this method. This can be
   * overridden in code. If no reply is received in the specified amount of
   * time, the request is aborted and a DEADLINE_EXCEEDED error status
   * is returned to the caller.
   * The actual deadline used will be the minimum of the value specified here
   * and the value set by the application via the gRPC client API.  If either
   * one is not set, then the other will be used.  If neither is set, then the
   * request has no deadline.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 3;</code>
   */
  public boolean hasTimeout() {
    return timeout_ != null;
  }
  /**
   * <pre>
   * The default timeout in seconds for RPCs sent to this method. This can be
   * overridden in code. If no reply is received in the specified amount of
   * time, the request is aborted and a DEADLINE_EXCEEDED error status
   * is returned to the caller.
   * The actual deadline used will be the minimum of the value specified here
   * and the value set by the application via the gRPC client API.  If either
   * one is not set, then the other will be used.  If neither is set, then the
   * request has no deadline.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 3;</code>
   */
  public com.google.protobuf.Duration getTimeout() {
    return timeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : timeout_;
  }
  /**
   * <pre>
   * The default timeout in seconds for RPCs sent to this method. This can be
   * overridden in code. If no reply is received in the specified amount of
   * time, the request is aborted and a DEADLINE_EXCEEDED error status
   * is returned to the caller.
   * The actual deadline used will be the minimum of the value specified here
   * and the value set by the application via the gRPC client API.  If either
   * one is not set, then the other will be used.  If neither is set, then the
   * request has no deadline.
   * </pre>
   *
   * <code>.google.protobuf.Duration timeout = 3;</code>
   */
  public com.google.protobuf.DurationOrBuilder getTimeoutOrBuilder() {
    return getTimeout();
  }

  public static final int MAX_REQUEST_MESSAGE_BYTES_FIELD_NUMBER = 4;
  private com.google.protobuf.UInt32Value maxRequestMessageBytes_;
  /**
   * <pre>
   * The maximum allowed payload size for an individual request or object in a
   * stream (client-&gt;server) in bytes. The size which is measured is the
   * serialized payload after per-message compression (but before stream
   * compression) in bytes. This applies both to streaming and non-streaming
   * requests.
   * The actual value used is the minumum of the value specified here and the
   * value set by the application via the gRPC client API.  If either one is
   * not set, then the other will be used.  If neither is set, then the
   * built-in default is used.
   * If a client attempts to send an object larger than this value, it will not
   * be sent and the client will see a ClientError.
   * Note that 0 is a valid value, meaning that the request message
   * must be empty.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
   */
  public boolean hasMaxRequestMessageBytes() {
    return maxRequestMessageBytes_ != null;
  }
  /**
   * <pre>
   * The maximum allowed payload size for an individual request or object in a
   * stream (client-&gt;server) in bytes. The size which is measured is the
   * serialized payload after per-message compression (but before stream
   * compression) in bytes. This applies both to streaming and non-streaming
   * requests.
   * The actual value used is the minumum of the value specified here and the
   * value set by the application via the gRPC client API.  If either one is
   * not set, then the other will be used.  If neither is set, then the
   * built-in default is used.
   * If a client attempts to send an object larger than this value, it will not
   * be sent and the client will see a ClientError.
   * Note that 0 is a valid value, meaning that the request message
   * must be empty.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
   */
  public com.google.protobuf.UInt32Value getMaxRequestMessageBytes() {
    return maxRequestMessageBytes_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestMessageBytes_;
  }
  /**
   * <pre>
   * The maximum allowed payload size for an individual request or object in a
   * stream (client-&gt;server) in bytes. The size which is measured is the
   * serialized payload after per-message compression (but before stream
   * compression) in bytes. This applies both to streaming and non-streaming
   * requests.
   * The actual value used is the minumum of the value specified here and the
   * value set by the application via the gRPC client API.  If either one is
   * not set, then the other will be used.  If neither is set, then the
   * built-in default is used.
   * If a client attempts to send an object larger than this value, it will not
   * be sent and the client will see a ClientError.
   * Note that 0 is a valid value, meaning that the request message
   * must be empty.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
   */
  public com.google.protobuf.UInt32ValueOrBuilder getMaxRequestMessageBytesOrBuilder() {
    return getMaxRequestMessageBytes();
  }

  public static final int MAX_RESPONSE_MESSAGE_BYTES_FIELD_NUMBER = 5;
  private com.google.protobuf.UInt32Value maxResponseMessageBytes_;
  /**
   * <pre>
   * The maximum allowed payload size for an individual response or object in a
   * stream (server-&gt;client) in bytes. The size which is measured is the
   * serialized payload after per-message compression (but before stream
   * compression) in bytes. This applies both to streaming and non-streaming
   * requests.
   * The actual value used is the minumum of the value specified here and the
   * value set by the application via the gRPC client API.  If either one is
   * not set, then the other will be used.  If neither is set, then the
   * built-in default is used.
   * If a server attempts to send an object larger than this value, it will not
   * be sent, and a ServerError will be sent to the client instead.
   * Note that 0 is a valid value, meaning that the response message
   * must be empty.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
   */
  public boolean hasMaxResponseMessageBytes() {
    return maxResponseMessageBytes_ != null;
  }
  /**
   * <pre>
   * The maximum allowed payload size for an individual response or object in a
   * stream (server-&gt;client) in bytes. The size which is measured is the
   * serialized payload after per-message compression (but before stream
   * compression) in bytes. This applies both to streaming and non-streaming
   * requests.
   * The actual value used is the minumum of the value specified here and the
   * value set by the application via the gRPC client API.  If either one is
   * not set, then the other will be used.  If neither is set, then the
   * built-in default is used.
   * If a server attempts to send an object larger than this value, it will not
   * be sent, and a ServerError will be sent to the client instead.
   * Note that 0 is a valid value, meaning that the response message
   * must be empty.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
   */
  public com.google.protobuf.UInt32Value getMaxResponseMessageBytes() {
    return maxResponseMessageBytes_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxResponseMessageBytes_;
  }
  /**
   * <pre>
   * The maximum allowed payload size for an individual response or object in a
   * stream (server-&gt;client) in bytes. The size which is measured is the
   * serialized payload after per-message compression (but before stream
   * compression) in bytes. This applies both to streaming and non-streaming
   * requests.
   * The actual value used is the minumum of the value specified here and the
   * value set by the application via the gRPC client API.  If either one is
   * not set, then the other will be used.  If neither is set, then the
   * built-in default is used.
   * If a server attempts to send an object larger than this value, it will not
   * be sent, and a ServerError will be sent to the client instead.
   * Note that 0 is a valid value, meaning that the response message
   * must be empty.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
   */
  public com.google.protobuf.UInt32ValueOrBuilder getMaxResponseMessageBytesOrBuilder() {
    return getMaxResponseMessageBytes();
  }

  public static final int RETRY_POLICY_FIELD_NUMBER = 6;
  /**
   * <code>.grpc.MethodConfig.RetryPolicy retry_policy = 6;</code>
   */
  public boolean hasRetryPolicy() {
    return retryOrHedgingPolicyCase_ == 6;
  }
  /**
   * <code>.grpc.MethodConfig.RetryPolicy retry_policy = 6;</code>
   */
  public io.grpc.serviceconfig.MethodConfig.RetryPolicy getRetryPolicy() {
    if (retryOrHedgingPolicyCase_ == 6) {
       return (io.grpc.serviceconfig.MethodConfig.RetryPolicy) retryOrHedgingPolicy_;
    }
    return io.grpc.serviceconfig.MethodConfig.RetryPolicy.getDefaultInstance();
  }
  /**
   * <code>.grpc.MethodConfig.RetryPolicy retry_policy = 6;</code>
   */
  public io.grpc.serviceconfig.MethodConfig.RetryPolicyOrBuilder getRetryPolicyOrBuilder() {
    if (retryOrHedgingPolicyCase_ == 6) {
       return (io.grpc.serviceconfig.MethodConfig.RetryPolicy) retryOrHedgingPolicy_;
    }
    return io.grpc.serviceconfig.MethodConfig.RetryPolicy.getDefaultInstance();
  }

  public static final int HEDGING_POLICY_FIELD_NUMBER = 7;
  /**
   * <code>.grpc.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
   */
  public boolean hasHedgingPolicy() {
    return retryOrHedgingPolicyCase_ == 7;
  }
  /**
   * <code>.grpc.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
   */
  public io.grpc.serviceconfig.MethodConfig.HedgingPolicy getHedgingPolicy() {
    if (retryOrHedgingPolicyCase_ == 7) {
       return (io.grpc.serviceconfig.MethodConfig.HedgingPolicy) retryOrHedgingPolicy_;
    }
    return io.grpc.serviceconfig.MethodConfig.HedgingPolicy.getDefaultInstance();
  }
  /**
   * <code>.grpc.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
   */
  public io.grpc.serviceconfig.MethodConfig.HedgingPolicyOrBuilder getHedgingPolicyOrBuilder() {
    if (retryOrHedgingPolicyCase_ == 7) {
       return (io.grpc.serviceconfig.MethodConfig.HedgingPolicy) retryOrHedgingPolicy_;
    }
    return io.grpc.serviceconfig.MethodConfig.HedgingPolicy.getDefaultInstance();
  }

  private byte memoizedIsInitialized = -1;
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    for (int i = 0; i < name_.size(); i++) {
      output.writeMessage(1, name_.get(i));
    }
    if (waitForReady_ != null) {
      output.writeMessage(2, getWaitForReady());
    }
    if (timeout_ != null) {
      output.writeMessage(3, getTimeout());
    }
    if (maxRequestMessageBytes_ != null) {
      output.writeMessage(4, getMaxRequestMessageBytes());
    }
    if (maxResponseMessageBytes_ != null) {
      output.writeMessage(5, getMaxResponseMessageBytes());
    }
    if (retryOrHedgingPolicyCase_ == 6) {
      output.writeMessage(6, (io.grpc.serviceconfig.MethodConfig.RetryPolicy) retryOrHedgingPolicy_);
    }
    if (retryOrHedgingPolicyCase_ == 7) {
      output.writeMessage(7, (io.grpc.serviceconfig.MethodConfig.HedgingPolicy) retryOrHedgingPolicy_);
    }
    unknownFields.writeTo(output);
  }

  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    for (int i = 0; i < name_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(1, name_.get(i));
    }
    if (waitForReady_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(2, getWaitForReady());
    }
    if (timeout_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(3, getTimeout());
    }
    if (maxRequestMessageBytes_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(4, getMaxRequestMessageBytes());
    }
    if (maxResponseMessageBytes_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(5, getMaxResponseMessageBytes());
    }
    if (retryOrHedgingPolicyCase_ == 6) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(6, (io.grpc.serviceconfig.MethodConfig.RetryPolicy) retryOrHedgingPolicy_);
    }
    if (retryOrHedgingPolicyCase_ == 7) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(7, (io.grpc.serviceconfig.MethodConfig.HedgingPolicy) retryOrHedgingPolicy_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.grpc.serviceconfig.MethodConfig)) {
      return super.equals(obj);
    }
    io.grpc.serviceconfig.MethodConfig other = (io.grpc.serviceconfig.MethodConfig) obj;

    boolean result = true;
    result = result && getNameList()
        .equals(other.getNameList());
    result = result && (hasWaitForReady() == other.hasWaitForReady());
    if (hasWaitForReady()) {
      result = result && getWaitForReady()
          .equals(other.getWaitForReady());
    }
    result = result && (hasTimeout() == other.hasTimeout());
    if (hasTimeout()) {
      result = result && getTimeout()
          .equals(other.getTimeout());
    }
    result = result && (hasMaxRequestMessageBytes() == other.hasMaxRequestMessageBytes());
    if (hasMaxRequestMessageBytes()) {
      result = result && getMaxRequestMessageBytes()
          .equals(other.getMaxRequestMessageBytes());
    }
    result = result && (hasMaxResponseMessageBytes() == other.hasMaxResponseMessageBytes());
    if (hasMaxResponseMessageBytes()) {
      result = result && getMaxResponseMessageBytes()
          .equals(other.getMaxResponseMessageBytes());
    }
    result = result && getRetryOrHedgingPolicyCase().equals(
        other.getRetryOrHedgingPolicyCase());
    if (!result) return false;
    switch (retryOrHedgingPolicyCase_) {
      case 6:
        result = result && getRetryPolicy()
            .equals(other.getRetryPolicy());
        break;
      case 7:
        result = result && getHedgingPolicy()
            .equals(other.getHedgingPolicy());
        break;
      case 0:
      default:
    }
    result = result && unknownFields.equals(other.unknownFields);
    return result;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (getNameCount() > 0) {
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getNameList().hashCode();
    }
    if (hasWaitForReady()) {
      hash = (37 * hash) + WAIT_FOR_READY_FIELD_NUMBER;
      hash = (53 * hash) + getWaitForReady().hashCode();
    }
    if (hasTimeout()) {
      hash = (37 * hash) + TIMEOUT_FIELD_NUMBER;
      hash = (53 * hash) + getTimeout().hashCode();
    }
    if (hasMaxRequestMessageBytes()) {
      hash = (37 * hash) + MAX_REQUEST_MESSAGE_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + getMaxRequestMessageBytes().hashCode();
    }
    if (hasMaxResponseMessageBytes()) {
      hash = (37 * hash) + MAX_RESPONSE_MESSAGE_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + getMaxResponseMessageBytes().hashCode();
    }
    switch (retryOrHedgingPolicyCase_) {
      case 6:
        hash = (37 * hash) + RETRY_POLICY_FIELD_NUMBER;
        hash = (53 * hash) + getRetryPolicy().hashCode();
        break;
      case 7:
        hash = (37 * hash) + HEDGING_POLICY_FIELD_NUMBER;
        hash = (53 * hash) + getHedgingPolicy().hashCode();
        break;
      case 0:
      default:
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.grpc.serviceconfig.MethodConfig parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.grpc.serviceconfig.MethodConfig parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.grpc.serviceconfig.MethodConfig parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.grpc.serviceconfig.MethodConfig parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.grpc.serviceconfig.MethodConfig parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.grpc.serviceconfig.MethodConfig parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.grpc.serviceconfig.MethodConfig parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.grpc.serviceconfig.MethodConfig parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.grpc.serviceconfig.MethodConfig parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.grpc.serviceconfig.MethodConfig parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.grpc.serviceconfig.MethodConfig parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.grpc.serviceconfig.MethodConfig parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.grpc.serviceconfig.MethodConfig prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * Configuration for a method.
   * </pre>
   *
   * Protobuf type {@code grpc.MethodConfig}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:grpc.MethodConfig)
      io.grpc.serviceconfig.MethodConfigOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.grpc.serviceconfig.MethodConfig.class, io.grpc.serviceconfig.MethodConfig.Builder.class);
    }

    // Construct using io.grpc.serviceconfig.MethodConfig.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
        getNameFieldBuilder();
      }
    }
    public Builder clear() {
      super.clear();
      if (nameBuilder_ == null) {
        name_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
      } else {
        nameBuilder_.clear();
      }
      if (waitForReadyBuilder_ == null) {
        waitForReady_ = null;
      } else {
        waitForReady_ = null;
        waitForReadyBuilder_ = null;
      }
      if (timeoutBuilder_ == null) {
        timeout_ = null;
      } else {
        timeout_ = null;
        timeoutBuilder_ = null;
      }
      if (maxRequestMessageBytesBuilder_ == null) {
        maxRequestMessageBytes_ = null;
      } else {
        maxRequestMessageBytes_ = null;
        maxRequestMessageBytesBuilder_ = null;
      }
      if (maxResponseMessageBytesBuilder_ == null) {
        maxResponseMessageBytes_ = null;
      } else {
        maxResponseMessageBytes_ = null;
        maxResponseMessageBytesBuilder_ = null;
      }
      retryOrHedgingPolicyCase_ = 0;
      retryOrHedgingPolicy_ = null;
      return this;
    }

    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.grpc.serviceconfig.ServiceConfigProto.internal_static_grpc_MethodConfig_descriptor;
    }

    public io.grpc.serviceconfig.MethodConfig getDefaultInstanceForType() {
      return io.grpc.serviceconfig.MethodConfig.getDefaultInstance();
    }

    public io.grpc.serviceconfig.MethodConfig build() {
      io.grpc.serviceconfig.MethodConfig result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    public io.grpc.serviceconfig.MethodConfig buildPartial() {
      io.grpc.serviceconfig.MethodConfig result = new io.grpc.serviceconfig.MethodConfig(this);
      int from_bitField0_ = bitField0_;
      int to_bitField0_ = 0;
      if (nameBuilder_ == null) {
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          name_ = java.util.Collections.unmodifiableList(name_);
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.name_ = name_;
      } else {
        result.name_ = nameBuilder_.build();
      }
      if (waitForReadyBuilder_ == null) {
        result.waitForReady_ = waitForReady_;
      } else {
        result.waitForReady_ = waitForReadyBuilder_.build();
      }
      if (timeoutBuilder_ == null) {
        result.timeout_ = timeout_;
      } else {
        result.timeout_ = timeoutBuilder_.build();
      }
      if (maxRequestMessageBytesBuilder_ == null) {
        result.maxRequestMessageBytes_ = maxRequestMessageBytes_;
      } else {
        result.maxRequestMessageBytes_ = maxRequestMessageBytesBuilder_.build();
      }
      if (maxResponseMessageBytesBuilder_ == null) {
        result.maxResponseMessageBytes_ = maxResponseMessageBytes_;
      } else {
        result.maxResponseMessageBytes_ = maxResponseMessageBytesBuilder_.build();
      }
      if (retryOrHedgingPolicyCase_ == 6) {
        if (retryPolicyBuilder_ == null) {
          result.retryOrHedgingPolicy_ = retryOrHedgingPolicy_;
        } else {
          result.retryOrHedgingPolicy_ = retryPolicyBuilder_.build();
        }
      }
      if (retryOrHedgingPolicyCase_ == 7) {
        if (hedgingPolicyBuilder_ == null) {
          result.retryOrHedgingPolicy_ = retryOrHedgingPolicy_;
        } else {
          result.retryOrHedgingPolicy_ = hedgingPolicyBuilder_.build();
        }
      }
      result.bitField0_ = to_bitField0_;
      result.retryOrHedgingPolicyCase_ = retryOrHedgingPolicyCase_;
      onBuilt();
      return result;
    }

    public Builder clone() {
      return (Builder) super.clone();
    }
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return (Builder) super.setField(field, value);
    }
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return (Builder) super.clearField(field);
    }
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return (Builder) super.clearOneof(oneof);
    }
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return (Builder) super.setRepeatedField(field, index, value);
    }
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return (Builder) super.addRepeatedField(field, value);
    }
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.grpc.serviceconfig.MethodConfig) {
        return mergeFrom((io.grpc.serviceconfig.MethodConfig)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.grpc.serviceconfig.MethodConfig other) {
      if (other == io.grpc.serviceconfig.MethodConfig.getDefaultInstance()) return this;
      if (nameBuilder_ == null) {
        if (!other.name_.isEmpty()) {
          if (name_.isEmpty()) {
            name_ = other.name_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureNameIsMutable();
            name_.addAll(other.name_);
          }
          onChanged();
        }
      } else {
        if (!other.name_.isEmpty()) {
          if (nameBuilder_.isEmpty()) {
            nameBuilder_.dispose();
            nameBuilder_ = null;
            name_ = other.name_;
            bitField0_ = (bitField0_ & ~0x00000001);
            nameBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getNameFieldBuilder() : null;
          } else {
            nameBuilder_.addAllMessages(other.name_);
          }
        }
      }
      if (other.hasWaitForReady()) {
        mergeWaitForReady(other.getWaitForReady());
      }
      if (other.hasTimeout()) {
        mergeTimeout(other.getTimeout());
      }
      if (other.hasMaxRequestMessageBytes()) {
        mergeMaxRequestMessageBytes(other.getMaxRequestMessageBytes());
      }
      if (other.hasMaxResponseMessageBytes()) {
        mergeMaxResponseMessageBytes(other.getMaxResponseMessageBytes());
      }
      switch (other.getRetryOrHedgingPolicyCase()) {
        case RETRY_POLICY: {
          mergeRetryPolicy(other.getRetryPolicy());
          break;
        }
        case HEDGING_POLICY: {
          mergeHedgingPolicy(other.getHedgingPolicy());
          break;
        }
        case RETRYORHEDGINGPOLICY_NOT_SET: {
          break;
        }
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    public final boolean isInitialized() {
      return true;
    }

    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      io.grpc.serviceconfig.MethodConfig parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (io.grpc.serviceconfig.MethodConfig) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int retryOrHedgingPolicyCase_ = 0;
    private java.lang.Object retryOrHedgingPolicy_;
    public RetryOrHedgingPolicyCase
        getRetryOrHedgingPolicyCase() {
      return RetryOrHedgingPolicyCase.forNumber(
          retryOrHedgingPolicyCase_);
    }

    public Builder clearRetryOrHedgingPolicy() {
      retryOrHedgingPolicyCase_ = 0;
      retryOrHedgingPolicy_ = null;
      onChanged();
      return this;
    }

    private int bitField0_;

    private java.util.List<io.grpc.serviceconfig.MethodConfig.Name> name_ =
      java.util.Collections.emptyList();
    private void ensureNameIsMutable() {
      if (!((bitField0_ & 0x00000001) == 0x00000001)) {
        name_ = new java.util.ArrayList<io.grpc.serviceconfig.MethodConfig.Name>(name_);
        bitField0_ |= 0x00000001;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.grpc.serviceconfig.MethodConfig.Name, io.grpc.serviceconfig.MethodConfig.Name.Builder, io.grpc.serviceconfig.MethodConfig.NameOrBuilder> nameBuilder_;

    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public java.util.List<io.grpc.serviceconfig.MethodConfig.Name> getNameList() {
      if (nameBuilder_ == null) {
        return java.util.Collections.unmodifiableList(name_);
      } else {
        return nameBuilder_.getMessageList();
      }
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public int getNameCount() {
      if (nameBuilder_ == null) {
        return name_.size();
      } else {
        return nameBuilder_.getCount();
      }
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public io.grpc.serviceconfig.MethodConfig.Name getName(int index) {
      if (nameBuilder_ == null) {
        return name_.get(index);
      } else {
        return nameBuilder_.getMessage(index);
      }
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public Builder setName(
        int index, io.grpc.serviceconfig.MethodConfig.Name value) {
      if (nameBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureNameIsMutable();
        name_.set(index, value);
        onChanged();
      } else {
        nameBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public Builder setName(
        int index, io.grpc.serviceconfig.MethodConfig.Name.Builder builderForValue) {
      if (nameBuilder_ == null) {
        ensureNameIsMutable();
        name_.set(index, builderForValue.build());
        onChanged();
      } else {
        nameBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public Builder addName(io.grpc.serviceconfig.MethodConfig.Name value) {
      if (nameBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureNameIsMutable();
        name_.add(value);
        onChanged();
      } else {
        nameBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public Builder addName(
        int index, io.grpc.serviceconfig.MethodConfig.Name value) {
      if (nameBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureNameIsMutable();
        name_.add(index, value);
        onChanged();
      } else {
        nameBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public Builder addName(
        io.grpc.serviceconfig.MethodConfig.Name.Builder builderForValue) {
      if (nameBuilder_ == null) {
        ensureNameIsMutable();
        name_.add(builderForValue.build());
        onChanged();
      } else {
        nameBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public Builder addName(
        int index, io.grpc.serviceconfig.MethodConfig.Name.Builder builderForValue) {
      if (nameBuilder_ == null) {
        ensureNameIsMutable();
        name_.add(index, builderForValue.build());
        onChanged();
      } else {
        nameBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public Builder addAllName(
        java.lang.Iterable<? extends io.grpc.serviceconfig.MethodConfig.Name> values) {
      if (nameBuilder_ == null) {
        ensureNameIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, name_);
        onChanged();
      } else {
        nameBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public Builder clearName() {
      if (nameBuilder_ == null) {
        name_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
      } else {
        nameBuilder_.clear();
      }
      return this;
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public Builder removeName(int index) {
      if (nameBuilder_ == null) {
        ensureNameIsMutable();
        name_.remove(index);
        onChanged();
      } else {
        nameBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public io.grpc.serviceconfig.MethodConfig.Name.Builder getNameBuilder(
        int index) {
      return getNameFieldBuilder().getBuilder(index);
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public io.grpc.serviceconfig.MethodConfig.NameOrBuilder getNameOrBuilder(
        int index) {
      if (nameBuilder_ == null) {
        return name_.get(index);  } else {
        return nameBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public java.util.List<? extends io.grpc.serviceconfig.MethodConfig.NameOrBuilder> 
         getNameOrBuilderList() {
      if (nameBuilder_ != null) {
        return nameBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(name_);
      }
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public io.grpc.serviceconfig.MethodConfig.Name.Builder addNameBuilder() {
      return getNameFieldBuilder().addBuilder(
          io.grpc.serviceconfig.MethodConfig.Name.getDefaultInstance());
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public io.grpc.serviceconfig.MethodConfig.Name.Builder addNameBuilder(
        int index) {
      return getNameFieldBuilder().addBuilder(
          index, io.grpc.serviceconfig.MethodConfig.Name.getDefaultInstance());
    }
    /**
     * <code>repeated .grpc.MethodConfig.Name name = 1;</code>
     */
    public java.util.List<io.grpc.serviceconfig.MethodConfig.Name.Builder> 
         getNameBuilderList() {
      return getNameFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.grpc.serviceconfig.MethodConfig.Name, io.grpc.serviceconfig.MethodConfig.Name.Builder, io.grpc.serviceconfig.MethodConfig.NameOrBuilder> 
        getNameFieldBuilder() {
      if (nameBuilder_ == null) {
        nameBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.grpc.serviceconfig.MethodConfig.Name, io.grpc.serviceconfig.MethodConfig.Name.Builder, io.grpc.serviceconfig.MethodConfig.NameOrBuilder>(
                name_,
                ((bitField0_ & 0x00000001) == 0x00000001),
                getParentForChildren(),
                isClean());
        name_ = null;
      }
      return nameBuilder_;
    }

    private com.google.protobuf.BoolValue waitForReady_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> waitForReadyBuilder_;
    /**
     * <pre>
     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     */
    public boolean hasWaitForReady() {
      return waitForReadyBuilder_ != null || waitForReady_ != null;
    }
    /**
     * <pre>
     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     */
    public com.google.protobuf.BoolValue getWaitForReady() {
      if (waitForReadyBuilder_ == null) {
        return waitForReady_ == null ? com.google.protobuf.BoolValue.getDefaultInstance() : waitForReady_;
      } else {
        return waitForReadyBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     */
    public Builder setWaitForReady(com.google.protobuf.BoolValue value) {
      if (waitForReadyBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        waitForReady_ = value;
        onChanged();
      } else {
        waitForReadyBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     */
    public Builder setWaitForReady(
        com.google.protobuf.BoolValue.Builder builderForValue) {
      if (waitForReadyBuilder_ == null) {
        waitForReady_ = builderForValue.build();
        onChanged();
      } else {
        waitForReadyBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     */
    public Builder mergeWaitForReady(com.google.protobuf.BoolValue value) {
      if (waitForReadyBuilder_ == null) {
        if (waitForReady_ != null) {
          waitForReady_ =
            com.google.protobuf.BoolValue.newBuilder(waitForReady_).mergeFrom(value).buildPartial();
        } else {
          waitForReady_ = value;
        }
        onChanged();
      } else {
        waitForReadyBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     */
    public Builder clearWaitForReady() {
      if (waitForReadyBuilder_ == null) {
        waitForReady_ = null;
        onChanged();
      } else {
        waitForReady_ = null;
        waitForReadyBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     */
    public com.google.protobuf.BoolValue.Builder getWaitForReadyBuilder() {
      
      onChanged();
      return getWaitForReadyFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     */
    public com.google.protobuf.BoolValueOrBuilder getWaitForReadyOrBuilder() {
      if (waitForReadyBuilder_ != null) {
        return waitForReadyBuilder_.getMessageOrBuilder();
      } else {
        return waitForReady_ == null ?
            com.google.protobuf.BoolValue.getDefaultInstance() : waitForReady_;
      }
    }
    /**
     * <pre>
     * Whether RPCs sent to this method should wait until the connection is
     * ready by default. If false, the RPC will abort immediately if there is
     * a transient failure connecting to the server. Otherwise, gRPC will
     * attempt to connect until the deadline is exceeded.
     * The value specified via the gRPC client API will override the value
     * set here. However, note that setting the value in the client API will
     * also affect transient errors encountered during name resolution, which
     * cannot be caught by the value here, since the service config is
     * obtained by the gRPC client via name resolution.
     * </pre>
     *
     * <code>.google.protobuf.BoolValue wait_for_ready = 2;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder> 
        getWaitForReadyFieldBuilder() {
      if (waitForReadyBuilder_ == null) {
        waitForReadyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.BoolValue, com.google.protobuf.BoolValue.Builder, com.google.protobuf.BoolValueOrBuilder>(
                getWaitForReady(),
                getParentForChildren(),
                isClean());
        waitForReady_ = null;
      }
      return waitForReadyBuilder_;
    }

    private com.google.protobuf.Duration timeout_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> timeoutBuilder_;
    /**
     * <pre>
     * The default timeout in seconds for RPCs sent to this method. This can be
     * overridden in code. If no reply is received in the specified amount of
     * time, the request is aborted and a DEADLINE_EXCEEDED error status
     * is returned to the caller.
     * The actual deadline used will be the minimum of the value specified here
     * and the value set by the application via the gRPC client API.  If either
     * one is not set, then the other will be used.  If neither is set, then the
     * request has no deadline.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 3;</code>
     */
    public boolean hasTimeout() {
      return timeoutBuilder_ != null || timeout_ != null;
    }
    /**
     * <pre>
     * The default timeout in seconds for RPCs sent to this method. This can be
     * overridden in code. If no reply is received in the specified amount of
     * time, the request is aborted and a DEADLINE_EXCEEDED error status
     * is returned to the caller.
     * The actual deadline used will be the minimum of the value specified here
     * and the value set by the application via the gRPC client API.  If either
     * one is not set, then the other will be used.  If neither is set, then the
     * request has no deadline.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 3;</code>
     */
    public com.google.protobuf.Duration getTimeout() {
      if (timeoutBuilder_ == null) {
        return timeout_ == null ? com.google.protobuf.Duration.getDefaultInstance() : timeout_;
      } else {
        return timeoutBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The default timeout in seconds for RPCs sent to this method. This can be
     * overridden in code. If no reply is received in the specified amount of
     * time, the request is aborted and a DEADLINE_EXCEEDED error status
     * is returned to the caller.
     * The actual deadline used will be the minimum of the value specified here
     * and the value set by the application via the gRPC client API.  If either
     * one is not set, then the other will be used.  If neither is set, then the
     * request has no deadline.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 3;</code>
     */
    public Builder setTimeout(com.google.protobuf.Duration value) {
      if (timeoutBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        timeout_ = value;
        onChanged();
      } else {
        timeoutBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The default timeout in seconds for RPCs sent to this method. This can be
     * overridden in code. If no reply is received in the specified amount of
     * time, the request is aborted and a DEADLINE_EXCEEDED error status
     * is returned to the caller.
     * The actual deadline used will be the minimum of the value specified here
     * and the value set by the application via the gRPC client API.  If either
     * one is not set, then the other will be used.  If neither is set, then the
     * request has no deadline.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 3;</code>
     */
    public Builder setTimeout(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (timeoutBuilder_ == null) {
        timeout_ = builderForValue.build();
        onChanged();
      } else {
        timeoutBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The default timeout in seconds for RPCs sent to this method. This can be
     * overridden in code. If no reply is received in the specified amount of
     * time, the request is aborted and a DEADLINE_EXCEEDED error status
     * is returned to the caller.
     * The actual deadline used will be the minimum of the value specified here
     * and the value set by the application via the gRPC client API.  If either
     * one is not set, then the other will be used.  If neither is set, then the
     * request has no deadline.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 3;</code>
     */
    public Builder mergeTimeout(com.google.protobuf.Duration value) {
      if (timeoutBuilder_ == null) {
        if (timeout_ != null) {
          timeout_ =
            com.google.protobuf.Duration.newBuilder(timeout_).mergeFrom(value).buildPartial();
        } else {
          timeout_ = value;
        }
        onChanged();
      } else {
        timeoutBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The default timeout in seconds for RPCs sent to this method. This can be
     * overridden in code. If no reply is received in the specified amount of
     * time, the request is aborted and a DEADLINE_EXCEEDED error status
     * is returned to the caller.
     * The actual deadline used will be the minimum of the value specified here
     * and the value set by the application via the gRPC client API.  If either
     * one is not set, then the other will be used.  If neither is set, then the
     * request has no deadline.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 3;</code>
     */
    public Builder clearTimeout() {
      if (timeoutBuilder_ == null) {
        timeout_ = null;
        onChanged();
      } else {
        timeout_ = null;
        timeoutBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The default timeout in seconds for RPCs sent to this method. This can be
     * overridden in code. If no reply is received in the specified amount of
     * time, the request is aborted and a DEADLINE_EXCEEDED error status
     * is returned to the caller.
     * The actual deadline used will be the minimum of the value specified here
     * and the value set by the application via the gRPC client API.  If either
     * one is not set, then the other will be used.  If neither is set, then the
     * request has no deadline.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 3;</code>
     */
    public com.google.protobuf.Duration.Builder getTimeoutBuilder() {
      
      onChanged();
      return getTimeoutFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The default timeout in seconds for RPCs sent to this method. This can be
     * overridden in code. If no reply is received in the specified amount of
     * time, the request is aborted and a DEADLINE_EXCEEDED error status
     * is returned to the caller.
     * The actual deadline used will be the minimum of the value specified here
     * and the value set by the application via the gRPC client API.  If either
     * one is not set, then the other will be used.  If neither is set, then the
     * request has no deadline.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 3;</code>
     */
    public com.google.protobuf.DurationOrBuilder getTimeoutOrBuilder() {
      if (timeoutBuilder_ != null) {
        return timeoutBuilder_.getMessageOrBuilder();
      } else {
        return timeout_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : timeout_;
      }
    }
    /**
     * <pre>
     * The default timeout in seconds for RPCs sent to this method. This can be
     * overridden in code. If no reply is received in the specified amount of
     * time, the request is aborted and a DEADLINE_EXCEEDED error status
     * is returned to the caller.
     * The actual deadline used will be the minimum of the value specified here
     * and the value set by the application via the gRPC client API.  If either
     * one is not set, then the other will be used.  If neither is set, then the
     * request has no deadline.
     * </pre>
     *
     * <code>.google.protobuf.Duration timeout = 3;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getTimeoutFieldBuilder() {
      if (timeoutBuilder_ == null) {
        timeoutBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getTimeout(),
                getParentForChildren(),
                isClean());
        timeout_ = null;
      }
      return timeoutBuilder_;
    }

    private com.google.protobuf.UInt32Value maxRequestMessageBytes_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> maxRequestMessageBytesBuilder_;
    /**
     * <pre>
     * The maximum allowed payload size for an individual request or object in a
     * stream (client-&gt;server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     */
    public boolean hasMaxRequestMessageBytes() {
      return maxRequestMessageBytesBuilder_ != null || maxRequestMessageBytes_ != null;
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual request or object in a
     * stream (client-&gt;server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     */
    public com.google.protobuf.UInt32Value getMaxRequestMessageBytes() {
      if (maxRequestMessageBytesBuilder_ == null) {
        return maxRequestMessageBytes_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestMessageBytes_;
      } else {
        return maxRequestMessageBytesBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual request or object in a
     * stream (client-&gt;server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     */
    public Builder setMaxRequestMessageBytes(com.google.protobuf.UInt32Value value) {
      if (maxRequestMessageBytesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        maxRequestMessageBytes_ = value;
        onChanged();
      } else {
        maxRequestMessageBytesBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual request or object in a
     * stream (client-&gt;server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     */
    public Builder setMaxRequestMessageBytes(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (maxRequestMessageBytesBuilder_ == null) {
        maxRequestMessageBytes_ = builderForValue.build();
        onChanged();
      } else {
        maxRequestMessageBytesBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual request or object in a
     * stream (client-&gt;server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     */
    public Builder mergeMaxRequestMessageBytes(com.google.protobuf.UInt32Value value) {
      if (maxRequestMessageBytesBuilder_ == null) {
        if (maxRequestMessageBytes_ != null) {
          maxRequestMessageBytes_ =
            com.google.protobuf.UInt32Value.newBuilder(maxRequestMessageBytes_).mergeFrom(value).buildPartial();
        } else {
          maxRequestMessageBytes_ = value;
        }
        onChanged();
      } else {
        maxRequestMessageBytesBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual request or object in a
     * stream (client-&gt;server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     */
    public Builder clearMaxRequestMessageBytes() {
      if (maxRequestMessageBytesBuilder_ == null) {
        maxRequestMessageBytes_ = null;
        onChanged();
      } else {
        maxRequestMessageBytes_ = null;
        maxRequestMessageBytesBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual request or object in a
     * stream (client-&gt;server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     */
    public com.google.protobuf.UInt32Value.Builder getMaxRequestMessageBytesBuilder() {
      
      onChanged();
      return getMaxRequestMessageBytesFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual request or object in a
     * stream (client-&gt;server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getMaxRequestMessageBytesOrBuilder() {
      if (maxRequestMessageBytesBuilder_ != null) {
        return maxRequestMessageBytesBuilder_.getMessageOrBuilder();
      } else {
        return maxRequestMessageBytes_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : maxRequestMessageBytes_;
      }
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual request or object in a
     * stream (client-&gt;server) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a client attempts to send an object larger than this value, it will not
     * be sent and the client will see a ClientError.
     * Note that 0 is a valid value, meaning that the request message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_request_message_bytes = 4;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getMaxRequestMessageBytesFieldBuilder() {
      if (maxRequestMessageBytesBuilder_ == null) {
        maxRequestMessageBytesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getMaxRequestMessageBytes(),
                getParentForChildren(),
                isClean());
        maxRequestMessageBytes_ = null;
      }
      return maxRequestMessageBytesBuilder_;
    }

    private com.google.protobuf.UInt32Value maxResponseMessageBytes_ = null;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> maxResponseMessageBytesBuilder_;
    /**
     * <pre>
     * The maximum allowed payload size for an individual response or object in a
     * stream (server-&gt;client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     */
    public boolean hasMaxResponseMessageBytes() {
      return maxResponseMessageBytesBuilder_ != null || maxResponseMessageBytes_ != null;
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual response or object in a
     * stream (server-&gt;client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     */
    public com.google.protobuf.UInt32Value getMaxResponseMessageBytes() {
      if (maxResponseMessageBytesBuilder_ == null) {
        return maxResponseMessageBytes_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : maxResponseMessageBytes_;
      } else {
        return maxResponseMessageBytesBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual response or object in a
     * stream (server-&gt;client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     */
    public Builder setMaxResponseMessageBytes(com.google.protobuf.UInt32Value value) {
      if (maxResponseMessageBytesBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        maxResponseMessageBytes_ = value;
        onChanged();
      } else {
        maxResponseMessageBytesBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual response or object in a
     * stream (server-&gt;client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     */
    public Builder setMaxResponseMessageBytes(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (maxResponseMessageBytesBuilder_ == null) {
        maxResponseMessageBytes_ = builderForValue.build();
        onChanged();
      } else {
        maxResponseMessageBytesBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual response or object in a
     * stream (server-&gt;client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     */
    public Builder mergeMaxResponseMessageBytes(com.google.protobuf.UInt32Value value) {
      if (maxResponseMessageBytesBuilder_ == null) {
        if (maxResponseMessageBytes_ != null) {
          maxResponseMessageBytes_ =
            com.google.protobuf.UInt32Value.newBuilder(maxResponseMessageBytes_).mergeFrom(value).buildPartial();
        } else {
          maxResponseMessageBytes_ = value;
        }
        onChanged();
      } else {
        maxResponseMessageBytesBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual response or object in a
     * stream (server-&gt;client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     */
    public Builder clearMaxResponseMessageBytes() {
      if (maxResponseMessageBytesBuilder_ == null) {
        maxResponseMessageBytes_ = null;
        onChanged();
      } else {
        maxResponseMessageBytes_ = null;
        maxResponseMessageBytesBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual response or object in a
     * stream (server-&gt;client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     */
    public com.google.protobuf.UInt32Value.Builder getMaxResponseMessageBytesBuilder() {
      
      onChanged();
      return getMaxResponseMessageBytesFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual response or object in a
     * stream (server-&gt;client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getMaxResponseMessageBytesOrBuilder() {
      if (maxResponseMessageBytesBuilder_ != null) {
        return maxResponseMessageBytesBuilder_.getMessageOrBuilder();
      } else {
        return maxResponseMessageBytes_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : maxResponseMessageBytes_;
      }
    }
    /**
     * <pre>
     * The maximum allowed payload size for an individual response or object in a
     * stream (server-&gt;client) in bytes. The size which is measured is the
     * serialized payload after per-message compression (but before stream
     * compression) in bytes. This applies both to streaming and non-streaming
     * requests.
     * The actual value used is the minumum of the value specified here and the
     * value set by the application via the gRPC client API.  If either one is
     * not set, then the other will be used.  If neither is set, then the
     * built-in default is used.
     * If a server attempts to send an object larger than this value, it will not
     * be sent, and a ServerError will be sent to the client instead.
     * Note that 0 is a valid value, meaning that the response message
     * must be empty.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value max_response_message_bytes = 5;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getMaxResponseMessageBytesFieldBuilder() {
      if (maxResponseMessageBytesBuilder_ == null) {
        maxResponseMessageBytesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getMaxResponseMessageBytes(),
                getParentForChildren(),
                isClean());
        maxResponseMessageBytes_ = null;
      }
      return maxResponseMessageBytesBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.serviceconfig.MethodConfig.RetryPolicy, io.grpc.serviceconfig.MethodConfig.RetryPolicy.Builder, io.grpc.serviceconfig.MethodConfig.RetryPolicyOrBuilder> retryPolicyBuilder_;
    /**
     * <code>.grpc.MethodConfig.RetryPolicy retry_policy = 6;</code>
     */
    public boolean hasRetryPolicy() {
      return retryOrHedgingPolicyCase_ == 6;
    }
    /**
     * <code>.grpc.MethodConfig.RetryPolicy retry_policy = 6;</code>
     */
    public io.grpc.serviceconfig.MethodConfig.RetryPolicy getRetryPolicy() {
      if (retryPolicyBuilder_ == null) {
        if (retryOrHedgingPolicyCase_ == 6) {
          return (io.grpc.serviceconfig.MethodConfig.RetryPolicy) retryOrHedgingPolicy_;
        }
        return io.grpc.serviceconfig.MethodConfig.RetryPolicy.getDefaultInstance();
      } else {
        if (retryOrHedgingPolicyCase_ == 6) {
          return retryPolicyBuilder_.getMessage();
        }
        return io.grpc.serviceconfig.MethodConfig.RetryPolicy.getDefaultInstance();
      }
    }
    /**
     * <code>.grpc.MethodConfig.RetryPolicy retry_policy = 6;</code>
     */
    public Builder setRetryPolicy(io.grpc.serviceconfig.MethodConfig.RetryPolicy value) {
      if (retryPolicyBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        retryOrHedgingPolicy_ = value;
        onChanged();
      } else {
        retryPolicyBuilder_.setMessage(value);
      }
      retryOrHedgingPolicyCase_ = 6;
      return this;
    }
    /**
     * <code>.grpc.MethodConfig.RetryPolicy retry_policy = 6;</code>
     */
    public Builder setRetryPolicy(
        io.grpc.serviceconfig.MethodConfig.RetryPolicy.Builder builderForValue) {
      if (retryPolicyBuilder_ == null) {
        retryOrHedgingPolicy_ = builderForValue.build();
        onChanged();
      } else {
        retryPolicyBuilder_.setMessage(builderForValue.build());
      }
      retryOrHedgingPolicyCase_ = 6;
      return this;
    }
    /**
     * <code>.grpc.MethodConfig.RetryPolicy retry_policy = 6;</code>
     */
    public Builder mergeRetryPolicy(io.grpc.serviceconfig.MethodConfig.RetryPolicy value) {
      if (retryPolicyBuilder_ == null) {
        if (retryOrHedgingPolicyCase_ == 6 &&
            retryOrHedgingPolicy_ != io.grpc.serviceconfig.MethodConfig.RetryPolicy.getDefaultInstance()) {
          retryOrHedgingPolicy_ = io.grpc.serviceconfig.MethodConfig.RetryPolicy.newBuilder((io.grpc.serviceconfig.MethodConfig.RetryPolicy) retryOrHedgingPolicy_)
              .mergeFrom(value).buildPartial();
        } else {
          retryOrHedgingPolicy_ = value;
        }
        onChanged();
      } else {
        if (retryOrHedgingPolicyCase_ == 6) {
          retryPolicyBuilder_.mergeFrom(value);
        }
        retryPolicyBuilder_.setMessage(value);
      }
      retryOrHedgingPolicyCase_ = 6;
      return this;
    }
    /**
     * <code>.grpc.MethodConfig.RetryPolicy retry_policy = 6;</code>
     */
    public Builder clearRetryPolicy() {
      if (retryPolicyBuilder_ == null) {
        if (retryOrHedgingPolicyCase_ == 6) {
          retryOrHedgingPolicyCase_ = 0;
          retryOrHedgingPolicy_ = null;
          onChanged();
        }
      } else {
        if (retryOrHedgingPolicyCase_ == 6) {
          retryOrHedgingPolicyCase_ = 0;
          retryOrHedgingPolicy_ = null;
        }
        retryPolicyBuilder_.clear();
      }
      return this;
    }
    /**
     * <code>.grpc.MethodConfig.RetryPolicy retry_policy = 6;</code>
     */
    public io.grpc.serviceconfig.MethodConfig.RetryPolicy.Builder getRetryPolicyBuilder() {
      return getRetryPolicyFieldBuilder().getBuilder();
    }
    /**
     * <code>.grpc.MethodConfig.RetryPolicy retry_policy = 6;</code>
     */
    public io.grpc.serviceconfig.MethodConfig.RetryPolicyOrBuilder getRetryPolicyOrBuilder() {
      if ((retryOrHedgingPolicyCase_ == 6) && (retryPolicyBuilder_ != null)) {
        return retryPolicyBuilder_.getMessageOrBuilder();
      } else {
        if (retryOrHedgingPolicyCase_ == 6) {
          return (io.grpc.serviceconfig.MethodConfig.RetryPolicy) retryOrHedgingPolicy_;
        }
        return io.grpc.serviceconfig.MethodConfig.RetryPolicy.getDefaultInstance();
      }
    }
    /**
     * <code>.grpc.MethodConfig.RetryPolicy retry_policy = 6;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.serviceconfig.MethodConfig.RetryPolicy, io.grpc.serviceconfig.MethodConfig.RetryPolicy.Builder, io.grpc.serviceconfig.MethodConfig.RetryPolicyOrBuilder> 
        getRetryPolicyFieldBuilder() {
      if (retryPolicyBuilder_ == null) {
        if (!(retryOrHedgingPolicyCase_ == 6)) {
          retryOrHedgingPolicy_ = io.grpc.serviceconfig.MethodConfig.RetryPolicy.getDefaultInstance();
        }
        retryPolicyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.serviceconfig.MethodConfig.RetryPolicy, io.grpc.serviceconfig.MethodConfig.RetryPolicy.Builder, io.grpc.serviceconfig.MethodConfig.RetryPolicyOrBuilder>(
                (io.grpc.serviceconfig.MethodConfig.RetryPolicy) retryOrHedgingPolicy_,
                getParentForChildren(),
                isClean());
        retryOrHedgingPolicy_ = null;
      }
      retryOrHedgingPolicyCase_ = 6;
      onChanged();;
      return retryPolicyBuilder_;
    }

    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.serviceconfig.MethodConfig.HedgingPolicy, io.grpc.serviceconfig.MethodConfig.HedgingPolicy.Builder, io.grpc.serviceconfig.MethodConfig.HedgingPolicyOrBuilder> hedgingPolicyBuilder_;
    /**
     * <code>.grpc.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
     */
    public boolean hasHedgingPolicy() {
      return retryOrHedgingPolicyCase_ == 7;
    }
    /**
     * <code>.grpc.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
     */
    public io.grpc.serviceconfig.MethodConfig.HedgingPolicy getHedgingPolicy() {
      if (hedgingPolicyBuilder_ == null) {
        if (retryOrHedgingPolicyCase_ == 7) {
          return (io.grpc.serviceconfig.MethodConfig.HedgingPolicy) retryOrHedgingPolicy_;
        }
        return io.grpc.serviceconfig.MethodConfig.HedgingPolicy.getDefaultInstance();
      } else {
        if (retryOrHedgingPolicyCase_ == 7) {
          return hedgingPolicyBuilder_.getMessage();
        }
        return io.grpc.serviceconfig.MethodConfig.HedgingPolicy.getDefaultInstance();
      }
    }
    /**
     * <code>.grpc.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
     */
    public Builder setHedgingPolicy(io.grpc.serviceconfig.MethodConfig.HedgingPolicy value) {
      if (hedgingPolicyBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        retryOrHedgingPolicy_ = value;
        onChanged();
      } else {
        hedgingPolicyBuilder_.setMessage(value);
      }
      retryOrHedgingPolicyCase_ = 7;
      return this;
    }
    /**
     * <code>.grpc.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
     */
    public Builder setHedgingPolicy(
        io.grpc.serviceconfig.MethodConfig.HedgingPolicy.Builder builderForValue) {
      if (hedgingPolicyBuilder_ == null) {
        retryOrHedgingPolicy_ = builderForValue.build();
        onChanged();
      } else {
        hedgingPolicyBuilder_.setMessage(builderForValue.build());
      }
      retryOrHedgingPolicyCase_ = 7;
      return this;
    }
    /**
     * <code>.grpc.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
     */
    public Builder mergeHedgingPolicy(io.grpc.serviceconfig.MethodConfig.HedgingPolicy value) {
      if (hedgingPolicyBuilder_ == null) {
        if (retryOrHedgingPolicyCase_ == 7 &&
            retryOrHedgingPolicy_ != io.grpc.serviceconfig.MethodConfig.HedgingPolicy.getDefaultInstance()) {
          retryOrHedgingPolicy_ = io.grpc.serviceconfig.MethodConfig.HedgingPolicy.newBuilder((io.grpc.serviceconfig.MethodConfig.HedgingPolicy) retryOrHedgingPolicy_)
              .mergeFrom(value).buildPartial();
        } else {
          retryOrHedgingPolicy_ = value;
        }
        onChanged();
      } else {
        if (retryOrHedgingPolicyCase_ == 7) {
          hedgingPolicyBuilder_.mergeFrom(value);
        }
        hedgingPolicyBuilder_.setMessage(value);
      }
      retryOrHedgingPolicyCase_ = 7;
      return this;
    }
    /**
     * <code>.grpc.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
     */
    public Builder clearHedgingPolicy() {
      if (hedgingPolicyBuilder_ == null) {
        if (retryOrHedgingPolicyCase_ == 7) {
          retryOrHedgingPolicyCase_ = 0;
          retryOrHedgingPolicy_ = null;
          onChanged();
        }
      } else {
        if (retryOrHedgingPolicyCase_ == 7) {
          retryOrHedgingPolicyCase_ = 0;
          retryOrHedgingPolicy_ = null;
        }
        hedgingPolicyBuilder_.clear();
      }
      return this;
    }
    /**
     * <code>.grpc.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
     */
    public io.grpc.serviceconfig.MethodConfig.HedgingPolicy.Builder getHedgingPolicyBuilder() {
      return getHedgingPolicyFieldBuilder().getBuilder();
    }
    /**
     * <code>.grpc.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
     */
    public io.grpc.serviceconfig.MethodConfig.HedgingPolicyOrBuilder getHedgingPolicyOrBuilder() {
      if ((retryOrHedgingPolicyCase_ == 7) && (hedgingPolicyBuilder_ != null)) {
        return hedgingPolicyBuilder_.getMessageOrBuilder();
      } else {
        if (retryOrHedgingPolicyCase_ == 7) {
          return (io.grpc.serviceconfig.MethodConfig.HedgingPolicy) retryOrHedgingPolicy_;
        }
        return io.grpc.serviceconfig.MethodConfig.HedgingPolicy.getDefaultInstance();
      }
    }
    /**
     * <code>.grpc.MethodConfig.HedgingPolicy hedging_policy = 7;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.grpc.serviceconfig.MethodConfig.HedgingPolicy, io.grpc.serviceconfig.MethodConfig.HedgingPolicy.Builder, io.grpc.serviceconfig.MethodConfig.HedgingPolicyOrBuilder> 
        getHedgingPolicyFieldBuilder() {
      if (hedgingPolicyBuilder_ == null) {
        if (!(retryOrHedgingPolicyCase_ == 7)) {
          retryOrHedgingPolicy_ = io.grpc.serviceconfig.MethodConfig.HedgingPolicy.getDefaultInstance();
        }
        hedgingPolicyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.grpc.serviceconfig.MethodConfig.HedgingPolicy, io.grpc.serviceconfig.MethodConfig.HedgingPolicy.Builder, io.grpc.serviceconfig.MethodConfig.HedgingPolicyOrBuilder>(
                (io.grpc.serviceconfig.MethodConfig.HedgingPolicy) retryOrHedgingPolicy_,
                getParentForChildren(),
                isClean());
        retryOrHedgingPolicy_ = null;
      }
      retryOrHedgingPolicyCase_ = 7;
      onChanged();;
      return hedgingPolicyBuilder_;
    }
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFieldsProto3(unknownFields);
    }

    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:grpc.MethodConfig)
  }

  // @@protoc_insertion_point(class_scope:grpc.MethodConfig)
  private static final io.grpc.serviceconfig.MethodConfig DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.grpc.serviceconfig.MethodConfig();
  }

  public static io.grpc.serviceconfig.MethodConfig getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<MethodConfig>
      PARSER = new com.google.protobuf.AbstractParser<MethodConfig>() {
    public MethodConfig parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new MethodConfig(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<MethodConfig> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<MethodConfig> getParserForType() {
    return PARSER;
  }

  public io.grpc.serviceconfig.MethodConfig getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

