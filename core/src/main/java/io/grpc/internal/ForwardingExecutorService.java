package io.grpc.internal;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.AbstractExecutorService;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * TODO: Insert description here. (generated by notcarl)
 */
public final class ForwardingExecutorService extends AbstractExecutorService {
  private final Set<Future<?>> activeTasks =
      Collections.newSetFromMap(new ConcurrentHashMap<Future<?>, Boolean>());
  private final ExecutorService delegate;
  private boolean isShutdown;

  public ForwardingExecutorService(ExecutorService delegate) {
    this.delegate = delegate;
  }

  @Override
  public synchronized void shutdown() {
    isShutdown = true;
  }

  @Override
  public synchronized List<Runnable> shutdownNow() {
    isShutdown = true;
    for (Future<?> future : activeTasks) {
      future.cancel(true);
    }
    return null;
  }

  @Override
  public synchronized boolean isShutdown() {
    return isShutdown;
  }

  @Override
  public boolean isTerminated() {
    return false;
  }

  @Override
  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
    unit.timedWait(this, timeout);
    // TODO(notcarl): Auto-generated method stub
    return false;
  }

  @Override
  public synchronized void execute(final Runnable command) {

    final LinkedBlockingQueue<Runnable> q = new LinkedBlockingQueue<Runnable>();
    q.put(command);
    delegate.submit(new Runnable() {

      @Override
      public void run() {
        q.take();
        // TODO(notcarl): Auto-generated method stub

      }});

    final Runnable r = new Runnable() {
      @Override
      public void run() {
        command.run();
      }
    };

    final Future<?> future = delegate.submit(new Runnable() {
      @Override
      public void run() {
        try {
          r.run();
        } finally {
          synchronized (ForwardingExecutorService.this) {
            activeTasks.remove(r);
          }
        }
      }
    });

    activeTasks.add(future);
  }
}

